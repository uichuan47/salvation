{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u524d\u8fdb\ud83c\udf0a","title":"Home"},{"location":"#_1","text":"","title":"\u524d\u8fdb\ud83c\udf0a"},{"location":"ThankU/","text":"2022/9/16 \u9996\u5148\u662f\uff0c\u5bf9\u4e4b\u524d\u7684\u751f\u6d3b\u753b\u4e0a\u53e5\u53f7\uff0c \u5728\u6b64\u611f\u8c22\u6211\u7684\u7236\u6bcd\uff0c\u670b\u53cb\u5bf9\u6211\u7684\u652f\u6301(\u7cbe\u795e\u4e0a\u7684\u6216\u662f\u7269\u8d28\u4e0a)\uff0c\u8ba9\u6211\u8d70\u5230\u4eca\u5929\uff0c \u8ba9\u6211\u6709\u4e86\u4e00\u4e2a\u65b0\u7684\u673a\u4f1a\u53bb\u5f00\u59cb\ud83c\udf88\uff0c\u53bb\u7ed9\u6211\u7684\u4eba\u751f\u518d\u4e00\u4e2a\u8f6c\u6298\u7684\u673a\u4f1a\uff0c \u6211\u4e0d\u4f1a\u8ba9\u4f60\u4eec\u5931\u671b\uff0c \u8bdd\u5c31\u8bf4\u5230\u8fd9\u91cc\u4e86\uff0c\u4e0d\u5fc5\u518d\u591a\u8bf4\u4e86\u3002 \u8fd9\u4e9b\u7167\u7247\u4f1a\u5728\u4eca\u540e\u7684\u751f\u6d3b\u4e2d\u7ed9\u6211\u5f88\u5927\u7684\u9f13\u52b1","title":"ThankU"},{"location":"C%282022%29/before/before/","text":"\u524d\u620f 1.\u6570\u636e\u7c7b\u578b 2.\u6df7\u5408\u8fd0\u7b97 3.\u6574\u578b\u8fdb\u5236\u8f6c\u6362","title":"1.\u6570\u636e\u7c7b\u578b\u548c\u8f93\u5165\u8f93\u51fa"},{"location":"C%282022%29/before/before/#_1","text":"","title":"\u524d\u620f"},{"location":"C%282022%29/before/before/#1","text":"","title":"1.\u6570\u636e\u7c7b\u578b"},{"location":"C%282022%29/before/before/#2","text":"","title":"2.\u6df7\u5408\u8fd0\u7b97"},{"location":"C%282022%29/before/before/#3","text":"","title":"3.\u6574\u578b\u8fdb\u5236\u8f6c\u6362"},{"location":"C%282022%29/expression/expression/","text":"\u8fd0\u7b97\u7b26\u4e0e\u8868\u8fbe\u5f0f \u903b\u8f91\u8fd0\u7b97","title":"3.\u8fd0\u7b97\u7b26\u4e0e\u903b\u8f91\u8fd0\u7b97"},{"location":"C%282022%29/expression/expression/#_1","text":"","title":"\u8fd0\u7b97\u7b26\u4e0e\u8868\u8fbe\u5f0f"},{"location":"C%282022%29/expression/expression/#_2","text":"","title":"\u903b\u8f91\u8fd0\u7b97"},{"location":"C%282022%29/pointer/pointer/","text":"\u6307\u9488 \u6458\u8981\uff1a \u6307\u9488\u7684\u672c\u8d28 \u6307\u9488\u7684\u4f20\u9012\u548c\u504f\u79fb \u4e8c\u7ea7\u6307\u9488 \u5bf932\u4f4d\u64cd\u4f5c\u7cfb\u7edf\u6765\u8bf4\uff0c\u670932\u6839\u603b\u7ebf\uff0c \u5185\u5b58\u5730\u5740\u6700\u591a2^32\u4e2a\uff0c\u7528\u4e8c\u8fdb\u5236\u7f16\u7801\u5730\u5740\u7684\u8bdd\u5e94\u8be5\u662f32\u4e2abit\uff0c\u4e5f\u5c31\u662f4\u4e2abyte\u7684\u5927\u5c0f\u7528\u6765\u5b58\u5185\u5b58\u5730\u5740\u3002 \u752816\u8fdb\u5236\u8868\u793a\u5c31\u662f8\u4e2a16\u8fdb\u5236\u6570 \u5728\u5185\u5b58\u89c6\u56fe\u4e2d\u67e5\u770b\uff1a - \u770b\u5230\u56db\u7ec4\u5341\u516d\u8fdb\u5236\u6570 - \u6bcf\u7ec4\u4e24\u4f4d 1.\u6307\u9488\u7684\u5b9a\u4e49 \u6307\u9488\u53d8\u91cf\u5b58\u50a8\u7684\u5185\u5bb9\u662f\u4e00\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740 \u5185\u5b58\u5730\u5740\uff08\u9488\u5bf932\u4f4d\u64cd\u4f5c\u7cfb\u7edf\uff09 \u6bcf\u4e00\u4e2a\u5185\u5b58\u5730\u5740\u5bf9\u5e944\u5b57\u8282 #include <stdio.h> int main(){ int i=5; int *i_pointer = &i; // \u5b9a\u4e49\u4e00\u4e2a\u6307\u9488\u53d8\u91cfi_pointer \u5b58\u50a8i\u7684\u5185\u5b58\u5730\u5740 } \u6307\u9488\u53d8\u91cf\u7684\u521d\u59cb\u5316\u4e00\u5b9a\u6307\u5411\u67d0\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740 \u53d6\u5730\u5740\u64cd\u4f5c\u7b26\u4e0e\u53d6\u503c\u64cd\u4f5c\u7b26 \u53d6\u5730\u5740\u64cd\u4f5c\u7b26&\uff0c\u901a\u8fc7\u8fd9\u4e2a\u64cd\u4f5c\u7b26\u53ef\u4ee5\u83b7\u53d6\u4e00\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740\u503c \u53d6\u503c\u64cd\u4f5c\u7b26*\uff0c\u53ef\u4ee5\u83b7\u5f97\u4e00\u4e2a\u5730\u5740\u5bf9\u5e94\u7684\u6570\u636e #include <stdio.h> int main() { int i = 5; int* p = &i; printf(\"i=%d\\n\",i);//\u76f4\u63a5\u8bbf\u95ee printf(\"*p=%d\\n\",*p);//\u901a\u8fc7\u5185\u5b58\u5730\u5740\u95f4\u63a5\u8bbf\u95ee } \u9700\u8981\u6ce8\u610f\uff1a \u5b9a\u4e49\u6307\u9488\u53d8\u91cf\u65f6\u5fc5\u987b\u5236\u5b9a\u6307\u9488\u53d8\u91cf\u7684\u7c7b\u578b\uff0c\u6574\u578b\u53d8\u91cf\u6307\u9488\u548c\u6d6e\u70b9\u578b\u53d8\u91cf\u6307\u9488\u4e0d\u80fd\u6df7\u7528 \u53ea\u6709\u6574\u5f62\u53d8\u91cf\u7684\u5730\u5740\u624d\u80fd\u653e\u5230\u6307\u5411\u6574\u578b\u53d8\u91cf\u7684\u6307\u9488\u53d8\u91cf\u4e2d\u3002 2. \u6307\u9488\u7684\u4f7f\u7528\u573a\u666f \u4f20\u9012\uff0cc\u8bed\u8a00\u7684\u51fd\u6570\u8c03\u7528\u662f\u503c\u4f20\u9012\uff0c\u5b9e\u53c2\u8d4b\u503c\u7ed9\u884c\u53c2 \u504f\u79fb 2.1 \u6307\u9488\u7684\u4f20\u9012 c\u8bed\u8a00\u51fd\u6570\u8c03\u7528\u91c7\u53d6\u503c\u4f20\u9012 #include <stdio.h> void change(int j) { j = 5; } int main() { int i = 10; printf(\"before change i=%d\",i); change(i); printf(\"after change i=%d\",i); return 0; } /Users/uichuan/CLionProjects/c2022/pointer/cmake-build-debug/pointer before change i=10 after change i=10 Process finished with exit code 0 \u5f53main\u51fd\u6570\u5f00\u59cb\u6267\u884c\u65f6\uff0c\u5f00\u8f9f\u6808\u7a7a\u95f4\uff0c\u5728\u8c03\u7528change\u51fd\u6570\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4e3achange\u51fd\u6570\u4ee5\u53ca\u5176\u5185\u90e8\u53c2\u6570\u5728\u6808\u7a7a\u95f4\u5185\u5206\u914d\u5185\u5b58\u7a7a\u95f4\u3002 \u5728\u8c03\u7528change\u51fd\u6570\u65f6\uff0c \u5b9e\u9645\u4e0a\u662f\u5c06i\u7684\u503c\u8d4b\u7ed9j\uff08\u503c\u4f20\u9012\uff09 \uff0c \u5f53change\u51fd\u6570\u6267\u884c\u7ed3\u675f\u540e\uff0c\u6808\u7a7a\u95f4\u91ca\u653e \uff0cj\u88ab\u91ca\u653e\uff0ci\u4e0d\u4f1a\u6539\u53d8 2.2 \u6307\u9488\u7684\u504f\u79fb \u6307\u9488\u504f\u79fb\u7684\u957f\u5ea6\u662f\u5176\u57fa\u7c7b\u578b\u7684\u957f\u5ea6 \uff0csizeof\uff08ElemType\uff09 void\u7c7b\u578b\u7684\u6307\u9488\u65e0\u6cd5\u504f\u79fb #include <stdio.h> int main() { int a[5] = {1,2,3,4,5}; int *p; //\u5bf9\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\u8fdb\u884c\u53d6\u503c\uff0c\u5f97\u5230\u7684\u7c7b\u578b\u662f\u5176\u57fa\u7c7b\u578b p = a; printf(\"*p=%d\\n\",*p); for(int i=0;i<5;i++) { printf(\"%d\\n\",*(p+1)); } } 3.\u6307\u9488\u4e0e\u4e00\u7ef4\u6570\u7ec4 \u4e00\u7ef4\u6570\u7ec4\u7684\u6570\u7ec4\u53d8\u91cf\u540d\u5b58\u50a8\u7684\u662f\u6570\u7ec4\u7684\u9996\u5730\u5740 \u6570\u7ec4 \u4f20\u9012\u65f6\uff0c \u5f31\u5316\u4e3a\u6307\u9488 #include <stdio.h> void change(char *d) { d[0]; } int main() { char c[10] = \"hello\"; change(c); } 4. \u52a8\u6001\u5185\u5b58\u7533\u8bf7malloc c\u8bed\u8a00\u7684\u6570\u7ec4\u957f\u5ea6\u56fa\u5b9a\u662f\u56e0\u4e3a\u5176\u5b9a\u4e49\u7684\u6574\u578b\uff0c\u6d6e\u70b9\u578b\uff0c\u5b57\u7b26\u578b\u53d8\u91cf\uff0c\u6570\u7ec4\u53d8\u91cf\u90fd\u5728\u6808\u7a7a\u95f4\u4e2d\uff0c \u6808\u7a7a\u95f4\u7684\u5927\u5c0f\u5728\u7f16\u8bd1\u65f6\u662f\u786e\u5b9a\u7684\uff0c\u5982\u679c\u4f7f\u7528\u7a7a\u95f4\u7684\u5927\u5c0f\u4e0d\u786e\u5b9a\uff0c\u90a3\u4e48\u5c31\u8981\u4f7f\u7528\u5806\u7a7a\u95f4\u3002 \u4f7f\u7528 malloc \u7533\u8bf7\u7684\u662f\u5806\u7a7a\u95f4\uff0c\u4e0d\u4f1a\u968f\u7740\u51fd\u6570\u7684\u6267\u884c\u7ed3\u675f\u800c\u91ca\u653e #include <stdio.h> int main() { int i;//\u7533\u8bf7\u591a\u5927\u7a7a\u95f4 scanf(\"%d\",&i); char *p; p = (char*)malloc(i);//malloc\u7533\u8bf7\u7a7a\u95f4\u7684\u5355\u4f4d\u662f\u5b57\u8282 strcpy(p,\"malloc success\"); puts(p); free(p);//\u91ca\u653e\u7a7a\u95f4 p = NULL;//\u5982\u679c\u4e0d\u628ap\u7f6e\u4e3aNULL\uff0c\u5219p\u4e3a\u91ce\u6307\u9488 return 0; } \u91ca\u653e\u7a7a\u95f4\u65f6p\u7684\u503c\u5fc5\u987b\u548c\u521d\u59cb\u65f6\u4e00\u6837\uff0c\u91ca\u653e\u7a7a\u95f4\u65f6\u6307\u9488\u4e0d\u80fd\u504f\u79fb void *p --\u65e0\u7c7b\u578b\u6307\u9488 malloc\u8fd4\u56de\u65e0\u7c7b\u578b\u6307\u9488 5. \u6808\u7a7a\u95f4\u4e0e\u5806\u7a7a\u95f4\u7684\u5dee\u5f02 \u5728\u6808\u7a7a\u95f4\u5185\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u91ca\u653e\u5185\u5b58\uff08\u5728\u51fd\u6570\u7ed3\u675f\u4e4b\u540e\uff09 \u5806\u7a7a\u95f4\u5185\uff0c\u5728\u7a0b\u5e8f\u91ca\u653e\u7a7a\u95f4\u4e4b\u524d\uff0c\u4e0d\u4f1a\u91ca\u653e\u5185\u5b58 #include <stdio.h> #include <stdlib.h> #include <string.h> char* print_stack() { char c[17] = \"i am print_stack\"; puts(c); return c; } char *print_malloc() { char *p = (char*)malloc(30);//\u7533\u8bf720\u5b57\u8282\u5806\u7a7a\u95f4\uff0c\u63a5\u6536\u5b57\u7b26\u578b\u6307\u9488 strcpy(p,\"i am print_malloc\"); puts(p); return p; } int main() { char *p; p = print_stack();//\u6808\u7a7a\u95f4\u4f1a\u968f\u7740\u51fd\u6570\u7684\u6267\u884c\u7ed3\u675f\u800c\u91ca\u653e //puts(p); p = print_malloc(); //\u6b64\u5904p\u6307\u5411\u5806\u7a7a\u95f4\uff0c\u4e0d\u4f1a\u56e0\u4e3aprint_malloc()\u51fd\u6570\u7684\u6267\u884c\u7ed3\u675f\u800c\u91ca\u653e\u5185\u5b58\u7a7a\u95f4 puts(p); return 0; } i am print_stack \u0001F // \u4ea7\u751f\u4e71\u7801-> \u5185\u5b58\u7a7a\u95f4\u5df2\u7ecf\u88ab\u91ca\u653e i am print_malloc i am print_malloc 6.\u5b57\u7b26\u6307\u9488\u4e0e\u5b57\u7b26\u6570\u7ec4\u7684\u521d\u59cb\u5316 \u5b57\u7b26\u6307\u9488\u53ef\u4ee5\u521d\u59cb\u5316\u8d4b\u503c\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u6570\u7ec4\u521d\u59cb\u5316\u4e5f\u53ef\u4ee5\u8d4b\u503c\u4e00\u4e2a\u5b57\u7b26\u4e32 #include <stdio.h> #include <stdlib.h> #include <string.h> int main() { char *p = \"hello\"; //\u628a\u5b57\u7b26\u4e32\u578b\u5e38\u91cf\"hello\"\u9996\u5730\u5740\u7ed9p char c[10] = \"hello\";//\u7b49\u4ef7\u4e8estrcpy(c,\"hello\")\uff0c\u6808\u7a7a\u95f4\u5185 c[0] = 'H';//\u5728\u6808\u7a7a\u95f4\u5185\uff0c\u53ef\u4ee5\u4fee\u6539 p[0] = 'H';//\u6307\u9488\u6307\u5411\u7684\u6570\u636e\u533a\u57df\u4e0d\u53ef\u4ee5\u4fee\u6539 p = \"world\";//\u5c06\u5b57\u7b26\u4e32\"world\"\u9996\u5730\u5740\u8d4b\u503c\u7ed9\u6307\u9488\u53d8\u91cfp c = \"world\";//\u975e\u6cd5\uff0cc\u5df2\u7ecf\u6709\u56fa\u5b9a\u7684\u5185\u5b58\u5730\u5740 return 0; } 7.\u4e8c\u7ea7\u6307\u9488 \u4e00\u7ea7\u6307\u9488\u7684\u4f7f\u7528\u573a\u666f\u662f\u4f20\u9012\u548c\u504f\u79fb\uff0c \u4e8c\u7ea7\u6307\u9488\u53ea\u670d\u52a1\u4e8e\u4e00\u7ea7\u6307\u9488\u7684\u4f20\u9012\u548c\u504f\u79fb\u3002 #include <stdio.h> void change(int **pi, int *pj) { *pi = pj; } // \u60f3\u8981\u5728\u5b50\u51fd\u6570\u4e2d\u6539\u53d8\u4e00\u4e2a\u53d8\u91cf\u7684\u503c\uff0c\u5fc5\u987b\u4f20\u5165\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740 //\u540c\u7406\uff0c\u60f3\u8981\u5728\u5b50\u51fd\u6570\u4e2d\u6539\u53d8\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\u7684\u503c\uff0c\u5fc5\u987b\u4f20\u5165 \u6307\u9488\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740` int main() { int i = 10; int j = 5; int *pi = &i; int *pj = &j; printf(\"pi_value=%d\\n\", *pi); change(&pi, pj); printf(\"pi_value=%d\\n\", *pi); // &pi\u6b64\u65f6\u76f8\u5f53\u4e8e\u4e8c\u7ea7\u6307\u9488\uff0c\u7528\u4e8c\u7ea7\u6307\u9488\u6539\u53d8pi\u7684\u5185\u5bb9 } pi_value=10 // \u901a\u8fc7\u4e8c\u7ea7\u6307\u9488change\u524d---\u8f93\u51fapi\u6307\u9488\u6307\u5411\u7684\u503c pi_value=5 // \u901a\u8fc7\u4e8c\u7ea7\u6307\u9488change\u540e---\u8f93\u51fapi\u6307\u9488\u6307\u5411\u7684\u503c \u4e8c\u7ea7\u6307\u9488\u7684\u521d\u59cb\u5316\u662f\u4e00\u7ea7\u6307\u9488\u53d6\u5730\u5740 int **p2; p2 = &p; //p\u6b64\u65f6\u662f\u4e00\u7ea7\u6307\u9488","title":"4.\u6307\u9488"},{"location":"C%282022%29/pointer/pointer/#_1","text":"\u6458\u8981\uff1a \u6307\u9488\u7684\u672c\u8d28 \u6307\u9488\u7684\u4f20\u9012\u548c\u504f\u79fb \u4e8c\u7ea7\u6307\u9488 \u5bf932\u4f4d\u64cd\u4f5c\u7cfb\u7edf\u6765\u8bf4\uff0c\u670932\u6839\u603b\u7ebf\uff0c \u5185\u5b58\u5730\u5740\u6700\u591a2^32\u4e2a\uff0c\u7528\u4e8c\u8fdb\u5236\u7f16\u7801\u5730\u5740\u7684\u8bdd\u5e94\u8be5\u662f32\u4e2abit\uff0c\u4e5f\u5c31\u662f4\u4e2abyte\u7684\u5927\u5c0f\u7528\u6765\u5b58\u5185\u5b58\u5730\u5740\u3002 \u752816\u8fdb\u5236\u8868\u793a\u5c31\u662f8\u4e2a16\u8fdb\u5236\u6570 \u5728\u5185\u5b58\u89c6\u56fe\u4e2d\u67e5\u770b\uff1a - \u770b\u5230\u56db\u7ec4\u5341\u516d\u8fdb\u5236\u6570 - \u6bcf\u7ec4\u4e24\u4f4d","title":"\u6307\u9488"},{"location":"C%282022%29/pointer/pointer/#1","text":"\u6307\u9488\u53d8\u91cf\u5b58\u50a8\u7684\u5185\u5bb9\u662f\u4e00\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740 \u5185\u5b58\u5730\u5740\uff08\u9488\u5bf932\u4f4d\u64cd\u4f5c\u7cfb\u7edf\uff09 \u6bcf\u4e00\u4e2a\u5185\u5b58\u5730\u5740\u5bf9\u5e944\u5b57\u8282 #include <stdio.h> int main(){ int i=5; int *i_pointer = &i; // \u5b9a\u4e49\u4e00\u4e2a\u6307\u9488\u53d8\u91cfi_pointer \u5b58\u50a8i\u7684\u5185\u5b58\u5730\u5740 } \u6307\u9488\u53d8\u91cf\u7684\u521d\u59cb\u5316\u4e00\u5b9a\u6307\u5411\u67d0\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740","title":"1.\u6307\u9488\u7684\u5b9a\u4e49"},{"location":"C%282022%29/pointer/pointer/#_2","text":"\u53d6\u5730\u5740\u64cd\u4f5c\u7b26&\uff0c\u901a\u8fc7\u8fd9\u4e2a\u64cd\u4f5c\u7b26\u53ef\u4ee5\u83b7\u53d6\u4e00\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740\u503c \u53d6\u503c\u64cd\u4f5c\u7b26*\uff0c\u53ef\u4ee5\u83b7\u5f97\u4e00\u4e2a\u5730\u5740\u5bf9\u5e94\u7684\u6570\u636e #include <stdio.h> int main() { int i = 5; int* p = &i; printf(\"i=%d\\n\",i);//\u76f4\u63a5\u8bbf\u95ee printf(\"*p=%d\\n\",*p);//\u901a\u8fc7\u5185\u5b58\u5730\u5740\u95f4\u63a5\u8bbf\u95ee } \u9700\u8981\u6ce8\u610f\uff1a \u5b9a\u4e49\u6307\u9488\u53d8\u91cf\u65f6\u5fc5\u987b\u5236\u5b9a\u6307\u9488\u53d8\u91cf\u7684\u7c7b\u578b\uff0c\u6574\u578b\u53d8\u91cf\u6307\u9488\u548c\u6d6e\u70b9\u578b\u53d8\u91cf\u6307\u9488\u4e0d\u80fd\u6df7\u7528 \u53ea\u6709\u6574\u5f62\u53d8\u91cf\u7684\u5730\u5740\u624d\u80fd\u653e\u5230\u6307\u5411\u6574\u578b\u53d8\u91cf\u7684\u6307\u9488\u53d8\u91cf\u4e2d\u3002","title":"\u53d6\u5730\u5740\u64cd\u4f5c\u7b26\u4e0e\u53d6\u503c\u64cd\u4f5c\u7b26"},{"location":"C%282022%29/pointer/pointer/#2","text":"\u4f20\u9012\uff0cc\u8bed\u8a00\u7684\u51fd\u6570\u8c03\u7528\u662f\u503c\u4f20\u9012\uff0c\u5b9e\u53c2\u8d4b\u503c\u7ed9\u884c\u53c2 \u504f\u79fb","title":"2. \u6307\u9488\u7684\u4f7f\u7528\u573a\u666f"},{"location":"C%282022%29/pointer/pointer/#21","text":"c\u8bed\u8a00\u51fd\u6570\u8c03\u7528\u91c7\u53d6\u503c\u4f20\u9012 #include <stdio.h> void change(int j) { j = 5; } int main() { int i = 10; printf(\"before change i=%d\",i); change(i); printf(\"after change i=%d\",i); return 0; } /Users/uichuan/CLionProjects/c2022/pointer/cmake-build-debug/pointer before change i=10 after change i=10 Process finished with exit code 0 \u5f53main\u51fd\u6570\u5f00\u59cb\u6267\u884c\u65f6\uff0c\u5f00\u8f9f\u6808\u7a7a\u95f4\uff0c\u5728\u8c03\u7528change\u51fd\u6570\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4e3achange\u51fd\u6570\u4ee5\u53ca\u5176\u5185\u90e8\u53c2\u6570\u5728\u6808\u7a7a\u95f4\u5185\u5206\u914d\u5185\u5b58\u7a7a\u95f4\u3002 \u5728\u8c03\u7528change\u51fd\u6570\u65f6\uff0c \u5b9e\u9645\u4e0a\u662f\u5c06i\u7684\u503c\u8d4b\u7ed9j\uff08\u503c\u4f20\u9012\uff09 \uff0c \u5f53change\u51fd\u6570\u6267\u884c\u7ed3\u675f\u540e\uff0c\u6808\u7a7a\u95f4\u91ca\u653e \uff0cj\u88ab\u91ca\u653e\uff0ci\u4e0d\u4f1a\u6539\u53d8","title":"2.1 \u6307\u9488\u7684\u4f20\u9012"},{"location":"C%282022%29/pointer/pointer/#22","text":"\u6307\u9488\u504f\u79fb\u7684\u957f\u5ea6\u662f\u5176\u57fa\u7c7b\u578b\u7684\u957f\u5ea6 \uff0csizeof\uff08ElemType\uff09 void\u7c7b\u578b\u7684\u6307\u9488\u65e0\u6cd5\u504f\u79fb #include <stdio.h> int main() { int a[5] = {1,2,3,4,5}; int *p; //\u5bf9\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\u8fdb\u884c\u53d6\u503c\uff0c\u5f97\u5230\u7684\u7c7b\u578b\u662f\u5176\u57fa\u7c7b\u578b p = a; printf(\"*p=%d\\n\",*p); for(int i=0;i<5;i++) { printf(\"%d\\n\",*(p+1)); } }","title":"2.2 \u6307\u9488\u7684\u504f\u79fb"},{"location":"C%282022%29/pointer/pointer/#3","text":"\u4e00\u7ef4\u6570\u7ec4\u7684\u6570\u7ec4\u53d8\u91cf\u540d\u5b58\u50a8\u7684\u662f\u6570\u7ec4\u7684\u9996\u5730\u5740 \u6570\u7ec4 \u4f20\u9012\u65f6\uff0c \u5f31\u5316\u4e3a\u6307\u9488 #include <stdio.h> void change(char *d) { d[0]; } int main() { char c[10] = \"hello\"; change(c); }","title":"3.\u6307\u9488\u4e0e\u4e00\u7ef4\u6570\u7ec4"},{"location":"C%282022%29/pointer/pointer/#4-malloc","text":"c\u8bed\u8a00\u7684\u6570\u7ec4\u957f\u5ea6\u56fa\u5b9a\u662f\u56e0\u4e3a\u5176\u5b9a\u4e49\u7684\u6574\u578b\uff0c\u6d6e\u70b9\u578b\uff0c\u5b57\u7b26\u578b\u53d8\u91cf\uff0c\u6570\u7ec4\u53d8\u91cf\u90fd\u5728\u6808\u7a7a\u95f4\u4e2d\uff0c \u6808\u7a7a\u95f4\u7684\u5927\u5c0f\u5728\u7f16\u8bd1\u65f6\u662f\u786e\u5b9a\u7684\uff0c\u5982\u679c\u4f7f\u7528\u7a7a\u95f4\u7684\u5927\u5c0f\u4e0d\u786e\u5b9a\uff0c\u90a3\u4e48\u5c31\u8981\u4f7f\u7528\u5806\u7a7a\u95f4\u3002 \u4f7f\u7528 malloc \u7533\u8bf7\u7684\u662f\u5806\u7a7a\u95f4\uff0c\u4e0d\u4f1a\u968f\u7740\u51fd\u6570\u7684\u6267\u884c\u7ed3\u675f\u800c\u91ca\u653e #include <stdio.h> int main() { int i;//\u7533\u8bf7\u591a\u5927\u7a7a\u95f4 scanf(\"%d\",&i); char *p; p = (char*)malloc(i);//malloc\u7533\u8bf7\u7a7a\u95f4\u7684\u5355\u4f4d\u662f\u5b57\u8282 strcpy(p,\"malloc success\"); puts(p); free(p);//\u91ca\u653e\u7a7a\u95f4 p = NULL;//\u5982\u679c\u4e0d\u628ap\u7f6e\u4e3aNULL\uff0c\u5219p\u4e3a\u91ce\u6307\u9488 return 0; } \u91ca\u653e\u7a7a\u95f4\u65f6p\u7684\u503c\u5fc5\u987b\u548c\u521d\u59cb\u65f6\u4e00\u6837\uff0c\u91ca\u653e\u7a7a\u95f4\u65f6\u6307\u9488\u4e0d\u80fd\u504f\u79fb void *p --\u65e0\u7c7b\u578b\u6307\u9488 malloc\u8fd4\u56de\u65e0\u7c7b\u578b\u6307\u9488","title":"4. \u52a8\u6001\u5185\u5b58\u7533\u8bf7malloc"},{"location":"C%282022%29/pointer/pointer/#5","text":"\u5728\u6808\u7a7a\u95f4\u5185\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u91ca\u653e\u5185\u5b58\uff08\u5728\u51fd\u6570\u7ed3\u675f\u4e4b\u540e\uff09 \u5806\u7a7a\u95f4\u5185\uff0c\u5728\u7a0b\u5e8f\u91ca\u653e\u7a7a\u95f4\u4e4b\u524d\uff0c\u4e0d\u4f1a\u91ca\u653e\u5185\u5b58 #include <stdio.h> #include <stdlib.h> #include <string.h> char* print_stack() { char c[17] = \"i am print_stack\"; puts(c); return c; } char *print_malloc() { char *p = (char*)malloc(30);//\u7533\u8bf720\u5b57\u8282\u5806\u7a7a\u95f4\uff0c\u63a5\u6536\u5b57\u7b26\u578b\u6307\u9488 strcpy(p,\"i am print_malloc\"); puts(p); return p; } int main() { char *p; p = print_stack();//\u6808\u7a7a\u95f4\u4f1a\u968f\u7740\u51fd\u6570\u7684\u6267\u884c\u7ed3\u675f\u800c\u91ca\u653e //puts(p); p = print_malloc(); //\u6b64\u5904p\u6307\u5411\u5806\u7a7a\u95f4\uff0c\u4e0d\u4f1a\u56e0\u4e3aprint_malloc()\u51fd\u6570\u7684\u6267\u884c\u7ed3\u675f\u800c\u91ca\u653e\u5185\u5b58\u7a7a\u95f4 puts(p); return 0; } i am print_stack \u0001F // \u4ea7\u751f\u4e71\u7801-> \u5185\u5b58\u7a7a\u95f4\u5df2\u7ecf\u88ab\u91ca\u653e i am print_malloc i am print_malloc","title":"5. \u6808\u7a7a\u95f4\u4e0e\u5806\u7a7a\u95f4\u7684\u5dee\u5f02"},{"location":"C%282022%29/pointer/pointer/#6","text":"\u5b57\u7b26\u6307\u9488\u53ef\u4ee5\u521d\u59cb\u5316\u8d4b\u503c\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u6570\u7ec4\u521d\u59cb\u5316\u4e5f\u53ef\u4ee5\u8d4b\u503c\u4e00\u4e2a\u5b57\u7b26\u4e32 #include <stdio.h> #include <stdlib.h> #include <string.h> int main() { char *p = \"hello\"; //\u628a\u5b57\u7b26\u4e32\u578b\u5e38\u91cf\"hello\"\u9996\u5730\u5740\u7ed9p char c[10] = \"hello\";//\u7b49\u4ef7\u4e8estrcpy(c,\"hello\")\uff0c\u6808\u7a7a\u95f4\u5185 c[0] = 'H';//\u5728\u6808\u7a7a\u95f4\u5185\uff0c\u53ef\u4ee5\u4fee\u6539 p[0] = 'H';//\u6307\u9488\u6307\u5411\u7684\u6570\u636e\u533a\u57df\u4e0d\u53ef\u4ee5\u4fee\u6539 p = \"world\";//\u5c06\u5b57\u7b26\u4e32\"world\"\u9996\u5730\u5740\u8d4b\u503c\u7ed9\u6307\u9488\u53d8\u91cfp c = \"world\";//\u975e\u6cd5\uff0cc\u5df2\u7ecf\u6709\u56fa\u5b9a\u7684\u5185\u5b58\u5730\u5740 return 0; }","title":"6.\u5b57\u7b26\u6307\u9488\u4e0e\u5b57\u7b26\u6570\u7ec4\u7684\u521d\u59cb\u5316"},{"location":"C%282022%29/pointer/pointer/#7","text":"\u4e00\u7ea7\u6307\u9488\u7684\u4f7f\u7528\u573a\u666f\u662f\u4f20\u9012\u548c\u504f\u79fb\uff0c \u4e8c\u7ea7\u6307\u9488\u53ea\u670d\u52a1\u4e8e\u4e00\u7ea7\u6307\u9488\u7684\u4f20\u9012\u548c\u504f\u79fb\u3002 #include <stdio.h> void change(int **pi, int *pj) { *pi = pj; } // \u60f3\u8981\u5728\u5b50\u51fd\u6570\u4e2d\u6539\u53d8\u4e00\u4e2a\u53d8\u91cf\u7684\u503c\uff0c\u5fc5\u987b\u4f20\u5165\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740 //\u540c\u7406\uff0c\u60f3\u8981\u5728\u5b50\u51fd\u6570\u4e2d\u6539\u53d8\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\u7684\u503c\uff0c\u5fc5\u987b\u4f20\u5165 \u6307\u9488\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740` int main() { int i = 10; int j = 5; int *pi = &i; int *pj = &j; printf(\"pi_value=%d\\n\", *pi); change(&pi, pj); printf(\"pi_value=%d\\n\", *pi); // &pi\u6b64\u65f6\u76f8\u5f53\u4e8e\u4e8c\u7ea7\u6307\u9488\uff0c\u7528\u4e8c\u7ea7\u6307\u9488\u6539\u53d8pi\u7684\u5185\u5bb9 } pi_value=10 // \u901a\u8fc7\u4e8c\u7ea7\u6307\u9488change\u524d---\u8f93\u51fapi\u6307\u9488\u6307\u5411\u7684\u503c pi_value=5 // \u901a\u8fc7\u4e8c\u7ea7\u6307\u9488change\u540e---\u8f93\u51fapi\u6307\u9488\u6307\u5411\u7684\u503c \u4e8c\u7ea7\u6307\u9488\u7684\u521d\u59cb\u5316\u662f\u4e00\u7ea7\u6307\u9488\u53d6\u5730\u5740 int **p2; p2 = &p; //p\u6b64\u65f6\u662f\u4e00\u7ea7\u6307\u9488","title":"7.\u4e8c\u7ea7\u6307\u9488"},{"location":"C%282022%29/scanf/scanf/","text":"scanf\u7684\u539f\u7406 c\u8bed\u8a00\u672a\u63d0\u4f9b\u8f93\u5165/\u8f93\u51fa\u5173\u952e\u5b57\uff0c\u8f93\u5165\u548c\u8f93\u51fa\u901a\u8fc7\u6807\u51c6\u51fd\u6570\u5e93\u5b9e\u73b0 stdio.h #include <stdio.h> 1.\u6807\u51c6\u8f93\u5165\u7f13\u51b2\u533a\uff08stdin\uff09 #include <stdio.h> int main() { int i; char c; scanf(\"%d\",&i); printf(\"%d\\n\",i); scanf(\"%d\",&i); printf(\"%c\\n\",c); } \u5728\u8f93\u5165\u7b2c\u4e00\u4e2a\u6574\u6570\u540e\uff0c\u7b2c\u4e8c\u4e2ascanf\u4e0d\u4f1a\u963b\u585e\uff0c\u76f4\u63a5\u8fd0\u884c\u7ed3\u675f \u539f\u56e0\uff1a \u7b2c\u4e00\u6b21\u8f93\u5165 6969\\n \u8f93\u5165\u6570\u5b57\u540e \u56de\u8f66\uff0c\u51fa\u53d1scanf scanf\u8bfb\u53d6\u6574\u6570 6969 \uff0c\u6b64\u65f6\u6807\u51c6\u8f93\u5165\u7f13\u51b2\u533a\u4e2d\uff1a \\n \u7b2c\u4e8c\u6b21\u8f93\u5165 \u8bfb\u53d6\u5230\u6807\u51c6\u8f93\u5165\u7f13\u51b2\u533a\u4e2d\u6709\u503c \\n \uff0c\u76f4\u63a5\u7ed3\u675f\u8fdb\u7a0b 2.\u5173\u4e8escanf scanf\u51fd\u6570\u5728\u8bfb\u53d6\u6574\u578b\uff0c\u6d6e\u70b9\u6570\uff0c\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5ffd\u7565 \\n(\u56de\u8f66) \uff0c \u7a7a\u683c \u7b49\u5b57\u7b26 scanf\u51fd\u6570\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u4f1a\u9996\u5148\u5220\u9664\u8fd9\u4e9b\u5b57\u7b26\uff0c\u7136\u540e\u518d\u963b\u585e scanf\u51fd\u6570\u5339\u914d\u4e00\u4e2a\u5b57\u7b26\u65f6\uff0c\u4f1a\u5728\u7f13\u51b2\u533a\u5220\u9664\u5bf9\u5e94\u7684\u5b57\u7b26\uff0c\u5e76\u4e14\u5728\u6574\u4e2a\u8fc7\u7a0b\u4e2d\u4e0d\u4f1a\u5ffd\u7565\u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\u5305\u62ec\u6362\u884c\u7b26 \\n - scanf\u7684\u8fd4\u56de\u503c\uff1a\u8fd4\u56de\u5339\u914d\u6210\u529f\u7684\u4e2a\u6570 3.\u591a\u79cd\u6570\u636e\u7c7b\u578b\u6df7\u5408\u8f93\u5165 \u5728\u8f93\u5165\u5b57\u7b26\u7c7b\u578b %c \u65f6\uff0c\u52a0\u5165\u7a7a\u683c\u6765\u907f\u514d\u5339\u914d\u9519\u4f4d\u7684\u60c5\u51b5\uff0c \u56e0\u4e3ascanf\u5728\u5339\u914d\u5b57\u7b26\u7c7b\u578b %c \u7684\u8fc7\u7a0b\u4e2d\uff0c\u4e5f\u4f1a\u5339\u914d\u7a7a\u683c\u7b26 4.\u8bfe\u4ef6","title":"2.scanf"},{"location":"C%282022%29/scanf/scanf/#scanf","text":"c\u8bed\u8a00\u672a\u63d0\u4f9b\u8f93\u5165/\u8f93\u51fa\u5173\u952e\u5b57\uff0c\u8f93\u5165\u548c\u8f93\u51fa\u901a\u8fc7\u6807\u51c6\u51fd\u6570\u5e93\u5b9e\u73b0 stdio.h #include <stdio.h>","title":"scanf\u7684\u539f\u7406"},{"location":"C%282022%29/scanf/scanf/#1stdin","text":"#include <stdio.h> int main() { int i; char c; scanf(\"%d\",&i); printf(\"%d\\n\",i); scanf(\"%d\",&i); printf(\"%c\\n\",c); } \u5728\u8f93\u5165\u7b2c\u4e00\u4e2a\u6574\u6570\u540e\uff0c\u7b2c\u4e8c\u4e2ascanf\u4e0d\u4f1a\u963b\u585e\uff0c\u76f4\u63a5\u8fd0\u884c\u7ed3\u675f \u539f\u56e0\uff1a \u7b2c\u4e00\u6b21\u8f93\u5165 6969\\n \u8f93\u5165\u6570\u5b57\u540e \u56de\u8f66\uff0c\u51fa\u53d1scanf scanf\u8bfb\u53d6\u6574\u6570 6969 \uff0c\u6b64\u65f6\u6807\u51c6\u8f93\u5165\u7f13\u51b2\u533a\u4e2d\uff1a \\n \u7b2c\u4e8c\u6b21\u8f93\u5165 \u8bfb\u53d6\u5230\u6807\u51c6\u8f93\u5165\u7f13\u51b2\u533a\u4e2d\u6709\u503c \\n \uff0c\u76f4\u63a5\u7ed3\u675f\u8fdb\u7a0b","title":"1.\u6807\u51c6\u8f93\u5165\u7f13\u51b2\u533a\uff08stdin\uff09"},{"location":"C%282022%29/scanf/scanf/#2scanf","text":"scanf\u51fd\u6570\u5728\u8bfb\u53d6\u6574\u578b\uff0c\u6d6e\u70b9\u6570\uff0c\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5ffd\u7565 \\n(\u56de\u8f66) \uff0c \u7a7a\u683c \u7b49\u5b57\u7b26 scanf\u51fd\u6570\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u4f1a\u9996\u5148\u5220\u9664\u8fd9\u4e9b\u5b57\u7b26\uff0c\u7136\u540e\u518d\u963b\u585e scanf\u51fd\u6570\u5339\u914d\u4e00\u4e2a\u5b57\u7b26\u65f6\uff0c\u4f1a\u5728\u7f13\u51b2\u533a\u5220\u9664\u5bf9\u5e94\u7684\u5b57\u7b26\uff0c\u5e76\u4e14\u5728\u6574\u4e2a\u8fc7\u7a0b\u4e2d\u4e0d\u4f1a\u5ffd\u7565\u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\u5305\u62ec\u6362\u884c\u7b26 \\n - scanf\u7684\u8fd4\u56de\u503c\uff1a\u8fd4\u56de\u5339\u914d\u6210\u529f\u7684\u4e2a\u6570","title":"2.\u5173\u4e8escanf"},{"location":"C%282022%29/scanf/scanf/#3","text":"\u5728\u8f93\u5165\u5b57\u7b26\u7c7b\u578b %c \u65f6\uff0c\u52a0\u5165\u7a7a\u683c\u6765\u907f\u514d\u5339\u914d\u9519\u4f4d\u7684\u60c5\u51b5\uff0c \u56e0\u4e3ascanf\u5728\u5339\u914d\u5b57\u7b26\u7c7b\u578b %c \u7684\u8fc7\u7a0b\u4e2d\uff0c\u4e5f\u4f1a\u5339\u914d\u7a7a\u683c\u7b26","title":"3.\u591a\u79cd\u6570\u636e\u7c7b\u578b\u6df7\u5408\u8f93\u5165"},{"location":"C%282022%29/scanf/scanf/#4","text":"","title":"4.\u8bfe\u4ef6"},{"location":"C%282022%29/struct/struct/","text":"\u7ed3\u6784\u4f53 C \u8bed\u8a00\u63d0\u4f9b\u7ed3\u6784\u4f53\u6765\u7ba1\u7406\u4e0d\u540c\u7c7b\u578b\u7684\u6570\u636e\u7ec4\u5408 1.\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49\uff0c\u5f15\u7528\uff0c\u521d\u59cb\u5316 struct student{ int num; char name[20]; char sex; int age; }; //\u7ed3\u6784\u4f53\u7c7b\u578b\u58f0\u660e\uff0c\u6ce8\u610f\u6700\u540e\u4e00\u5b9a\u8981\u52a0\u5206\u53f7 int main() { struct student s = {1001,\"lele\",'m',20}; printf(\"%d%s%c%d\\n\",s.num,s.name,s.sex,s.age); //\u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u5efa\u7acb //\u6570\u7ec4\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5b58\u653e\u4e00\u4e2a\u7ed3\u6784\u4f53 struct student sarr[3]; int i; for (i=0;i<3;i++) { scanf(\"%d%s %c%d\",&sarr[i].num,&sarr[i].num,&sarr[i].name,&sarr[i].sex,&sarr[i].age) } return 0; } 2. \u7ed3\u6784\u4f53\u5bf9\u9f50 \u7ed3\u6784\u4f53\u7684\u5927\u5c0f\u5fc5\u987b\u662f\u5176\u6700\u5927\u6210\u5458\u7684\u6574\u6570\u500d #include <stdio.h> struct student_type1{ double score; // double 8\u5b57\u8282 short age; } struct student_type2{ double score; int height; short age; }; struct student_type3{ int height; char sex; short age; }; int main(){ struct student_type1 s1; struct student_type2 s2; struct student_type3 s3; printf(\"s1 size=%d\\n\",sizeof(s1)); printf(\"s2 size=%d\\n\",sizeof(s2)); printf(\"s3 size=%d\\n\",sizeof(s3)); return 0; } s1 size=16 s2 size=16 s3 size=8 Process finished with exit code 0 3. \u7ed3\u6784\u4f53\u6307\u9488 \u4e00\u4e2a\u7ed3\u6784\u4f53\u53d8\u91cf\u7684\u6307\u9488\u5c31\u662f\u8be5\u53d8\u91cf\u6240\u5360\u636e\u7684\u5185\u5b58\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u3002 \u53ef\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\uff0c \u7528\u5b83\u6307\u5411\u4e00\u4e2a\u7ed3\u6784\u4f53\u53d8\u91cf\uff0c \u6b64\u65f6\u8be5\u6307\u9488\u53d8\u91cf\u7684\u503c\u662f\u7ed3\u6784\u4f53\u53d8\u91cf\u7684\u8d77\u59cb\u5730\u5740 \u3002 \u6307\u9488\u53d8\u91cf\u4e5f\u53ef\u4ee5\u7528\u6765 \u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\uff0c\u4ece\u800c\u80fd\u591f\u901a\u8fc7\u7ed3\u6784\u4f53\u6307\u9488\u5feb\u901f\u8bbf\u95ee\u7ed3\u6784\u4f53\u5185\u7684\u6bcf\u4e2a\u6210\u5458\u3002 struct student{ int num; char name[20]; char sex; }; int main() { struct student s = {1001,\"lele\",'m'}; struct student *p; p = &s; printf(\"%d%s%c\\n\",(*p).num,(*p).name,(*p).sex); //\u5728c\u8bed\u8a00\u7684\u4f18\u5148\u7ea7\u89c4\u5219\u4e2d\uff0c.\uff08\u6210\u5458\u8fd0\u7b97\u7b26\u7684\u4f18\u5148\u7ea7\u9ad8\u4e8e\u53d6\u503c\u8fd0\u7b97\u7b26\uff09\uff0c //\u9700\u8981\u52a0\u62ec\u53f7\u6539\u53d8\u4f18\u5148\u7ea7 //\u7ed3\u6784\u4f53\u6307\u9488\u8bbf\u95ee\u6bcf\u4e00\u4e2a\u6210\u5458 printf(\"%d%s%c\\n\",p->num,p->name,p->sex); return 0; } \u7ed3\u6784\u4f53\u6307\u9488\u7684\u6210\u5458\u9009\u62e9 printf(\"%d%s%c\\n\",p->num,p->name,p->sex); 4. typedef typedef\u7684\u4f5c\u7528\u662f\u8d77\u522b\u540d #include <stdio.h> typedef struct student{ int num; char name[20]; char sex; }stu,*pstu; //\u7ed3\u6784\u4f53\u548c\u7ed3\u6784\u4f53\u6307\u9488 typedef int INTERGER; int main() { stu s = {1001,\"lele\",'m'}; pstu p; } #include <stdio.h> typedef struct student{ int num; char name[20]; char sex; }stu,*pstu; int main() { stu s = {1,\"wupeiqi\",'1'}; stu *p = &s; pstu pointer = &s; printf(\"stu->num=%d\\n\",p->num); printf(\"pointer->num=%d\\n\",pointer->num); return 0; } stu->num=1 pointer->num=1 Process finished with exit code 0 5. C++ \u5f15\u7528 #include <stdio.h> //\u628a&\u5199\u5230\u5f62\u53c2\u7684\u4f4d\u7f6e\u662fC++\u7684\u8bed\u6cd5\uff0c\u79f0\u4e3a\u5f15\u7528 void modifynum(int &b) //\u4f20\u5165\u7684\u662f\u5f15\u7528 { b = b + 1; } int main() { int a = 10; modifynum(a); return 0; }","title":"5.\u7ed3\u6784\u4f53"},{"location":"C%282022%29/struct/struct/#_1","text":"C \u8bed\u8a00\u63d0\u4f9b\u7ed3\u6784\u4f53\u6765\u7ba1\u7406\u4e0d\u540c\u7c7b\u578b\u7684\u6570\u636e\u7ec4\u5408","title":"\u7ed3\u6784\u4f53"},{"location":"C%282022%29/struct/struct/#1","text":"struct student{ int num; char name[20]; char sex; int age; }; //\u7ed3\u6784\u4f53\u7c7b\u578b\u58f0\u660e\uff0c\u6ce8\u610f\u6700\u540e\u4e00\u5b9a\u8981\u52a0\u5206\u53f7 int main() { struct student s = {1001,\"lele\",'m',20}; printf(\"%d%s%c%d\\n\",s.num,s.name,s.sex,s.age); //\u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u5efa\u7acb //\u6570\u7ec4\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5b58\u653e\u4e00\u4e2a\u7ed3\u6784\u4f53 struct student sarr[3]; int i; for (i=0;i<3;i++) { scanf(\"%d%s %c%d\",&sarr[i].num,&sarr[i].num,&sarr[i].name,&sarr[i].sex,&sarr[i].age) } return 0; }","title":"1.\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49\uff0c\u5f15\u7528\uff0c\u521d\u59cb\u5316"},{"location":"C%282022%29/struct/struct/#2","text":"\u7ed3\u6784\u4f53\u7684\u5927\u5c0f\u5fc5\u987b\u662f\u5176\u6700\u5927\u6210\u5458\u7684\u6574\u6570\u500d #include <stdio.h> struct student_type1{ double score; // double 8\u5b57\u8282 short age; } struct student_type2{ double score; int height; short age; }; struct student_type3{ int height; char sex; short age; }; int main(){ struct student_type1 s1; struct student_type2 s2; struct student_type3 s3; printf(\"s1 size=%d\\n\",sizeof(s1)); printf(\"s2 size=%d\\n\",sizeof(s2)); printf(\"s3 size=%d\\n\",sizeof(s3)); return 0; } s1 size=16 s2 size=16 s3 size=8 Process finished with exit code 0","title":"2. \u7ed3\u6784\u4f53\u5bf9\u9f50"},{"location":"C%282022%29/struct/struct/#3","text":"\u4e00\u4e2a\u7ed3\u6784\u4f53\u53d8\u91cf\u7684\u6307\u9488\u5c31\u662f\u8be5\u53d8\u91cf\u6240\u5360\u636e\u7684\u5185\u5b58\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u3002 \u53ef\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\uff0c \u7528\u5b83\u6307\u5411\u4e00\u4e2a\u7ed3\u6784\u4f53\u53d8\u91cf\uff0c \u6b64\u65f6\u8be5\u6307\u9488\u53d8\u91cf\u7684\u503c\u662f\u7ed3\u6784\u4f53\u53d8\u91cf\u7684\u8d77\u59cb\u5730\u5740 \u3002 \u6307\u9488\u53d8\u91cf\u4e5f\u53ef\u4ee5\u7528\u6765 \u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\uff0c\u4ece\u800c\u80fd\u591f\u901a\u8fc7\u7ed3\u6784\u4f53\u6307\u9488\u5feb\u901f\u8bbf\u95ee\u7ed3\u6784\u4f53\u5185\u7684\u6bcf\u4e2a\u6210\u5458\u3002 struct student{ int num; char name[20]; char sex; }; int main() { struct student s = {1001,\"lele\",'m'}; struct student *p; p = &s; printf(\"%d%s%c\\n\",(*p).num,(*p).name,(*p).sex); //\u5728c\u8bed\u8a00\u7684\u4f18\u5148\u7ea7\u89c4\u5219\u4e2d\uff0c.\uff08\u6210\u5458\u8fd0\u7b97\u7b26\u7684\u4f18\u5148\u7ea7\u9ad8\u4e8e\u53d6\u503c\u8fd0\u7b97\u7b26\uff09\uff0c //\u9700\u8981\u52a0\u62ec\u53f7\u6539\u53d8\u4f18\u5148\u7ea7 //\u7ed3\u6784\u4f53\u6307\u9488\u8bbf\u95ee\u6bcf\u4e00\u4e2a\u6210\u5458 printf(\"%d%s%c\\n\",p->num,p->name,p->sex); return 0; } \u7ed3\u6784\u4f53\u6307\u9488\u7684\u6210\u5458\u9009\u62e9 printf(\"%d%s%c\\n\",p->num,p->name,p->sex);","title":"3. \u7ed3\u6784\u4f53\u6307\u9488"},{"location":"C%282022%29/struct/struct/#4-typedef","text":"typedef\u7684\u4f5c\u7528\u662f\u8d77\u522b\u540d #include <stdio.h> typedef struct student{ int num; char name[20]; char sex; }stu,*pstu; //\u7ed3\u6784\u4f53\u548c\u7ed3\u6784\u4f53\u6307\u9488 typedef int INTERGER; int main() { stu s = {1001,\"lele\",'m'}; pstu p; } #include <stdio.h> typedef struct student{ int num; char name[20]; char sex; }stu,*pstu; int main() { stu s = {1,\"wupeiqi\",'1'}; stu *p = &s; pstu pointer = &s; printf(\"stu->num=%d\\n\",p->num); printf(\"pointer->num=%d\\n\",pointer->num); return 0; } stu->num=1 pointer->num=1 Process finished with exit code 0","title":"4. typedef"},{"location":"C%282022%29/struct/struct/#5-c","text":"#include <stdio.h> //\u628a&\u5199\u5230\u5f62\u53c2\u7684\u4f4d\u7f6e\u662fC++\u7684\u8bed\u6cd5\uff0c\u79f0\u4e3a\u5f15\u7528 void modifynum(int &b) //\u4f20\u5165\u7684\u662f\u5f15\u7528 { b = b + 1; } int main() { int a = 10; modifynum(a); return 0; }","title":"5. C++ \u5f15\u7528"},{"location":"DataStruct/LinearList/LinearList/","text":"LinearList\u7ebf\u6027\u8868 \u7ebf\u6027\u8868\u7684\u987a\u5e8f\u8868\u793a \u7ebf\u6027\u8868\u7684\u94fe\u5f0f\u8868\u793a 1.\u7ebf\u6027\u8868 \u7531n (n>=0)\u4e2a\u76f8\u540c\u7c7b\u578b\u5143\u7d20\u7ec4\u6210\u7684\u6709\u5e8f\u96c6\u5408 L = (a1,a2,...,ai) \u7ebf\u6027\u8868\u4e2d\u5143\u7d20\u7684\u4e2a\u6570\u79f0\u4e3a\u7ebf\u6027\u8868\u7684\u957f\u5ea6 - a1\u662f\u552f\u4e00\u7684\u201c\u7b2c\u4e00\u4e2a\u201d\u6570\u636e\u5143\u7d20\u201c\uff0can\u662f\u552f\u4e00\u7684\u201d\u6700\u540e\u4e00\u4e2a\u201c\u6570\u636e\u5143\u7d20 - ai-1\u4e3aai\u7684\u76f4\u63a5\u524d\u9a71\uff0cai+1\u4e3aai\u7684\u76f4\u63a5\u540e\u7ee7 \u5143\u7d20\u4e2a\u6570\u6709\u9650 \u6570\u636e\u7c7b\u578b\u76f8\u540c \u903b\u8f91\u4e0a\u5177\u6709\u987a\u5e8f\u6027 2.\u7ebf\u6027\u8868\u7684\u987a\u5e8f\u8868\u793a \u7ebf\u6027\u8868\u987a\u5e8f\u8868\u793a\u7684\u4f18\u7f3a\u70b9 - \u4f18\u70b9 - \u968f\u673a\u5b58\u53d6 - \u5b58\u50a8\u5bc6\u5ea6\u9ad8 - \u7f3a\u70b9 - \u63d2\u5165&\u5220\u9664\u65f6\u9700\u8981\u79fb\u52a8\u5927\u91cf\u5143\u7d20 - \u7ebf\u6027\u8868\u53d1\u751f\u8f83\u5927\u53d8\u5316\u65f6\uff0c\u96be\u4ee5\u786e\u5b9a\u5b58\u50a8\u7a7a\u95f4\u7684\u5bb9\u91cf - \u5b58\u50a8\u5206\u914d\u9700\u8981\u8fde\u7eed\u5185\u5b58\u7a7a\u95f4\uff0c\u4e0d\u591f\u7075\u6d3b \u7ebf\u6027\u8868\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \u6700\u597d\u60c5\u51b5\uff0c\u8868\u5c3e\u63d2\u5165O\uff081\uff09 \u6700\u574f\u60c5\u51b5\uff0c\u8868\u5934\u63d2\u5165 O\uff08n\uff09 \u5e73\u5747\u60c5\u51b5\uff0c\u79fb\u52a8\u6b21\u6570O\uff08n/2\uff09 \u7ebf\u6027\u8868\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO\uff08n\uff09 3.\u987a\u5e8f\u8868\u4ee3\u7801 \u7ed3\u6784\uff1a typedef int ElemType; typedef struct SqList { ElemType data[MaxSize]; int length; } SqList; void PrintSqList(SqList L){...} bool InsertSqList(SqList &L, int pos, ElemType val){...} bool DelSqList(SqList &L, int pos, ElemType &val){...} bool GetSqList(SqList L, ElemType num, ElemType &val){...} int main() { SqList L; L.data[0] = 1; L.data[1] = 2; L.data[2] = 3; L.length = 3; PrintSqList(L); //\u589e\u52a0 InsertSqList(L, 2, 99); PrintSqList(L); //\u5220\u9664 ElemType DelValue; DelValue = DelSqList(L, 2, DelValue); PrintSqList(L); //\u67e5\u8be2 ElemType GetRes; GetSqList(L,3,GetRes); printf(\"\u67e5\u8be2\u7684\u6570\u5b57\u662f%d\\n\",GetRes); return 0; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #define MaxSize 50 typedef int ElemType; typedef struct SqList { ElemType data[MaxSize]; int length; } SqList; void PrintSqList(SqList L) { for (int i = 0; i < L.length; i++) { printf(\"%3d\", L.data[i]); } printf(\"\\n\"); } bool InsertSqList(SqList &L, int pos, ElemType val) { if (pos < 1 || pos > L.length + 1) { return false; } if (L.length > MaxSize) { return false; } for (int j = L.length; j >= pos; j--) { L.data[j] = L.data[j - 1]; } L.data[pos - 1] = val; L.length++; return true; } bool DelSqList(SqList &L, int pos, ElemType &val) { if (pos < 1 || pos > L.length + 1) { return false; } val = L.data[pos - 1]; for (int i = pos - 1; i < L.length; i++) { L.data[i] = L.data[i + 1]; } L.length--; return true; } bool GetSqList(SqList L, ElemType num, ElemType &val) { for (int i = 0;i<L.length;i++) { if(L.data[i] == num) { val = L.data[i]; return true; } } val = 404; return false; } int main() { SqList L; L.data[0] = 1; L.data[1] = 2; L.data[2] = 3; L.length = 3; PrintSqList(L); // InsertSqList(L, 2, 99); PrintSqList(L); // ElemType DelValue; DelValue = DelSqList(L, 2, DelValue); PrintSqList(L); // ElemType GetRes; GetSqList(L,3,GetRes); printf(\"\u67e5\u8be2\u7684\u6570\u5b57\u662f%d\\n\",GetRes); return 0; } 4.\u7ebf\u6027\u8868\u7684\u94fe\u5f0f\u8868\u793a \u94fe\u5f0f\u5b58\u50a8\uff1a \u903b\u8f91\u4e0a\u76f8\u90bb\u7684\u4e24\u4e2a\u5143\u7d20\u5728\u7269\u7406\u4f4d\u7f6e\u4e0a\u4e0d\u76f8\u90bb \u4e0e\u987a\u5e8f\u8868\u76f8\u6bd4\uff1a \u63d2\u5165\u548c\u5220\u9664\u4e0d\u9700\u8981\u79fb\u52a8\u5143\u7d20\uff0c\u53ea\u9700\u8981\u4fee\u6539\u6307\u9488 \u4e0d\u9700\u8981\u8fde\u7eed\u7684\u5927\u91cf\u5185\u5b58\u7a7a\u95f4 \u5355\u4e2a\u7ed3\u6784\u4f53\u9700\u8981\u5b58\u50a8\u6307\u9488\u57df \u4e0d\u652f\u6301\u968f\u673a\u5b58\u53d6 \u4ee5\u4e0b\u4f8b\u5b50\u4e3a\u5e26\u6709\u5934\u8282\u70b9\u7684\u94fe\u8868 \u94fe\u8868\u8282\u70b9\u7ed3\u6784\u4f53\uff1a typedef int element_type; typedef struct Lnode{ element_type data; //\u672c\u8282\u70b9\u7684\u6570\u636e struct Lnode *next; //\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u6307\u9488 }LNode,*LinkList; //Lnode\u4e3a\u7ed3\u6784\u4f53\uff0cLinkList\u4e3a\u7ed3\u6784\u4f53\u6307\u9488 4.1 \u5934\u63d2\u6cd5\u5efa\u7acb\u5355\u94fe\u8868 #include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode, *LinkList; void PrintList(LinkList L) { L = L->next; while (L != NULL){ printf(\"%3d\",L->data); L = L->next; } } LinkList HeadInsert(LinkList &L) { LinkList newNode; //\u58f0\u660e\u65b0\u8282\u70b9\u6307\u9488 int x; L = (LinkList) malloc(sizeof(LinkNode));//\u521d\u59cb\u5316\u5934\u8282\u70b9 L->next = NULL; scanf(\"%d\", &x); while (x != 9999) { newNode = (LinkList) malloc(sizeof(LinkNode));//\u5206\u914d\u65b0\u8282\u70b9\u7a7a\u95f4 newNode->data = x;//\u65b0\u8282\u70b9\u8d4b\u503c newNode->next = L->next; L->next = newNode; scanf(\"%d\",&x); } } int main() { LinkList testHeadInsert; HeadInsert(testHeadInsert); PrintList(testHeadInsert); return 0; } 4.2 \u5c3e\u63d2\u6cd5\u5efa\u7acb\u5355\u94fe\u8868 \u5728\u5c3e\u63d2\u6cd5\u4e2d\uff0c\u9700\u8981\u591a\u7528\u4e00\u4e2a\u6307\u9488\uff08LinkList\u7c7b\u578b\uff09\u6765\u8868\u793a\u8868\u5c3e\u5143\u7d20\u7684\u4f4d\u7f6e\uff0c \u672c\u5b9e\u4f8b\u4e2d\uff0c\u4e0e\u65b0\u8282\u70b9\u7684\u6307\u9488\u4e00\u540c\u5b9a\u4e49 #include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode, *LinkList; void PrintList(LinkList L) { L = L->next; while (L != NULL){ printf(\"%3d\",L->data); L = L->next; } } LinkList TailInsert(LinkList &L) { LinkList newNode,pointer; //\u58f0\u660e\u65b0\u8282\u70b9\uff0c\u4ee5\u53ca\u6807\u8bc6\u8868\u5c3e\u7684\u6307\u9488 int x; L = (LinkList) malloc(sizeof (LinkNode)); //\u521d\u59cb\u5316\u5934\u8282\u70b9 pointer = L; //\u6307\u9488\u6b64\u65f6\u6307\u5411\u5934\u8282\u70b9 scanf(\"%d\",&x); while (x!=9999) { newNode = (LinkList) malloc(sizeof (LinkNode));//\u521d\u59cb\u5316\u65b0\u8282\u70b9 newNode->data = x;//\u65b0\u8282\u70b9\u8d4b\u503c newNode->next = pointer->next; pointer->next = newNode; pointer = newNode;//\u66f4\u65b0\u6307\u9488\u53c8\u91cd\u65b0\u6307\u5411\u65b0\u7684\u8868\u5c3e scanf(\"%d\",&x); } return L; } int main() { LinkList testTailInsert; TailInsert(testTailInsert); PrintList(testTailInsert); return 0; } 4.3 \u5355\u94fe\u8868\u67e5\u8be2\uff08\u6309\u4f4d\u7f6e\uff09 LinkList GetElem(LinkList L, int pos) { int j = 1; LinkList p = L->next; if (pos == 0) return L; if(pos<1){ return NULL; } while(p&&j<pos) { p = p->next; j++; } return p; } 4.4 \u5355\u94fe\u8868\u67e5\u8be2\uff08\u6309\u503c\uff09 LinkList LocateElem(LinkList L,ElemType val) { LinkList p = L->next; while (p!=NULL && p->data !=val) { p = p->next; } return p; } 4.5 \u63d2\u5165\u65b0\u8282\u70b9 bool InsertElem(LinkList L,int pos,ElemType val) { LinkList before = GetElem(L,pos-1); //\u83b7\u53d6\u65b0\u8282\u70b9\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u6307\u9488 if (before == NULL) { return false; } LinkList newNode; newNode = (LinkList)malloc(sizeof (LinkNode));//\u7ed9\u65b0\u8282\u70b9\u5206\u914d\u7a7a\u95f4 newNode->data = val; newNode->next = before->next; before->next = newNode; return true; } 4.6 \u5220\u9664\u8282\u70b9 bool DelElem(LinkList L,int pos) { LinkList before = GetElem(L,pos-1); printf(\"before=%3d\\n\",before->data); if(before == NULL) { return false; } LinkList current = before->next; //\u4e2d\u95f4\u6307\u9488\u53d8\u91cf\u7684\u521b\u5efa before->next = current->next; free(current); current = NULL; return true; } \u5728\u5220\u9664\u8282\u70b9\u7684\u8fc7\u7a0b\u4e2d\uff0c \u9700\u8981\u501f\u52a9\u4e00\u4e2a\u4e2d\u95f4\u6307\u9488\u53d8\u91cfcurrent\u6765\u8bb0\u5f55\u6b64\u65f6\u5220\u9664\u7684\u8282\u70b9 \uff0c \u56e0\u4e3a\u9700\u8981\u901a\u8fc7current\u8282\u70b9\u8bbf\u95eebefore\u8282\u70b9\u7684\u540e\u7ee7\u7684\u540e\u7ee7 5.\u53cc\u5411\u94fe\u8868 \u53cc\u5411\u94fe\u8868\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49 typedef int element_type typedef struct DNode{ ElemType data; //\u6570\u636e\u57df struct DNode *prior; //\u524d\u9a71\u6307\u9488 struct DNode *next; //\u540e\u7ee7\u6307\u9488 }DNode,*DinkList; \u53cc\u94fe\u8868\u7684\u7ed3\u6784\u5305\u62ec\uff0c\u542b\u6709\u7a7a\u6570\u636e\u7684\u5934\u6307\u9488\uff0c\u4ee5\u53ca\u4e4b\u540e\u7684 \u6bcf\u4e00\u4e2a\u5305\u542b\u6570\u636e\u7684\u7ed3\u6784\u4f53\u8282\u70b9\u3002 \u53cc\u94fe\u8868\u7684\u4e00\u4e2a\u7ed3\u6784\u4f53\u8282\u70b9\u536012\u4e2a\u5b57\u8282\u7684\u7a7a\u95f4 \u5934\u8282\u70b9\uff08\u65e0\u6570\u636e\u7684\u8282\u70b9\uff09\u53ea\u6709\u540e\u7ee7\u6307\u9488\uff0c\u4e0d\u6210\u4e3a\u524d\u9a71\u6307\u9488\u6307\u5411\u7684\u5bf9\u8c61 5.1\u53cc\u5411\u94fe\u8868\u5934\u63d2\u6cd5 DLinkList ListHeadInsert(DLinkList &DL) { DNode *s; int x; DL = (DLinkList)malloc(sizeof(DNode)); DL->next = NULL; DL->prior = NULL; scanf(\"%d\",&x); while(x!=9999) { s = (DLinkList)malloc(sizeof(DNode)); //\u5efa\u7acb\u65b0\u7684\u6570\u636e\u8282\u70b9\uff0c\u7ed3\u6784\u4f53\uff08\u6307\u9488\uff09 s->data=x; s->next = DL->next; if(DL->next != NULL) { DL->next->prior = s; } s->prior = DL; //unnecessary own opinion DL->next = s; scanf(\"%d\",&x); } return DL; } 5.2 \u53cc\u5411\u94fe\u8868\u5c3e\u63d2\u6cd5 DLinkList DlistTailInsert(DLinkList &DL) { int x; DL = (DLinkList)malloc(sizeof(DNode)); DNode *s; DNode *r = DL; DL-> = NULL; scanf(\"%d\",&x); while(x!=9999) { s = (DNode*)malloc(sizeof(DNode)); s->data = x; r->next = s; s->prior = r; r=s; scanf(\"%d\",&x); } r->next = NULL; return DL; } 5.3 \u53cc\u5411\u94fe\u8868\u904d\u5386 void PrintDList(DLinkList DL) { DL = DL ->next; while(DL != NULL) { printf(\"%3d\",DL->data); DL = DL->next; } printf(\"\\n\"); } 5.4 \u53cc\u5411\u94fe\u8868\u63d2\u5165\u5143\u7d20 bool DListFrontInsert(DLinkList DL,int i,element_type) { DLinkList p = *get_element(DL,i-1); if (p==NULL) { return false; } DLinkList s = (DLinkList)malloc(sizeof(DNode)); s->data = e; s->next = p->next; p->next->prior=s; p->next = s; s->prior = p; return true; } 5.5 \u53cc\u5411\u94fe\u8868\u5220\u9664\u5143\u7d20 bool DListDelete(DLinkList DL,int i) { DLinkList p = *get_element(DL,i-1); if(p==NULL) { return false; } DLinkList q; q = p->next; if (q==NULL) { return false; } p->next = q->next; if(q->next != NULL) { q->next->prior = p; } free(p); return true; } int main() { LinkList L; // List_HeadInsert(L); List_TailInsert(L); LNode L1; int res; L1 = *get_element(L,2); res = L1.data; printf(\"%d\\n\",res); } 6.LinkList-2019-41 \u9898\u76ee 41.(13\u5206) \u8bbe\u7ebf\u6027\u8868L=\uff08a1,a2,a3,...,an\uff09\u91c7\u7528\u5e26\u5934\u8282\u70b9\u7684\u94fe\u8868\u4fdd\u5b58\uff0c\u94fe\u8868\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b typedef struct node{ int data; struct node *next; }NODE; \u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1)\u5e76\u4e14\u65f6\u95f4\u4e0a\u5c3d\u53ef\u80fd\u9ad8\u6548\u7684\u7b97\u6cd5\uff0c\u91cd\u65b0\u6392\u5217L\u4e2d\u7684\u8282\u70b9\uff0c \u5f97\u5230\u7ebf\u6027\u8868L'=\uff08a1,an,a2,an-1,a3,an-1,...\uff09 \u7ed9\u51fa\u7b97\u6cd5\u8bbe\u8ba1\u57fa\u672c\u601d\u60f3 \u7528C/C++\u63cf\u8ff0\u7b97\u6cd5 \u8bf4\u660e\u65f6\u95f4\u590d\u6742\u5ea6 \u8bbe\u8ba1\u601d\u60f3 \u4ee3\u7801 #include <stdio.h> #include <stdlib.h> typedef int element_type; typedef struct Lnode { element_type data; struct Lnode *next; } LinkNode, *LinkList; void PrintList(LinkList L) { L = L->next; while (L != NULL) { printf(\"%3d\", L->data); L = L->next; } printf(\"\\n\"); } LinkList TailInsert(LinkList &L) { LinkList newNode, pointer; int x; L = (LinkList) malloc(sizeof(LinkNode)); pointer = L; scanf(\"%d\", &x); while (x != 9999) { newNode = (LinkList) malloc(sizeof(LinkNode)); newNode->data = x; newNode->next = pointer->next; pointer->next = newNode; pointer = newNode; scanf(\"%d\", &x); } return L; } //\u627e\u94fe\u8868\u4e2d\u95f4\u8282\u70b9 void FindMiddle(LinkList L, LinkList &L2) { L2 = (LinkList) malloc(sizeof(LinkNode)); // \u53cc\u6307\u9488\u6cd5\u627e\u4e2d\u95f4\u8282\u70b9 LinkList pcur, ppre; pcur = L->next; ppre = L->next; while (pcur) { pcur = pcur->next; //pcur\u4e00\u6b21\u5411\u524d\u4e24\u4e2a\u8282\u70b9\uff0c\u8981\u5224\u65ad\u4e0b\u4e00\u4e2a\u8282\u70b9\u662f\u5426\u5b58\u5728 if (pcur == NULL) { break; } pcur = pcur->next; // \u5076\u6570\u60c5\u51b5\u4e0b\uff0c\u4fdd\u8bc1ppre\u4e0d\u5411\u524d\u79fb\u52a8 if (pcur == NULL) { break; } ppre = ppre->next; } // L2\u5934\u8282\u70b9\u6307\u5411\u540e\u9762\u4e00\u534a\u94fe\u8868 L2->next = ppre->next; //\u524d\u4e00\u534a\u94fe\u8868\u65ad\u5f00 ppre->next = NULL; } void reverse(LinkList L2) { LinkList r, s, t; r = L2->next; // \u7b2c\u4e8c\u6bb5\u94fe\u8868\u4e3a\u7a7a if (r == NULL) { return; } s = r->next; //\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u8282\u70b9 if (s == NULL) { return; } t = s->next; while (t) { s->next = r; r = s; s = t; t = t->next; } s->next = r; L2->next->next = NULL; L2->next = s; } void merge(LinkList L, LinkList L2) { LinkList pcur, p, q; //pcur\u59cb\u7ec8\u6307\u5411\u65b0\u94fe\u8868\u7684\u94fe\u8868\u5c3e pcur = L->next; p = pcur->next; q = L2->next; while (p != NULL && q != NULL) { //\u5148\u653e\u540e\u534a\u6bb5\u94fe\u8868\u7684\u4e00\u4e2a\u5143\u7d20 pcur->next = q; pcur = pcur->next; q = q->next; //\u653e\u524d\u4e00\u6bb5\u94fe\u8868\u7684\u4e00\u4e2a\u5143\u7d20 pcur->next = p; pcur = pcur->next; p = p->next; } if (p != NULL) { pcur->next = p; } if (q != NULL) { pcur->next = q; } } int main() { LinkList L; LinkList search; TailInsert(L); PrintList(L); LinkList L2; FindMiddle(L, L2); printf(\"--------FindeMiddle--------\\n\"); PrintList(L); PrintList(L2); printf(\"--------reverse--------\\n\"); reverse(L2); PrintList(L); PrintList(L2); printf(\"--------merge--------\\n\"); merge(L,L2); PrintList(L); return 0; } \u6d4b\u8bd5\u7ed3\u679c /Users/uichuan/Documents/library/DataStructure/codes/LinkList_example01/cmake-build-debug/LinkList_example01 1 2 3 4 5 9999 1 2 3 4 5 --------FindeMiddle-------- 1 2 3 4 5 --------reverse-------- 1 2 3 5 4 --------merge-------- 1 5 2 4 3 Process finished with exit code 0 /Users/uichuan/Documents/library/DataStructure/codes/LinkList_example01/cmake-build-debug/LinkList_example01 1 2 3 4 5 6 9999 1 2 3 4 5 6 --------FindeMiddle-------- 1 2 3 4 5 6 --------reverse-------- 1 2 3 6 5 4 --------merge-------- 1 6 2 5 3 4 Process finished with exit code 0 \u65f6\u95f4\u590d\u6742\u5ea6 O(1)","title":"2.\u7ebf\u6027\u8868"},{"location":"DataStruct/LinearList/LinearList/#linearlist","text":"\u7ebf\u6027\u8868\u7684\u987a\u5e8f\u8868\u793a \u7ebf\u6027\u8868\u7684\u94fe\u5f0f\u8868\u793a","title":"LinearList\u7ebf\u6027\u8868"},{"location":"DataStruct/LinearList/LinearList/#1","text":"\u7531n (n>=0)\u4e2a\u76f8\u540c\u7c7b\u578b\u5143\u7d20\u7ec4\u6210\u7684\u6709\u5e8f\u96c6\u5408 L = (a1,a2,...,ai) \u7ebf\u6027\u8868\u4e2d\u5143\u7d20\u7684\u4e2a\u6570\u79f0\u4e3a\u7ebf\u6027\u8868\u7684\u957f\u5ea6 - a1\u662f\u552f\u4e00\u7684\u201c\u7b2c\u4e00\u4e2a\u201d\u6570\u636e\u5143\u7d20\u201c\uff0can\u662f\u552f\u4e00\u7684\u201d\u6700\u540e\u4e00\u4e2a\u201c\u6570\u636e\u5143\u7d20 - ai-1\u4e3aai\u7684\u76f4\u63a5\u524d\u9a71\uff0cai+1\u4e3aai\u7684\u76f4\u63a5\u540e\u7ee7 \u5143\u7d20\u4e2a\u6570\u6709\u9650 \u6570\u636e\u7c7b\u578b\u76f8\u540c \u903b\u8f91\u4e0a\u5177\u6709\u987a\u5e8f\u6027","title":"1.\u7ebf\u6027\u8868"},{"location":"DataStruct/LinearList/LinearList/#2","text":"\u7ebf\u6027\u8868\u987a\u5e8f\u8868\u793a\u7684\u4f18\u7f3a\u70b9 - \u4f18\u70b9 - \u968f\u673a\u5b58\u53d6 - \u5b58\u50a8\u5bc6\u5ea6\u9ad8 - \u7f3a\u70b9 - \u63d2\u5165&\u5220\u9664\u65f6\u9700\u8981\u79fb\u52a8\u5927\u91cf\u5143\u7d20 - \u7ebf\u6027\u8868\u53d1\u751f\u8f83\u5927\u53d8\u5316\u65f6\uff0c\u96be\u4ee5\u786e\u5b9a\u5b58\u50a8\u7a7a\u95f4\u7684\u5bb9\u91cf - \u5b58\u50a8\u5206\u914d\u9700\u8981\u8fde\u7eed\u5185\u5b58\u7a7a\u95f4\uff0c\u4e0d\u591f\u7075\u6d3b \u7ebf\u6027\u8868\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \u6700\u597d\u60c5\u51b5\uff0c\u8868\u5c3e\u63d2\u5165O\uff081\uff09 \u6700\u574f\u60c5\u51b5\uff0c\u8868\u5934\u63d2\u5165 O\uff08n\uff09 \u5e73\u5747\u60c5\u51b5\uff0c\u79fb\u52a8\u6b21\u6570O\uff08n/2\uff09 \u7ebf\u6027\u8868\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO\uff08n\uff09","title":"2.\u7ebf\u6027\u8868\u7684\u987a\u5e8f\u8868\u793a"},{"location":"DataStruct/LinearList/LinearList/#3","text":"\u7ed3\u6784\uff1a typedef int ElemType; typedef struct SqList { ElemType data[MaxSize]; int length; } SqList; void PrintSqList(SqList L){...} bool InsertSqList(SqList &L, int pos, ElemType val){...} bool DelSqList(SqList &L, int pos, ElemType &val){...} bool GetSqList(SqList L, ElemType num, ElemType &val){...} int main() { SqList L; L.data[0] = 1; L.data[1] = 2; L.data[2] = 3; L.length = 3; PrintSqList(L); //\u589e\u52a0 InsertSqList(L, 2, 99); PrintSqList(L); //\u5220\u9664 ElemType DelValue; DelValue = DelSqList(L, 2, DelValue); PrintSqList(L); //\u67e5\u8be2 ElemType GetRes; GetSqList(L,3,GetRes); printf(\"\u67e5\u8be2\u7684\u6570\u5b57\u662f%d\\n\",GetRes); return 0; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #define MaxSize 50 typedef int ElemType; typedef struct SqList { ElemType data[MaxSize]; int length; } SqList; void PrintSqList(SqList L) { for (int i = 0; i < L.length; i++) { printf(\"%3d\", L.data[i]); } printf(\"\\n\"); } bool InsertSqList(SqList &L, int pos, ElemType val) { if (pos < 1 || pos > L.length + 1) { return false; } if (L.length > MaxSize) { return false; } for (int j = L.length; j >= pos; j--) { L.data[j] = L.data[j - 1]; } L.data[pos - 1] = val; L.length++; return true; } bool DelSqList(SqList &L, int pos, ElemType &val) { if (pos < 1 || pos > L.length + 1) { return false; } val = L.data[pos - 1]; for (int i = pos - 1; i < L.length; i++) { L.data[i] = L.data[i + 1]; } L.length--; return true; } bool GetSqList(SqList L, ElemType num, ElemType &val) { for (int i = 0;i<L.length;i++) { if(L.data[i] == num) { val = L.data[i]; return true; } } val = 404; return false; } int main() { SqList L; L.data[0] = 1; L.data[1] = 2; L.data[2] = 3; L.length = 3; PrintSqList(L); // InsertSqList(L, 2, 99); PrintSqList(L); // ElemType DelValue; DelValue = DelSqList(L, 2, DelValue); PrintSqList(L); // ElemType GetRes; GetSqList(L,3,GetRes); printf(\"\u67e5\u8be2\u7684\u6570\u5b57\u662f%d\\n\",GetRes); return 0; }","title":"3.\u987a\u5e8f\u8868\u4ee3\u7801"},{"location":"DataStruct/LinearList/LinearList/#4","text":"\u94fe\u5f0f\u5b58\u50a8\uff1a \u903b\u8f91\u4e0a\u76f8\u90bb\u7684\u4e24\u4e2a\u5143\u7d20\u5728\u7269\u7406\u4f4d\u7f6e\u4e0a\u4e0d\u76f8\u90bb \u4e0e\u987a\u5e8f\u8868\u76f8\u6bd4\uff1a \u63d2\u5165\u548c\u5220\u9664\u4e0d\u9700\u8981\u79fb\u52a8\u5143\u7d20\uff0c\u53ea\u9700\u8981\u4fee\u6539\u6307\u9488 \u4e0d\u9700\u8981\u8fde\u7eed\u7684\u5927\u91cf\u5185\u5b58\u7a7a\u95f4 \u5355\u4e2a\u7ed3\u6784\u4f53\u9700\u8981\u5b58\u50a8\u6307\u9488\u57df \u4e0d\u652f\u6301\u968f\u673a\u5b58\u53d6 \u4ee5\u4e0b\u4f8b\u5b50\u4e3a\u5e26\u6709\u5934\u8282\u70b9\u7684\u94fe\u8868 \u94fe\u8868\u8282\u70b9\u7ed3\u6784\u4f53\uff1a typedef int element_type; typedef struct Lnode{ element_type data; //\u672c\u8282\u70b9\u7684\u6570\u636e struct Lnode *next; //\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u6307\u9488 }LNode,*LinkList; //Lnode\u4e3a\u7ed3\u6784\u4f53\uff0cLinkList\u4e3a\u7ed3\u6784\u4f53\u6307\u9488","title":"4.\u7ebf\u6027\u8868\u7684\u94fe\u5f0f\u8868\u793a"},{"location":"DataStruct/LinearList/LinearList/#41","text":"#include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode, *LinkList; void PrintList(LinkList L) { L = L->next; while (L != NULL){ printf(\"%3d\",L->data); L = L->next; } } LinkList HeadInsert(LinkList &L) { LinkList newNode; //\u58f0\u660e\u65b0\u8282\u70b9\u6307\u9488 int x; L = (LinkList) malloc(sizeof(LinkNode));//\u521d\u59cb\u5316\u5934\u8282\u70b9 L->next = NULL; scanf(\"%d\", &x); while (x != 9999) { newNode = (LinkList) malloc(sizeof(LinkNode));//\u5206\u914d\u65b0\u8282\u70b9\u7a7a\u95f4 newNode->data = x;//\u65b0\u8282\u70b9\u8d4b\u503c newNode->next = L->next; L->next = newNode; scanf(\"%d\",&x); } } int main() { LinkList testHeadInsert; HeadInsert(testHeadInsert); PrintList(testHeadInsert); return 0; }","title":"4.1 \u5934\u63d2\u6cd5\u5efa\u7acb\u5355\u94fe\u8868"},{"location":"DataStruct/LinearList/LinearList/#42","text":"\u5728\u5c3e\u63d2\u6cd5\u4e2d\uff0c\u9700\u8981\u591a\u7528\u4e00\u4e2a\u6307\u9488\uff08LinkList\u7c7b\u578b\uff09\u6765\u8868\u793a\u8868\u5c3e\u5143\u7d20\u7684\u4f4d\u7f6e\uff0c \u672c\u5b9e\u4f8b\u4e2d\uff0c\u4e0e\u65b0\u8282\u70b9\u7684\u6307\u9488\u4e00\u540c\u5b9a\u4e49 #include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode, *LinkList; void PrintList(LinkList L) { L = L->next; while (L != NULL){ printf(\"%3d\",L->data); L = L->next; } } LinkList TailInsert(LinkList &L) { LinkList newNode,pointer; //\u58f0\u660e\u65b0\u8282\u70b9\uff0c\u4ee5\u53ca\u6807\u8bc6\u8868\u5c3e\u7684\u6307\u9488 int x; L = (LinkList) malloc(sizeof (LinkNode)); //\u521d\u59cb\u5316\u5934\u8282\u70b9 pointer = L; //\u6307\u9488\u6b64\u65f6\u6307\u5411\u5934\u8282\u70b9 scanf(\"%d\",&x); while (x!=9999) { newNode = (LinkList) malloc(sizeof (LinkNode));//\u521d\u59cb\u5316\u65b0\u8282\u70b9 newNode->data = x;//\u65b0\u8282\u70b9\u8d4b\u503c newNode->next = pointer->next; pointer->next = newNode; pointer = newNode;//\u66f4\u65b0\u6307\u9488\u53c8\u91cd\u65b0\u6307\u5411\u65b0\u7684\u8868\u5c3e scanf(\"%d\",&x); } return L; } int main() { LinkList testTailInsert; TailInsert(testTailInsert); PrintList(testTailInsert); return 0; }","title":"4.2 \u5c3e\u63d2\u6cd5\u5efa\u7acb\u5355\u94fe\u8868"},{"location":"DataStruct/LinearList/LinearList/#43","text":"LinkList GetElem(LinkList L, int pos) { int j = 1; LinkList p = L->next; if (pos == 0) return L; if(pos<1){ return NULL; } while(p&&j<pos) { p = p->next; j++; } return p; }","title":"4.3 \u5355\u94fe\u8868\u67e5\u8be2\uff08\u6309\u4f4d\u7f6e\uff09"},{"location":"DataStruct/LinearList/LinearList/#44","text":"LinkList LocateElem(LinkList L,ElemType val) { LinkList p = L->next; while (p!=NULL && p->data !=val) { p = p->next; } return p; }","title":"4.4 \u5355\u94fe\u8868\u67e5\u8be2\uff08\u6309\u503c\uff09"},{"location":"DataStruct/LinearList/LinearList/#45","text":"bool InsertElem(LinkList L,int pos,ElemType val) { LinkList before = GetElem(L,pos-1); //\u83b7\u53d6\u65b0\u8282\u70b9\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u6307\u9488 if (before == NULL) { return false; } LinkList newNode; newNode = (LinkList)malloc(sizeof (LinkNode));//\u7ed9\u65b0\u8282\u70b9\u5206\u914d\u7a7a\u95f4 newNode->data = val; newNode->next = before->next; before->next = newNode; return true; }","title":"4.5 \u63d2\u5165\u65b0\u8282\u70b9"},{"location":"DataStruct/LinearList/LinearList/#46","text":"bool DelElem(LinkList L,int pos) { LinkList before = GetElem(L,pos-1); printf(\"before=%3d\\n\",before->data); if(before == NULL) { return false; } LinkList current = before->next; //\u4e2d\u95f4\u6307\u9488\u53d8\u91cf\u7684\u521b\u5efa before->next = current->next; free(current); current = NULL; return true; } \u5728\u5220\u9664\u8282\u70b9\u7684\u8fc7\u7a0b\u4e2d\uff0c \u9700\u8981\u501f\u52a9\u4e00\u4e2a\u4e2d\u95f4\u6307\u9488\u53d8\u91cfcurrent\u6765\u8bb0\u5f55\u6b64\u65f6\u5220\u9664\u7684\u8282\u70b9 \uff0c \u56e0\u4e3a\u9700\u8981\u901a\u8fc7current\u8282\u70b9\u8bbf\u95eebefore\u8282\u70b9\u7684\u540e\u7ee7\u7684\u540e\u7ee7","title":"4.6 \u5220\u9664\u8282\u70b9"},{"location":"DataStruct/LinearList/LinearList/#5","text":"\u53cc\u5411\u94fe\u8868\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49 typedef int element_type typedef struct DNode{ ElemType data; //\u6570\u636e\u57df struct DNode *prior; //\u524d\u9a71\u6307\u9488 struct DNode *next; //\u540e\u7ee7\u6307\u9488 }DNode,*DinkList; \u53cc\u94fe\u8868\u7684\u7ed3\u6784\u5305\u62ec\uff0c\u542b\u6709\u7a7a\u6570\u636e\u7684\u5934\u6307\u9488\uff0c\u4ee5\u53ca\u4e4b\u540e\u7684 \u6bcf\u4e00\u4e2a\u5305\u542b\u6570\u636e\u7684\u7ed3\u6784\u4f53\u8282\u70b9\u3002 \u53cc\u94fe\u8868\u7684\u4e00\u4e2a\u7ed3\u6784\u4f53\u8282\u70b9\u536012\u4e2a\u5b57\u8282\u7684\u7a7a\u95f4 \u5934\u8282\u70b9\uff08\u65e0\u6570\u636e\u7684\u8282\u70b9\uff09\u53ea\u6709\u540e\u7ee7\u6307\u9488\uff0c\u4e0d\u6210\u4e3a\u524d\u9a71\u6307\u9488\u6307\u5411\u7684\u5bf9\u8c61","title":"5.\u53cc\u5411\u94fe\u8868"},{"location":"DataStruct/LinearList/LinearList/#_1","text":"","title":""},{"location":"DataStruct/LinearList/LinearList/#51","text":"DLinkList ListHeadInsert(DLinkList &DL) { DNode *s; int x; DL = (DLinkList)malloc(sizeof(DNode)); DL->next = NULL; DL->prior = NULL; scanf(\"%d\",&x); while(x!=9999) { s = (DLinkList)malloc(sizeof(DNode)); //\u5efa\u7acb\u65b0\u7684\u6570\u636e\u8282\u70b9\uff0c\u7ed3\u6784\u4f53\uff08\u6307\u9488\uff09 s->data=x; s->next = DL->next; if(DL->next != NULL) { DL->next->prior = s; } s->prior = DL; //unnecessary own opinion DL->next = s; scanf(\"%d\",&x); } return DL; }","title":"5.1\u53cc\u5411\u94fe\u8868\u5934\u63d2\u6cd5"},{"location":"DataStruct/LinearList/LinearList/#52","text":"DLinkList DlistTailInsert(DLinkList &DL) { int x; DL = (DLinkList)malloc(sizeof(DNode)); DNode *s; DNode *r = DL; DL-> = NULL; scanf(\"%d\",&x); while(x!=9999) { s = (DNode*)malloc(sizeof(DNode)); s->data = x; r->next = s; s->prior = r; r=s; scanf(\"%d\",&x); } r->next = NULL; return DL; }","title":"5.2 \u53cc\u5411\u94fe\u8868\u5c3e\u63d2\u6cd5"},{"location":"DataStruct/LinearList/LinearList/#53","text":"void PrintDList(DLinkList DL) { DL = DL ->next; while(DL != NULL) { printf(\"%3d\",DL->data); DL = DL->next; } printf(\"\\n\"); }","title":"5.3 \u53cc\u5411\u94fe\u8868\u904d\u5386"},{"location":"DataStruct/LinearList/LinearList/#54","text":"bool DListFrontInsert(DLinkList DL,int i,element_type) { DLinkList p = *get_element(DL,i-1); if (p==NULL) { return false; } DLinkList s = (DLinkList)malloc(sizeof(DNode)); s->data = e; s->next = p->next; p->next->prior=s; p->next = s; s->prior = p; return true; }","title":"5.4 \u53cc\u5411\u94fe\u8868\u63d2\u5165\u5143\u7d20"},{"location":"DataStruct/LinearList/LinearList/#55","text":"bool DListDelete(DLinkList DL,int i) { DLinkList p = *get_element(DL,i-1); if(p==NULL) { return false; } DLinkList q; q = p->next; if (q==NULL) { return false; } p->next = q->next; if(q->next != NULL) { q->next->prior = p; } free(p); return true; } int main() { LinkList L; // List_HeadInsert(L); List_TailInsert(L); LNode L1; int res; L1 = *get_element(L,2); res = L1.data; printf(\"%d\\n\",res); }","title":"5.5 \u53cc\u5411\u94fe\u8868\u5220\u9664\u5143\u7d20"},{"location":"DataStruct/LinearList/LinearList/#6linklist-2019-41","text":"","title":"6.LinkList-2019-41"},{"location":"DataStruct/LinearList/LinearList/#_2","text":"41.(13\u5206) \u8bbe\u7ebf\u6027\u8868L=\uff08a1,a2,a3,...,an\uff09\u91c7\u7528\u5e26\u5934\u8282\u70b9\u7684\u94fe\u8868\u4fdd\u5b58\uff0c\u94fe\u8868\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b typedef struct node{ int data; struct node *next; }NODE; \u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1)\u5e76\u4e14\u65f6\u95f4\u4e0a\u5c3d\u53ef\u80fd\u9ad8\u6548\u7684\u7b97\u6cd5\uff0c\u91cd\u65b0\u6392\u5217L\u4e2d\u7684\u8282\u70b9\uff0c \u5f97\u5230\u7ebf\u6027\u8868L'=\uff08a1,an,a2,an-1,a3,an-1,...\uff09 \u7ed9\u51fa\u7b97\u6cd5\u8bbe\u8ba1\u57fa\u672c\u601d\u60f3 \u7528C/C++\u63cf\u8ff0\u7b97\u6cd5 \u8bf4\u660e\u65f6\u95f4\u590d\u6742\u5ea6","title":"\u9898\u76ee"},{"location":"DataStruct/LinearList/LinearList/#_3","text":"","title":"\u8bbe\u8ba1\u601d\u60f3"},{"location":"DataStruct/LinearList/LinearList/#_4","text":"#include <stdio.h> #include <stdlib.h> typedef int element_type; typedef struct Lnode { element_type data; struct Lnode *next; } LinkNode, *LinkList; void PrintList(LinkList L) { L = L->next; while (L != NULL) { printf(\"%3d\", L->data); L = L->next; } printf(\"\\n\"); } LinkList TailInsert(LinkList &L) { LinkList newNode, pointer; int x; L = (LinkList) malloc(sizeof(LinkNode)); pointer = L; scanf(\"%d\", &x); while (x != 9999) { newNode = (LinkList) malloc(sizeof(LinkNode)); newNode->data = x; newNode->next = pointer->next; pointer->next = newNode; pointer = newNode; scanf(\"%d\", &x); } return L; } //\u627e\u94fe\u8868\u4e2d\u95f4\u8282\u70b9 void FindMiddle(LinkList L, LinkList &L2) { L2 = (LinkList) malloc(sizeof(LinkNode)); // \u53cc\u6307\u9488\u6cd5\u627e\u4e2d\u95f4\u8282\u70b9 LinkList pcur, ppre; pcur = L->next; ppre = L->next; while (pcur) { pcur = pcur->next; //pcur\u4e00\u6b21\u5411\u524d\u4e24\u4e2a\u8282\u70b9\uff0c\u8981\u5224\u65ad\u4e0b\u4e00\u4e2a\u8282\u70b9\u662f\u5426\u5b58\u5728 if (pcur == NULL) { break; } pcur = pcur->next; // \u5076\u6570\u60c5\u51b5\u4e0b\uff0c\u4fdd\u8bc1ppre\u4e0d\u5411\u524d\u79fb\u52a8 if (pcur == NULL) { break; } ppre = ppre->next; } // L2\u5934\u8282\u70b9\u6307\u5411\u540e\u9762\u4e00\u534a\u94fe\u8868 L2->next = ppre->next; //\u524d\u4e00\u534a\u94fe\u8868\u65ad\u5f00 ppre->next = NULL; } void reverse(LinkList L2) { LinkList r, s, t; r = L2->next; // \u7b2c\u4e8c\u6bb5\u94fe\u8868\u4e3a\u7a7a if (r == NULL) { return; } s = r->next; //\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u8282\u70b9 if (s == NULL) { return; } t = s->next; while (t) { s->next = r; r = s; s = t; t = t->next; } s->next = r; L2->next->next = NULL; L2->next = s; } void merge(LinkList L, LinkList L2) { LinkList pcur, p, q; //pcur\u59cb\u7ec8\u6307\u5411\u65b0\u94fe\u8868\u7684\u94fe\u8868\u5c3e pcur = L->next; p = pcur->next; q = L2->next; while (p != NULL && q != NULL) { //\u5148\u653e\u540e\u534a\u6bb5\u94fe\u8868\u7684\u4e00\u4e2a\u5143\u7d20 pcur->next = q; pcur = pcur->next; q = q->next; //\u653e\u524d\u4e00\u6bb5\u94fe\u8868\u7684\u4e00\u4e2a\u5143\u7d20 pcur->next = p; pcur = pcur->next; p = p->next; } if (p != NULL) { pcur->next = p; } if (q != NULL) { pcur->next = q; } } int main() { LinkList L; LinkList search; TailInsert(L); PrintList(L); LinkList L2; FindMiddle(L, L2); printf(\"--------FindeMiddle--------\\n\"); PrintList(L); PrintList(L2); printf(\"--------reverse--------\\n\"); reverse(L2); PrintList(L); PrintList(L2); printf(\"--------merge--------\\n\"); merge(L,L2); PrintList(L); return 0; } \u6d4b\u8bd5\u7ed3\u679c /Users/uichuan/Documents/library/DataStructure/codes/LinkList_example01/cmake-build-debug/LinkList_example01 1 2 3 4 5 9999 1 2 3 4 5 --------FindeMiddle-------- 1 2 3 4 5 --------reverse-------- 1 2 3 5 4 --------merge-------- 1 5 2 4 3 Process finished with exit code 0 /Users/uichuan/Documents/library/DataStructure/codes/LinkList_example01/cmake-build-debug/LinkList_example01 1 2 3 4 5 6 9999 1 2 3 4 5 6 --------FindeMiddle-------- 1 2 3 4 5 6 --------reverse-------- 1 2 3 6 5 4 --------merge-------- 1 6 2 5 3 4 Process finished with exit code 0","title":"\u4ee3\u7801"},{"location":"DataStruct/LinearList/LinearList/#_5","text":"O(1)","title":"\u65f6\u95f4\u590d\u6742\u5ea6"},{"location":"DataStruct/complexity/complexity/","text":"\u6570\u636e\u7ed3\u6784\u524d\u620f \u65f6\u95f4\u590d\u6742\u5ea6 \u4e00\u822c\u4e0d\u91c7\u7528\u8bb0\u5f55\u7b97\u6cd5\u8fd0\u884c\u65f6\u95f4\u7684\u65b9\u5f0f\u6765\u8bc4\u4f30\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\uff0c\u56e0\u4e3a\u540c\u4e00\u4e2a\u7b97\u6cd5\u5728\u4e0d\u540c\u786c\u4ef6\u4e0a\u7684\u8fd0\u884c\u901f\u5ea6\u5dee\u522b\u5f88\u5927 \u901a\u5e38\u7528\u8fd0\u884c\u6b21\u6570\u53bb\u8868\u793a\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u56e0\u4e3a\u65f6\u95f4\u548c\u8fd0\u884c\u6b21\u6570\u662f\u6b63\u76f8\u5173\u7684 \u65f6\u95f4\u590d\u6742\u5ea6\u6307\u7b97\u6cd5\u4e2d\u6240\u6709\u8bed\u53e5\u7684\u9891\u5ea6\uff08\u6267\u884c\u6b21\u6570\uff09\u4e4b\u548c T(n) = O(f(n)) \u5176\u4e2d\uff0cn\u662f\u95ee\u9898\u7684\u89c4\u6a21\uff0cf(n)\u662f\u95ee\u9898\u89c4\u6a21n\u7684\u67d0\u4e2a\u51fd\u6570 \u5e38\u89c1\u7684\u65f6\u95f4\u590d\u6742\u5ea6 O(1)<O(log2(n))<o(n)<o(nlog2(n))<o(n^2)<o(n^3)<o(2^n)<o(n!) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u8ba1\u7b97\u8981\u5ffd\u7565\u9ad8\u9636\u9879\u7cfb\u6570\u548c\u4f4e\u9636\u9879 \u7a7a\u95f4\u590d\u6742\u5ea6 \u7a7a\u95f4\u590d\u6742\u5ea6S(n)\u662f\u6307\u7b97\u6cd5\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6240\u4f7f\u7528\u7684\u8f85\u52a9\u7a7a\u95f4\u7684\u5927\u5c0f \u8bb0\u4e3a\uff1a s(n) = O(f(n)) \u9664\u4e86\u9700\u8981\u5b58\u50a8\u7b97\u6cd5\u672c\u8eab\u7684\u6307\u4ee4\uff0c\u5e38\u6570\uff0c\u53d8\u91cf\u548c\u8f93\u5165\u6570\u636e\u5916\uff0c\u8fd8\u9700\u8981\u5b58\u50a8\u5bf9\u6570\u636e\u64cd\u4f5c\u7684\u5b58\u50a8\u5355\u5143 \u82e5\u8f93\u5165\u7684\u6570\u636e\u6240\u5360\u7684\u7a7a\u95f4\u53ea\u53d6\u51b3\u4e8e\u95ee\u9898\u672c\u8eab\uff0c\u548c\u7b97\u6cd5\u65e0\u5173\uff0c\u8fd9\u6837\u53ea\u9700\u5206\u6790\u8be5\u7b97\u6cd5\u5728\u5b9e\u73b0\u65f6\u6240\u9700\u7684\u8f85\u52a9\u5355\u5143\u5373\u53ef \u7b97\u6cd5\u539f\u5730\u5de5\u4f5c\u662f\u6307\u7b97\u6cd5\u6240\u9700\u7684\u8f85\u52a9\u7a7a\u95f4\u662f\u5e38\u91cf\uff0c\u5373O(1)\u3002","title":"1.\u65f6\u95f4&\u7a7a\u95f4\u590d\u6742\u5ea6"},{"location":"DataStruct/complexity/complexity/#_1","text":"","title":"\u6570\u636e\u7ed3\u6784\u524d\u620f"},{"location":"DataStruct/complexity/complexity/#_2","text":"\u4e00\u822c\u4e0d\u91c7\u7528\u8bb0\u5f55\u7b97\u6cd5\u8fd0\u884c\u65f6\u95f4\u7684\u65b9\u5f0f\u6765\u8bc4\u4f30\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\uff0c\u56e0\u4e3a\u540c\u4e00\u4e2a\u7b97\u6cd5\u5728\u4e0d\u540c\u786c\u4ef6\u4e0a\u7684\u8fd0\u884c\u901f\u5ea6\u5dee\u522b\u5f88\u5927 \u901a\u5e38\u7528\u8fd0\u884c\u6b21\u6570\u53bb\u8868\u793a\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u56e0\u4e3a\u65f6\u95f4\u548c\u8fd0\u884c\u6b21\u6570\u662f\u6b63\u76f8\u5173\u7684 \u65f6\u95f4\u590d\u6742\u5ea6\u6307\u7b97\u6cd5\u4e2d\u6240\u6709\u8bed\u53e5\u7684\u9891\u5ea6\uff08\u6267\u884c\u6b21\u6570\uff09\u4e4b\u548c T(n) = O(f(n)) \u5176\u4e2d\uff0cn\u662f\u95ee\u9898\u7684\u89c4\u6a21\uff0cf(n)\u662f\u95ee\u9898\u89c4\u6a21n\u7684\u67d0\u4e2a\u51fd\u6570 \u5e38\u89c1\u7684\u65f6\u95f4\u590d\u6742\u5ea6 O(1)<O(log2(n))<o(n)<o(nlog2(n))<o(n^2)<o(n^3)<o(2^n)<o(n!) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u8ba1\u7b97\u8981\u5ffd\u7565\u9ad8\u9636\u9879\u7cfb\u6570\u548c\u4f4e\u9636\u9879","title":"\u65f6\u95f4\u590d\u6742\u5ea6"},{"location":"DataStruct/complexity/complexity/#_3","text":"\u7a7a\u95f4\u590d\u6742\u5ea6S(n)\u662f\u6307\u7b97\u6cd5\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6240\u4f7f\u7528\u7684\u8f85\u52a9\u7a7a\u95f4\u7684\u5927\u5c0f \u8bb0\u4e3a\uff1a s(n) = O(f(n)) \u9664\u4e86\u9700\u8981\u5b58\u50a8\u7b97\u6cd5\u672c\u8eab\u7684\u6307\u4ee4\uff0c\u5e38\u6570\uff0c\u53d8\u91cf\u548c\u8f93\u5165\u6570\u636e\u5916\uff0c\u8fd8\u9700\u8981\u5b58\u50a8\u5bf9\u6570\u636e\u64cd\u4f5c\u7684\u5b58\u50a8\u5355\u5143 \u82e5\u8f93\u5165\u7684\u6570\u636e\u6240\u5360\u7684\u7a7a\u95f4\u53ea\u53d6\u51b3\u4e8e\u95ee\u9898\u672c\u8eab\uff0c\u548c\u7b97\u6cd5\u65e0\u5173\uff0c\u8fd9\u6837\u53ea\u9700\u5206\u6790\u8be5\u7b97\u6cd5\u5728\u5b9e\u73b0\u65f6\u6240\u9700\u7684\u8f85\u52a9\u5355\u5143\u5373\u53ef \u7b97\u6cd5\u539f\u5730\u5de5\u4f5c\u662f\u6307\u7b97\u6cd5\u6240\u9700\u7684\u8f85\u52a9\u7a7a\u95f4\u662f\u5e38\u91cf\uff0c\u5373O(1)\u3002","title":"\u7a7a\u95f4\u590d\u6742\u5ea6"},{"location":"DataStruct/queue/queue/","text":"\u961f\u5217 \u961f\u5217\u662f\u4e00\u79cd\u64cd\u4f5c\u53d7\u5230\u7ea6\u675f\u7684\u7ebf\u6027\u8868\uff0c\u53ea\u5141\u8bb8\u5728\u8868\u7684\u4e00\u6bb5\u8fdb\u884c\u63d2\u5165\uff0c\u5728\u8868\u7684\u53e6\u4e00\u7aef\u8fdb\u884c\u5220\u9664 \u5411\u961f\u5217\u4e2d\u63d2\u5165\u5143\u7d20\u6210\u4e3a\u5165\u961f\uff0c\u5220\u9664\u5143\u7d20\u79f0\u4e3a\u51fa\u961f 1. \u5faa\u73af\u961f\u5217 \u5728\u5faa\u73af\u961f\u5217\u4e2d\u5224\u65ad\u961f\u5217\u662f\u5426\u5df2\u7ecf\u6ee1 \u727a\u7272\u4e00\u4e2a\u4f4d\u7f6e\u7684\u5b58\u50a8\u5355\u5143\u4e3a\u7a7a \u5982\u679c rear + 1 == front \u5373\u961f\u5c3e\u7684\u6307\u9488+1\u7b49\u4e8e\u961f\u5934 \u65f6\uff0c\u5faa\u73af\u961f\u5217\u5df2\u6ee1 \u518d\u6b21\u9700\u8981\u6ce8\u610f\uff1a front\u6307\u5411\u7684\u4f4d\u7f6e\u603b\u662f\u5b58\u6709\u5143\u7d20\uff0c\u800c\u4e14\u662f\u5148\u5165\u961f\u7684\u5143\u7d20 rear\u6307\u5411\u7684\u4f4d\u7f6e\u6ca1\u6709\u5143\u7d20\uff0crear\u603b\u662f\u6307\u5411\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e 2.\u987a\u5e8f\u8868\u5b9e\u73b0\u5faa\u73af\u961f\u5217 int main() { SqQueue SQ; bool res; ElemType element; InitQueue(SQ); EnQueue(SQ,1); EnQueue(SQ,2); EnQueue(SQ,3); DeQueue(SQ,element); printf(\"DeQueue->%d\\n\",element); DeQueue(SQ,element); printf(\"DeQueue->%d\\n\",element); return 0; } #define MaxSize 5 typedef int ElemType; typedef struct SqQueue{ ElemType data[MaxSize]; //\u6570\u7ec4\uff0c\u5faa\u73af\u961f\u5217\u6700\u5b58\u50a8MaxSize-1\u4e2a\u5143\u7d20 int front,rear; //\u961f\u5217\u5934\uff0c\u961f\u5217\u5c3e }SqQueue; void InitQueue(SqQueue &Q) { Q.front = Q.rear = 0; //\u521d\u59cb\u5316\u961f\u5217 } bool isEmpty(SqQueue Q) { if(Q.front == Q.rear) { return true; } return false; } 2.1 \u5165\u961f bool EnQueue(SqQueue &Q,ElemType x) { if ((Q.rear+1) % MaxSize == Q.front) { return false; //\u961f\u5217\u6ee1\uff0c\u4e0d\u80fd\u5165\u961f } Q.data[Q.rear] = x; Q.rear = (Q.rear + 1) % MaxSize; // \u6dfb\u52a0\u5b8c\u4e00\u4e2a\u5143\u7d20\u4ee5\u540e\uff0c\u961f\u5c3e\u5411\u540e\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d return true; } 2.2 \u51fa\u961f bool DeQueue(SqQueue &Q,ElemType &x) { if(Q.front == Q.rear) // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a { return false; } x = Q.data[Q.front]; Q.front = (Q.front + 1) % MaxSize; return true; } 3.\u94fe\u8868\u5b9e\u73b0\u961f\u5217 \u91c7\u7528\u5e26\u6709\u5934\u8282\u70b9\uff08front\uff09\u7684\u5355\u94fe\u8868\u5b58\u50a8\u961f\u5217\uff0c\u4e5f\u53ef\u4ee5\u5b9e\u73b0\u5148\u5165\u5148\u51fa\uff0c\u6bcf\u6b21\u5220\u9664\u7b2c\u4e00\u4e2a\u8282\u70b9\uff08front\u6307\u9488\u6240\u6307\u5411\u7684\u8282\u70b9\uff09 int main() { LinkQueue Q; InitQueue(Q); EnQueue(Q, 1); EnQueue(Q, 2); EnQueue(Q, 3); EnQueue(Q, 4); bool res; ElemType element; res = DeQueue(Q, element); if (res) { printf(\"deQueue success element=%d\\n\", element); } else { printf(\"deQueue unsuccess\\n\"); } return 0; } 3.1 \u94fe\u8868\u961f\u5217\u521d\u59cb\u5316 #include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode; typedef struct { LinkNode *front, *rear; } LinkQueue; //\u5e26\u5934\u8282\u70b9\u7684\u94fe\u8868\u5b9e\u73b0\u961f\u5217 void InitQueue(LinkQueue &Q) { Q.front = Q.rear = (LinkNode *) malloc(sizeof(LinkNode)); Q.front->next = NULL; } 3.2 \u5165\u961f void EnQueue(LinkQueue &Q, ElemType x) { LinkNode *newNode = (LinkNode *) malloc(sizeof(LinkNode)); newNode->data = x; newNode->next = NULL; Q.rear->next = newNode; Q.rear = newNode; } 3.3 \u51fa\u961f bool DeQueue(LinkQueue &Q, ElemType &element) { //\u961f\u5217\u4e3a\u7a7a if (Q.rear == Q.front) { return false; } LinkNode *q = Q.front->next; element = q->data; Q.front->next = q->next; if (q == Q.rear) { Q.rear = Q.front; } free(q); return true; } 3.Queue-2019-42 \u9898\u76ee 42.\uff0810\u5206\uff09\u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u961f\u5217\uff0c\u8981\u6c42\u6ee1\u8db3\uff1a1.\u521d\u59cb\u65f6\u961f\u5217\u4e3a\u7a7a\uff1b2.\u5165\u961f\u65f6\uff0c\u5141\u8bb8\u589e\u52a0\u961f\u5217\u5360\u7528\u7a7a\u95f4\uff1b3.\u51fa\u961f\u540e\uff0c\u51fa\u961f\u5143\u7d20\u6240\u5360\u7528\u7684\u7a7a\u95f4\u53ef\u4ee5 \u91cd\u590d\u5229\u7528 \uff0c\u5373\u6574\u4e2a\u961f\u5217\u6240\u5360\u7528\u7684\u7a7a\u95f4\u53ea\u589e\u4e0d\u51cf\uff1b4.\u5165\u961f\u64cd\u4f5c\u548c\u51fa\u961f\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO\uff081\uff09\u3002 \u56de\u7b54\u4ee5\u4e0b\u95ee\u9898\uff1a \u8be5\u961f\u5217\u9009\u62e9 \u94fe\u5f0f\u5b58\u50a8 \u8fd8\u662f\u987a\u5e8f\u5b58\u50a8\uff1f \u753b\u51fa\u961f\u5217\u7684\u521d\u59cb\u72b6\u6001\uff0c\u5e76\u7ed9\u51fa\u5224\u65ad\u961f\u7a7a\u548c\u961f\u6ee1\u7684\u6761\u4ef6 \u753b\u51fa\u7b2c\u4e00\u4e2a\u5143\u7d20\u5165\u961f\u540e\u7684\u961f\u5217\u72b6\u6001 \u7ed9\u51fa\u5165\u961f\u64cd\u4f5c\u548c\u51fa\u961f\u64cd\u4f5c\u7684\u57fa\u672c\u8fc7\u7a0b (1)\u94fe\u5f0f\u5b58\u50a8 (2)\u521d\u59cb\u72b6\u6001 \u753b\u51fa\u961f\u5217\u7684\u521d\u59cb\u72b6\u6001\uff0c\u5e76\u7ed9\u51fa\u5224\u65ad\u961f\u7a7a\u548c\u961f\u6ee1\u7684\u6761\u4ef6 \u200b \u521d\u59cb\u65f6\uff0c\u521b\u5efa\u53ea\u6709\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\u7684\u94fe\u8868\uff0crear\uff0cfront\u6307\u9488\u90fd\u6307\u5411\u7b2c\u4e00\u4e2a\u7a7a\u95f2\u7684\u8282\u70b9 \u65b0\u589e\u4e00\u4e2a\u5143\u7d20\u4e4b\u540e\uff1a \u961f\u7a7a\u7684\u5224\u5b9a\u6761\u4ef6\uff1afront=rear \u961f\u6ee1\u7684\u5224\u5b9a\u6761\u4ef6\uff1afront=rear->next (3)\u7b2c\u4e00\u4e2a\u5143\u7d20\u5165\u961f \u5728\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\u4e4b\u540e\uff0c\u4e00\u5b9a\u8981 \u786e\u4fdd\u5f53\u524d\u8282\u70b9\u7684next\u662f\u4e0b\u4e00\u4e2a\u7a7a\u8282\u70b9 (4)\u5165\u961f\u548c\u51fa\u961f\u64cd\u4f5c \u51fa\u961f\u64cd\u4f5c\uff1a \u79fb\u9664front\u6307\u9488\u6307\u5411\u7684\u8282\u70b9\u5b58\u50a8\u7684\u5143\u7d20\uff0c\u5e76\u5c06front\u6307\u9488\u5411\u524d\u79fb\u52a8front=front->next \u5165\u961f\u64cd\u4f5c\uff1a \u5c06\u65b0\u5143\u7d20Element\u653e\u5728Element2\u4e4b\u540e\uff0c\u540c\u65f6\u5c06rear\u6307\u5411\u4e4b\u524d\u79fb\u9664\u5143\u7d20\u7684\u8282\u70b9 \u5165\u961f\u64cd\u4f5c: if(front=rear->next) // \u961f\u6ee1 { \u5728rear\u4e4b\u540e\u63d2\u5165\u4e00\u4e2a\u65b0\u8282\u70b9 } \u5165\u961f\u5143\u7d20\u4fdd\u5b58\u5728rear\u6240\u6307\u5411\u7684\u8282\u70b9\u4e2d; rear=rear->next; \u51fa\u961f\u64cd\u4f5c: if (front == rear) //\u961f\u7a7a { \u51fa\u961f\u5931\u8d25return; } // \u5982\u679c\u5bf9\u5217\u4e0d\u4e3a\u7a7a \u53d6front\u6240\u6307\u5411\u7684\u5143\u7d20element\uff0cfront\u524d\u79fb front=front->next; return element; 4.\u94fe\u8868\u5b9e\u73b0\u5faa\u73af\u961f\u5217 4.1 \u5b9a\u4e49 #include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; void CircleQueue(LinkList &front, LinkList &rear) { //\u8fdb\u884c\u521d\u59cb\u5316 front = (LinkList) malloc(sizeof(LNode)); rear = front; rear->next = front; //\u5165\u961f\u4e24\u4e2a\u5143\u7d20 EnQueue(front,rear,3); EnQueue(front,rear,4); //\u51fa\u961f Dequeue(front,rear); Dequeue(front,rear); Dequeue(front,rear); } int main() { LinkList front, rear; CircleQueue(front, rear); } 4.2 \u5165\u961f void EnQueue(LinkList front, LinkList &rear, ElemType val) { LinkList pnew; if (rear->next == front) { //rear\u5f53\u524d\u662f\u7a7a\u8282\u70b9\uff0c\u5982\u679crear->next== front\uff0c\u8bf4\u660e\u961f\u5217\u6ee1 //\u7533\u8bf7\u65b0\u8282\u70b9 pnew = (LinkList) malloc(sizeof(LNode)); //\u63d2\u5165\u7684\u5143\u7d20\u653e\u5728rear\u8282\u70b9\u4e2d\uff0c\u800c\u4e0d\u653e\u5728\u65b0\u7533\u8bf7\u7684\u7a7a\u8282\u70b9\u4e2d rear->data = val; rear->next = pnew; pnew->next = front; rear = pnew; } else { //\u961f\u5217\u4e0d\u6ee1\uff0c\u76f4\u63a5\u653e\u503c\uff0crear\u540e\u79fb\u4e00\u4e2a\u8282\u70b9 rear->data = val; rear = rear->next; } } 4.3 \u51fa\u961f void Dequeue(LinkList &front,LinkList rear) { if (front==rear) { printf(\"empty queue\\n\"); }else{ printf(\"Dequeue->%d\\n\",front->data); front=front->next; } }","title":"4.\u961f\u5217"},{"location":"DataStruct/queue/queue/#_1","text":"\u961f\u5217\u662f\u4e00\u79cd\u64cd\u4f5c\u53d7\u5230\u7ea6\u675f\u7684\u7ebf\u6027\u8868\uff0c\u53ea\u5141\u8bb8\u5728\u8868\u7684\u4e00\u6bb5\u8fdb\u884c\u63d2\u5165\uff0c\u5728\u8868\u7684\u53e6\u4e00\u7aef\u8fdb\u884c\u5220\u9664 \u5411\u961f\u5217\u4e2d\u63d2\u5165\u5143\u7d20\u6210\u4e3a\u5165\u961f\uff0c\u5220\u9664\u5143\u7d20\u79f0\u4e3a\u51fa\u961f","title":"\u961f\u5217"},{"location":"DataStruct/queue/queue/#1","text":"\u5728\u5faa\u73af\u961f\u5217\u4e2d\u5224\u65ad\u961f\u5217\u662f\u5426\u5df2\u7ecf\u6ee1 \u727a\u7272\u4e00\u4e2a\u4f4d\u7f6e\u7684\u5b58\u50a8\u5355\u5143\u4e3a\u7a7a \u5982\u679c rear + 1 == front \u5373\u961f\u5c3e\u7684\u6307\u9488+1\u7b49\u4e8e\u961f\u5934 \u65f6\uff0c\u5faa\u73af\u961f\u5217\u5df2\u6ee1 \u518d\u6b21\u9700\u8981\u6ce8\u610f\uff1a front\u6307\u5411\u7684\u4f4d\u7f6e\u603b\u662f\u5b58\u6709\u5143\u7d20\uff0c\u800c\u4e14\u662f\u5148\u5165\u961f\u7684\u5143\u7d20 rear\u6307\u5411\u7684\u4f4d\u7f6e\u6ca1\u6709\u5143\u7d20\uff0crear\u603b\u662f\u6307\u5411\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e","title":"1. \u5faa\u73af\u961f\u5217"},{"location":"DataStruct/queue/queue/#2","text":"int main() { SqQueue SQ; bool res; ElemType element; InitQueue(SQ); EnQueue(SQ,1); EnQueue(SQ,2); EnQueue(SQ,3); DeQueue(SQ,element); printf(\"DeQueue->%d\\n\",element); DeQueue(SQ,element); printf(\"DeQueue->%d\\n\",element); return 0; } #define MaxSize 5 typedef int ElemType; typedef struct SqQueue{ ElemType data[MaxSize]; //\u6570\u7ec4\uff0c\u5faa\u73af\u961f\u5217\u6700\u5b58\u50a8MaxSize-1\u4e2a\u5143\u7d20 int front,rear; //\u961f\u5217\u5934\uff0c\u961f\u5217\u5c3e }SqQueue; void InitQueue(SqQueue &Q) { Q.front = Q.rear = 0; //\u521d\u59cb\u5316\u961f\u5217 } bool isEmpty(SqQueue Q) { if(Q.front == Q.rear) { return true; } return false; }","title":"2.\u987a\u5e8f\u8868\u5b9e\u73b0\u5faa\u73af\u961f\u5217"},{"location":"DataStruct/queue/queue/#21","text":"bool EnQueue(SqQueue &Q,ElemType x) { if ((Q.rear+1) % MaxSize == Q.front) { return false; //\u961f\u5217\u6ee1\uff0c\u4e0d\u80fd\u5165\u961f } Q.data[Q.rear] = x; Q.rear = (Q.rear + 1) % MaxSize; // \u6dfb\u52a0\u5b8c\u4e00\u4e2a\u5143\u7d20\u4ee5\u540e\uff0c\u961f\u5c3e\u5411\u540e\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d return true; }","title":"2.1 \u5165\u961f"},{"location":"DataStruct/queue/queue/#22","text":"bool DeQueue(SqQueue &Q,ElemType &x) { if(Q.front == Q.rear) // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a { return false; } x = Q.data[Q.front]; Q.front = (Q.front + 1) % MaxSize; return true; }","title":"2.2 \u51fa\u961f"},{"location":"DataStruct/queue/queue/#3","text":"\u91c7\u7528\u5e26\u6709\u5934\u8282\u70b9\uff08front\uff09\u7684\u5355\u94fe\u8868\u5b58\u50a8\u961f\u5217\uff0c\u4e5f\u53ef\u4ee5\u5b9e\u73b0\u5148\u5165\u5148\u51fa\uff0c\u6bcf\u6b21\u5220\u9664\u7b2c\u4e00\u4e2a\u8282\u70b9\uff08front\u6307\u9488\u6240\u6307\u5411\u7684\u8282\u70b9\uff09 int main() { LinkQueue Q; InitQueue(Q); EnQueue(Q, 1); EnQueue(Q, 2); EnQueue(Q, 3); EnQueue(Q, 4); bool res; ElemType element; res = DeQueue(Q, element); if (res) { printf(\"deQueue success element=%d\\n\", element); } else { printf(\"deQueue unsuccess\\n\"); } return 0; }","title":"3.\u94fe\u8868\u5b9e\u73b0\u961f\u5217"},{"location":"DataStruct/queue/queue/#31","text":"#include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode; typedef struct { LinkNode *front, *rear; } LinkQueue; //\u5e26\u5934\u8282\u70b9\u7684\u94fe\u8868\u5b9e\u73b0\u961f\u5217 void InitQueue(LinkQueue &Q) { Q.front = Q.rear = (LinkNode *) malloc(sizeof(LinkNode)); Q.front->next = NULL; }","title":"3.1 \u94fe\u8868\u961f\u5217\u521d\u59cb\u5316"},{"location":"DataStruct/queue/queue/#32","text":"void EnQueue(LinkQueue &Q, ElemType x) { LinkNode *newNode = (LinkNode *) malloc(sizeof(LinkNode)); newNode->data = x; newNode->next = NULL; Q.rear->next = newNode; Q.rear = newNode; }","title":"3.2 \u5165\u961f"},{"location":"DataStruct/queue/queue/#33","text":"bool DeQueue(LinkQueue &Q, ElemType &element) { //\u961f\u5217\u4e3a\u7a7a if (Q.rear == Q.front) { return false; } LinkNode *q = Q.front->next; element = q->data; Q.front->next = q->next; if (q == Q.rear) { Q.rear = Q.front; } free(q); return true; }","title":"3.3 \u51fa\u961f"},{"location":"DataStruct/queue/queue/#3queue-2019-42","text":"","title":"3.Queue-2019-42"},{"location":"DataStruct/queue/queue/#_2","text":"42.\uff0810\u5206\uff09\u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u961f\u5217\uff0c\u8981\u6c42\u6ee1\u8db3\uff1a1.\u521d\u59cb\u65f6\u961f\u5217\u4e3a\u7a7a\uff1b2.\u5165\u961f\u65f6\uff0c\u5141\u8bb8\u589e\u52a0\u961f\u5217\u5360\u7528\u7a7a\u95f4\uff1b3.\u51fa\u961f\u540e\uff0c\u51fa\u961f\u5143\u7d20\u6240\u5360\u7528\u7684\u7a7a\u95f4\u53ef\u4ee5 \u91cd\u590d\u5229\u7528 \uff0c\u5373\u6574\u4e2a\u961f\u5217\u6240\u5360\u7528\u7684\u7a7a\u95f4\u53ea\u589e\u4e0d\u51cf\uff1b4.\u5165\u961f\u64cd\u4f5c\u548c\u51fa\u961f\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO\uff081\uff09\u3002 \u56de\u7b54\u4ee5\u4e0b\u95ee\u9898\uff1a \u8be5\u961f\u5217\u9009\u62e9 \u94fe\u5f0f\u5b58\u50a8 \u8fd8\u662f\u987a\u5e8f\u5b58\u50a8\uff1f \u753b\u51fa\u961f\u5217\u7684\u521d\u59cb\u72b6\u6001\uff0c\u5e76\u7ed9\u51fa\u5224\u65ad\u961f\u7a7a\u548c\u961f\u6ee1\u7684\u6761\u4ef6 \u753b\u51fa\u7b2c\u4e00\u4e2a\u5143\u7d20\u5165\u961f\u540e\u7684\u961f\u5217\u72b6\u6001 \u7ed9\u51fa\u5165\u961f\u64cd\u4f5c\u548c\u51fa\u961f\u64cd\u4f5c\u7684\u57fa\u672c\u8fc7\u7a0b","title":"\u9898\u76ee"},{"location":"DataStruct/queue/queue/#1_1","text":"","title":"(1)\u94fe\u5f0f\u5b58\u50a8"},{"location":"DataStruct/queue/queue/#2_1","text":"\u753b\u51fa\u961f\u5217\u7684\u521d\u59cb\u72b6\u6001\uff0c\u5e76\u7ed9\u51fa\u5224\u65ad\u961f\u7a7a\u548c\u961f\u6ee1\u7684\u6761\u4ef6 \u200b \u521d\u59cb\u65f6\uff0c\u521b\u5efa\u53ea\u6709\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\u7684\u94fe\u8868\uff0crear\uff0cfront\u6307\u9488\u90fd\u6307\u5411\u7b2c\u4e00\u4e2a\u7a7a\u95f2\u7684\u8282\u70b9 \u65b0\u589e\u4e00\u4e2a\u5143\u7d20\u4e4b\u540e\uff1a \u961f\u7a7a\u7684\u5224\u5b9a\u6761\u4ef6\uff1afront=rear \u961f\u6ee1\u7684\u5224\u5b9a\u6761\u4ef6\uff1afront=rear->next","title":"(2)\u521d\u59cb\u72b6\u6001"},{"location":"DataStruct/queue/queue/#3_1","text":"\u5728\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\u4e4b\u540e\uff0c\u4e00\u5b9a\u8981 \u786e\u4fdd\u5f53\u524d\u8282\u70b9\u7684next\u662f\u4e0b\u4e00\u4e2a\u7a7a\u8282\u70b9","title":"(3)\u7b2c\u4e00\u4e2a\u5143\u7d20\u5165\u961f"},{"location":"DataStruct/queue/queue/#4","text":"\u51fa\u961f\u64cd\u4f5c\uff1a \u79fb\u9664front\u6307\u9488\u6307\u5411\u7684\u8282\u70b9\u5b58\u50a8\u7684\u5143\u7d20\uff0c\u5e76\u5c06front\u6307\u9488\u5411\u524d\u79fb\u52a8front=front->next \u5165\u961f\u64cd\u4f5c\uff1a \u5c06\u65b0\u5143\u7d20Element\u653e\u5728Element2\u4e4b\u540e\uff0c\u540c\u65f6\u5c06rear\u6307\u5411\u4e4b\u524d\u79fb\u9664\u5143\u7d20\u7684\u8282\u70b9 \u5165\u961f\u64cd\u4f5c: if(front=rear->next) // \u961f\u6ee1 { \u5728rear\u4e4b\u540e\u63d2\u5165\u4e00\u4e2a\u65b0\u8282\u70b9 } \u5165\u961f\u5143\u7d20\u4fdd\u5b58\u5728rear\u6240\u6307\u5411\u7684\u8282\u70b9\u4e2d; rear=rear->next; \u51fa\u961f\u64cd\u4f5c: if (front == rear) //\u961f\u7a7a { \u51fa\u961f\u5931\u8d25return; } // \u5982\u679c\u5bf9\u5217\u4e0d\u4e3a\u7a7a \u53d6front\u6240\u6307\u5411\u7684\u5143\u7d20element\uff0cfront\u524d\u79fb front=front->next; return element;","title":"(4)\u5165\u961f\u548c\u51fa\u961f\u64cd\u4f5c"},{"location":"DataStruct/queue/queue/#4_1","text":"","title":"4.\u94fe\u8868\u5b9e\u73b0\u5faa\u73af\u961f\u5217"},{"location":"DataStruct/queue/queue/#41","text":"#include <stdio.h> #include <stdlib.h> typedef int ElemType; typedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; void CircleQueue(LinkList &front, LinkList &rear) { //\u8fdb\u884c\u521d\u59cb\u5316 front = (LinkList) malloc(sizeof(LNode)); rear = front; rear->next = front; //\u5165\u961f\u4e24\u4e2a\u5143\u7d20 EnQueue(front,rear,3); EnQueue(front,rear,4); //\u51fa\u961f Dequeue(front,rear); Dequeue(front,rear); Dequeue(front,rear); } int main() { LinkList front, rear; CircleQueue(front, rear); }","title":"4.1 \u5b9a\u4e49"},{"location":"DataStruct/queue/queue/#42","text":"void EnQueue(LinkList front, LinkList &rear, ElemType val) { LinkList pnew; if (rear->next == front) { //rear\u5f53\u524d\u662f\u7a7a\u8282\u70b9\uff0c\u5982\u679crear->next== front\uff0c\u8bf4\u660e\u961f\u5217\u6ee1 //\u7533\u8bf7\u65b0\u8282\u70b9 pnew = (LinkList) malloc(sizeof(LNode)); //\u63d2\u5165\u7684\u5143\u7d20\u653e\u5728rear\u8282\u70b9\u4e2d\uff0c\u800c\u4e0d\u653e\u5728\u65b0\u7533\u8bf7\u7684\u7a7a\u8282\u70b9\u4e2d rear->data = val; rear->next = pnew; pnew->next = front; rear = pnew; } else { //\u961f\u5217\u4e0d\u6ee1\uff0c\u76f4\u63a5\u653e\u503c\uff0crear\u540e\u79fb\u4e00\u4e2a\u8282\u70b9 rear->data = val; rear = rear->next; } }","title":"4.2 \u5165\u961f"},{"location":"DataStruct/queue/queue/#43","text":"void Dequeue(LinkList &front,LinkList rear) { if (front==rear) { printf(\"empty queue\\n\"); }else{ printf(\"Dequeue->%d\\n\",front->data); front=front->next; } }","title":"4.3 \u51fa\u961f"},{"location":"DataStruct/search/search/","text":"\u67e5\u627e\u7b97\u6cd5 1.\u987a\u5e8f\u67e5\u627e \u987a\u5e8f\u67e5\u627e\u53c8\u79f0\u4e3a\u7ebf\u6027\u67e5\u627e\uff0c\u5bf9\u4e8e\u987a\u5e8f\u8868\u548c\u94fe\u8868\u90fd\u9002\u7528\u3002 \u8fd9\u91cc\u7684\u987a\u5e8f\u67e5\u627e\u9002\u7528\u7684 \u54e8\u5175\uff1a \u5c06\u8981\u67e5\u627e\u7684\u6570\u7ec4\u7684\u7b2c0\u4e2a\u4f4d\u7f6e\u7559\u7ed9\u54e8\u5175\uff0c\u4ece\u540e\u5411\u524d\u5faa\u73af\uff0c\u53ef\u4ee5\u66f4\u52a0\u7b80\u6d01 ElemType ST_Search(SSTable ST, ElemType key) { ST.elem[0] = key; int i; for (i = ST.TableLen-1; ST.elem[i] != ST.elem[0] ;i--) { } return i; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> typedef int ElemType; typedef struct SSTable{ ElemType *elem; int TableLen; }; void ST_Init(SSTable &ST,int length) { ST.TableLen = length + 1; ST.elem = (ElemType*) malloc(sizeof (SSTable) * ST.TableLen); int i; srand(time(NULL)); for (i=1;i<ST.TableLen;i++) { ST.elem[i] = rand() % 100; } } void ST_Print(SSTable ST) { for (int i = 1; i < ST.TableLen; ++i) { printf(\"%3d\",ST.elem[i]); } printf(\"\\n\"); } ElemType ST_Search(SSTable ST, ElemType key) { ST.elem[0] = key; int i; for (i = ST.TableLen-1; ST.elem[i] != ST.elem[0] ;i--) { } return i; } int main() { SSTable ST; ST_Init(ST,15); ST_Print(ST); ElemType res; ElemType key; scanf(\"%d\",&key); res= ST_Search(ST,key); if (res) { printf(\"search_res->%d\\n\",res); } else{ printf(\"not find\\n\"); } return 0; } 2.\u4e8c\u5206\u67e5\u627e \u4e8c\u5206\u67e5\u627e\u6f14\u793a\ud83c\udf88 \u4e8c\u5206\u67e5\u627e\u4e5f\u53eb\u6298\u534a\u67e5\u627e \uff0c\u5b83\u4ec5\u4ec5\u662f\u7528\u4e8e \u6709\u5e8f\u7684\u987a\u5e8f\u8868 \u4e8c\u5206\u67e5\u627e\u7684\u57fa\u672c\u601d\u60f3\uff1a \u5c06\u7ed9\u5b9a\u7684key\u4e0e\u8868\u4e2d\u95f4\u4f4d\u7f6e\u7684\u5143\u7d20\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u540c->\u67e5\u627e\u6210\u529f \u5982\u679c\u4e0d\u540c\uff0c\u5728\u4e2d\u95f4\u5143\u7d20\u7684\u524d\u534a\u6bb5\u6216\u540e\u534a\u6bb5\u5206\u522b\u8fdb\u884c\u7b2c\u4e00\u6b65\u7684\u64cd\u4f5c\uff0c\u76f4\u5230\u67e5\u627e\u6210\u529f \u5982\u679c\u5b9e\u5728\u6ca1\u6709\u627e\u5230\u5143\u7d20\uff0c\u5219\u67e5\u627e\u4e0d\u6210\u529f \u6f14\u793a\u7684\u8fc7\u7a0b\uff1a \u521d\u59cb\u5316\u987a\u5e8f\u8868\uff0c\u653e\u516510\u4e2a\u5143\u7d20 \u9002\u7528qsort\u63a5\u53e3\u8fdb\u884c\u6392\u5e8f\uff0c\u5e76\u6253\u5370 \u8fdb\u884c\u67e5\u627e \u4e8c\u5206\u67e5\u627e\u4ee3\u7801\uff1a ElemType BinarySearch(SSTable L,ElemType key) { int low=0; int high=L.TableLen-1; int mid; while (low<=high) { mid=(low+high)/2; if(key>L.elem[mid]) { low=mid+1; } else if(key<L.elem[mid]) { high=mid-1; } else{ return mid; } } return -1; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> typedef int ElemType; typedef struct SSTable{ ElemType *elem; int TableLen; }; void ST_Init(SSTable &ST,int length) { ST.TableLen = length; ST.elem = (ElemType*) malloc(sizeof (SSTable) * ST.TableLen); int i; srand(time(NULL)); for (i=0;i<ST.TableLen;i++) { ST.elem[i] = rand() % 100; } } void ST_Print(SSTable ST) { for (int i = 0; i < ST.TableLen; ++i) { printf(\"%3d\",ST.elem[i]); } printf(\"\\n\"); } ElemType BinarySearch(SSTable L,ElemType key) { int low=0; int high=L.TableLen-1; int mid; while (low<=high) { mid=(low+high)/2; if(key>L.elem[mid]) { low=mid+1; } else if(key<L.elem[mid]) { high=mid-1; } else{ return mid; } } return -1; } //\u51fd\u6570\u540d\u4e2d\u5b58\u7684\u662f\u51fd\u6570\u7684\u5165\u53e3\u5730\u5740\uff0c\u4e5f\u662f\u4e00\u4e2a\u6307\u9488\uff08\u51fd\u6570\u6307\u9488\uff09 //qsort\u89c4\u5b9a\u5982\u679cleft\u6307\u9488\u6307\u5411\u7684\u503c\u5927\u4e8eright\u6307\u9488\u6307\u5411\u7684\u503c\uff0c\u8fd4\u56de\u6b63\u503c\uff0c\u5426\u5219\u8fd4\u56de\u8d1f int compare(const void *left,const void *right) { return *(int*)left-*(int*)right; } int main() { SSTable ST; ST_Init(ST,10); ST_Print(ST); qsort(ST.elem,ST.TableLen,sizeof (ElemType),compare); ST_Print(ST); ElemType key; printf(\"please input search key:\\n\"); scanf(\"%d\",&key); int res; res = BinarySearch(ST,key); if (res!=-1) { printf(\"search res->%d\\n\",res); } else{ printf(\"not find\\n\"); } return 0; } qsort\u63a5\u53e3 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) base --\u6307\u5411\u8981\u6392\u5e8f\u6570\u7ec4\u7684\u6307\u9488 nitems --\u6570\u7ec4\u4e2d\u5143\u7d20\u7684\u4e2a\u6570 size -- \u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5927\u5c0f (sizeof(int)) compar -- \u6bd4\u8f83\u4e24\u4e2a\u5143\u7d20\u7684\u51fd\u6570\uff0c\u8fd4\u56de\u503c\u5fc5\u987b\u662f\u6307\u5b9a\u7c7b\u578b(\u8fd9\u91cc\u662fint) qsort\u89c4\u5b9a\u5982\u679cleft\u6307\u9488\u6307\u5411\u7684\u503c\u5927\u4e8eright\u6307\u9488\u6307\u5411\u7684\u503c\uff0c\u8fd4\u56de\u6b63\u503c\uff0c\u5426\u5219\u8fd4\u56de\u8d1f\uff0c\u76f8\u7b49\u8fd4\u56de0 qsort\u63a5\u53e3\u7684\u4f8b\u5b50\uff1a #include <stdio.h> #include <stdlib.h> int values[] = { 88, 56, 100, 2, 25 }; int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int main() { int n; printf(\"\u6392\u5e8f\u4e4b\u524d\u7684\u5217\u8868\uff1a\\n\"); for( n = 0 ; n < 5; n++ ) { printf(\"%d \", values[n]); } qsort(values, 5, sizeof(int), cmpfunc); printf(\"\\n\u6392\u5e8f\u4e4b\u540e\u7684\u5217\u8868\uff1a\\n\"); for( n = 0 ; n < 5; n++ ) { printf(\"%d \", values[n]); } return(0); } \u8fd0\u884c\u7ed3\u679c\uff1a \u6392\u5e8f\u4e4b\u524d\u7684\u5217\u8868\uff1a 88 56 100 2 25 \u6392\u5e8f\u4e4b\u540e\u7684\u5217\u8868\uff1a 2 25 56 88 100 3.\u4e8c\u53c9\u67e5\u627e\u6811 \u4e8c\u53c9\u6392\u5e8f\u6811\u6f14\u793a\ud83c\udf88 \u4e8c\u53c9\u67e5\u627e\u6811\u4e5f\u53eb\u4e8c\u53c9\u6392\u5e8f\u6811\uff0c\u6216\u8005\u662f\u4e00\u68f5\u7a7a\u6811\u3002 \u5177\u6709\u4ee5\u4e0b\u7684\u7279\u6027\uff1a \u5982\u679c\u5de6\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u5de6\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5c0f\u4e8e\u6839\u7ed3\u70b9 \u5982\u679c\u53f3\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u53f3\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5927\u4e8e\u6839\u7ed3\u70b9 \u5de6\u53f3\u5b50\u6811\u4e5f\u5206\u522b\u662f\u4e00\u68f5\u4e8c\u53c9\u6392\u5e8f\u6811 \u770b\u4efb\u4f55\u4e00\u4e2a\u6700\u5c0f\u5355\u5143\u7684\u6811\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u5de6\u5b69\u5b50\u7ed3\u70b9\u5c0f\u4e8e\u6839\u8282\u70b9\uff0c\u53f3\u5b69\u5b50\u7ed3\u70b9\u5927\u4e8e\u6839\u7ed3\u70b9 \u4f8b\u5982\uff1a \u4f7f\u7528\u4e8c\u53c9\u67e5\u627e\u6811\u67e5\u627e\u5143\u7d20\uff0c\u67e5\u627e\u7684\u6700\u591a\u6b21\u6570\u5c31\u662f\u6811\u7684\u9ad8\u5ea6\u3002 \u4e2d\u5e8f\u904d\u5386\u4e8c\u53c9\u67e5\u627e\u6811\uff0c\u5f97\u5230\u7684\u662f\u4ece\u5c0f\u5230\u5927\u7684\u7ed3\u679c 1.\u975e\u9012\u5f52\u5efa\u7acb\u4e8c\u53c9\u67e5\u627e\u6811 parent\u8282\u70b9\u7528\u6765\u6307\u793a\u8981\u63d2\u5165\u7684\u4f4d\u7f6e\u7684\u7236\u4eb2\u8282\u70b9 \u5f53\u627e\u5230\u4e3aNULL\u7684p\u8282\u70b9\u65f6\uff0c\u8df3\u51fa\u5faa\u73af void Creat_BST(BiTree &T, KeyType *str, int len) { int i; for (i = 0; i < len; i++) { BST_Insert(T, str[i]); } } int BST_Insert(BiTree &T, KeyType k) { BiTree TreeNew = (BiTree) calloc(1, sizeof(BSTNode)); TreeNew->Key=k; if (NULL==T) { T=TreeNew; return 0; } //\u7528\u6765\u904d\u5386\u6811 BiTree p=T,parent; while (p) { parent=p; if (k>p->Key) { p=p->rchild; } else if (k<p->Key) { p=p->lchild; } else{ //\u76f8\u7b49\u7684\u5143\u7d20\u4e0d\u653e\u5165\u67e5\u627e\u6811\uff0c\u8fd4\u56de-1 return -1; } } if (k>parent->Key) { parent->rchild=TreeNew; } else{ parent->lchild=TreeNew; } return 0; } 2.\u9012\u5f52\u5efa\u7acb\u4e8c\u53c9\u67e5\u627e\u6811 int RecurveBST_Insert(BiTree &T,KeyType k) { if (NULL==T) { T=(BiTree) malloc(sizeof (BSTNode)); T->Key=k; T->lchild=T->rchild=NULL; return 1; } else if(k==T->Key) { return 0; } else if (k<T->Key) { return BST_Insert(T->lchild,k); } else{ return BST_Insert(T->rchild,k); } } \u51fd\u6570int RecurveBST_Insert(BiTree &T,KeyType k)\u4f20\u5165\u5f15\u7528\u7c7b\u578b \u5728\u9012\u5f52\u8fc7\u7a0b\u4e2d\uff0c\u9012\u5f52\u65f6\u4f20\u5165\u7684\u53c2\u6570\u4f9d\u7136\u662f\u5f15\u7528\u7c7b\u578b 3.\u4f7f\u7528\u4e8c\u53c9\u67e5\u627e\u6811\u67e5\u627e BiTree BST_Search(BiTree T,KeyType k,BiTree &parent) { parent=NULL; while (T!=NULL && k!=T->Key) { parent=T; if (k>T->Key) { T=T->rchild; } else{ T=T->lchild; } } return T; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include \"stdlib.h\" //\u4e8c\u53c9\u6392\u5e8f\u6811 typedef int KeyType; typedef struct BSTNode { KeyType Key; struct BSTNode *lchild, *rchild; } BSTNode, *BiTree; //\u975e\u9012\u5f52\u521b\u5efa\u4e8c\u53c9\u67e5\u627e\u6811 int BST_Insert(BiTree &T, KeyType k) { BiTree TreeNew = (BiTree) calloc(1, sizeof(BSTNode)); TreeNew->Key=k; if (NULL==T) { T=TreeNew; return 0; } //\u7528\u6765\u904d\u5386\u6811 BiTree p=T,parent; while (p) { parent=p; if (k>p->Key) { p=p->rchild; } else if (k<p->Key) { p=p->lchild; } else{ //\u76f8\u7b49\u7684\u5143\u7d20\u4e0d\u653e\u5165\u67e5\u627e\u6811\uff0c\u8fd4\u56de-1 return -1; } } if (k>parent->Key) { parent->rchild=TreeNew; } else{ parent->lchild=TreeNew; } return 0; } void Creat_BST(BiTree &T, KeyType *str, int len) { int i; for (i = 0; i < len; i++) { BST_Insert(T, str[i]); } } void InOrder(BiTree T) { if (T!=NULL) { InOrder(T->lchild); printf(\"%3d\",T->Key); InOrder(T->rchild); } } BiTree BST_Search(BiTree T,KeyType k,BiTree &parent) { parent=NULL; while (T!=NULL && k!=T->Key) { parent=T; if (k>T->Key) { T=T->rchild; } else{ T=T->lchild; } } return T; } int RecurveBST_Insert(BiTree &T,KeyType k) { if (NULL==T) { T=(BiTree) malloc(sizeof (BSTNode)); T->Key=k; T->lchild=T->rchild=NULL; return 1; } else if(k==T->Key) { return 0; } else if (k<T->Key) { return BST_Insert(T->lchild,k); } else{ return BST_Insert(T->rchild,k); } } int main() { BiTree T = NULL; KeyType str[7] = {54, 20, 66, 40, 28, 79, 58}; Creat_BST(T, str, 7); InOrder(T); printf(\"\\n\"); BiTree res,parent; res=BST_Search(T,40,parent); if (res) { printf(\"find res->%d\\n\",res->Key); } else{ printf(\"not find\\n\"); } return 1; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/search/BinarySearchTree/cmake-build-debug/BinarySearchTree 20 28 40 54 58 66 79 find res->40 4.\u4e8c\u53c9\u67e5\u627e\u6811\u5220\u9664\u5143\u7d20 \u903b\u8f91\u8fc7\u7a0b\uff1a \u9996\u5148\u5b9a\u4f4d\u5230\u8981\u5220\u9664\u7684\u7ed3\u70b9\uff0c\u6839\u7ed3\u70b9\u5982\u679c\u5927\u4e8e\u8981\u5220\u9664\u7684\u5143\u7d20\uff0c\u8d70\u5de6\u5b50\u6811\uff0c\u5426\u5219\u8d70\u53f3\u5b50\u6811 \u5224\u65ad\u8981\u5220\u9664\u7684\u7ed3\u70b9\u7684\u5b50\u7ed3\u70b9\u662f\u5426\u4e3a\u7a7a \u5982\u679c\u5de6\u7ed3\u70b9\u4e3a\u7a7a\uff08\u5de6\u53f3\u7ed3\u70b9\u90fd\u4e3a\u7a7a\uff09\uff0c\u5c06\u5220\u9664\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u6307\u5411\u53f3\u5b69\u5b50\u8282\u70b9 \u5982\u679c\u53f3\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u5c06\u5220\u9664\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u6307\u5411\u5de6\u5b69\u5b50\u8282\u70b9 \u5982\u679c\u5de6\u53f3\u5b69\u5b50\u8282\u70b9\u90fd\u4e0d\u4e3a\u7a7a \u627e\u5de6\u5b50\u6811\u7684\u6700\u53f3\u5b69\u5b50\u8282\u70b9\u653e\u5728\u8981\u5220\u9664\u5143\u7d20\u7684\u4f4d\u7f6e \u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u6811\u8fd8\u662f\u4e00\u68f5\u4e8c\u53c9\u67e5\u627e\u6811 void DeleteNode(BiTree &root,KeyType x) { if (NULL==root) { return; } if (root->Key>x) { DeleteNode(root->lchild,x); } else if (root->Key<x) { DeleteNode(root->rchild,x); } else{ //\u627e\u5230\u4e86\u8981\u5220\u9664\u7684\u8282\u70b9 if (root->lchild==NULL) { BiTree tmpNode=root; root=root->rchild; free(tmpNode); } else if (root->rchild==NULL) { BiTree tmpNode=root; root=root->lchild; free(tmpNode); }else{ //\u5de6\u53f3\u5b50\u6811\u90fd\u4e0d\u4e3a\u7a7a BiTree tmpNode=root->lchild; while (tmpNode->rchild!=NULL) { tmpNode=tmpNode->rchild; } root->Key=tmpNode->Key; DeleteNode(root->lchild,tmpNode->Key); } } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include \"stdlib.h\" //\u4e8c\u53c9\u6392\u5e8f\u6811 typedef int KeyType; typedef struct BSTNode { KeyType Key; struct BSTNode *lchild, *rchild; } BSTNode, *BiTree; //\u975e\u9012\u5f52\u521b\u5efa\u4e8c\u53c9\u67e5\u627e\u6811 int BST_Insert(BiTree &T, KeyType k) { BiTree TreeNew = (BiTree) calloc(1, sizeof(BSTNode)); TreeNew->Key=k; if (NULL==T) { T=TreeNew; return 0; } //\u7528\u6765\u904d\u5386\u6811 BiTree p=T,parent; while (p) { parent=p; if (k>p->Key) { p=p->rchild; } else if (k<p->Key) { p=p->lchild; } else{ //\u76f8\u7b49\u7684\u5143\u7d20\u4e0d\u653e\u5165\u67e5\u627e\u6811\uff0c\u8fd4\u56de-1 return -1; } } if (k>parent->Key) { parent->rchild=TreeNew; } else{ parent->lchild=TreeNew; } return 0; } int RecurveBST_Insert(BiTree &T,KeyType k) { if (NULL==T) { T=(BiTree) malloc(sizeof (BSTNode)); T->Key=k; T->lchild=T->rchild=NULL; return 1; } else if(k==T->Key) { return 0; } else if (k<T->Key) { return BST_Insert(T->lchild,k); } else{ return BST_Insert(T->rchild,k); } } void Creat_BST(BiTree &T, KeyType *str, int len) { int i; for (i = 0; i < len; i++) { BST_Insert(T, str[i]); // RecurveBST_Insert(T,str[i]); } } void InOrder(BiTree T) { if (T!=NULL) { InOrder(T->lchild); printf(\"%3d\",T->Key); InOrder(T->rchild); } } BiTree BST_Search(BiTree T,KeyType k,BiTree &parent) { parent=NULL; while (T!=NULL && k!=T->Key) { parent=T; if (k>T->Key) { T=T->rchild; } else{ T=T->lchild; } } return T; } void DeleteNode(BiTree &root,KeyType x) { if (NULL==root) { return; } if (root->Key>x) { DeleteNode(root->lchild,x); } else if (root->Key<x) { DeleteNode(root->rchild,x); } else{ //\u627e\u5230\u4e86\u8981\u5220\u9664\u7684\u8282\u70b9 if (root->lchild==NULL) { BiTree tmpNode=root; root=root->rchild; free(tmpNode); } else if (root->rchild==NULL) { BiTree tmpNode=root; root=root->lchild; free(tmpNode); }else{ //\u5de6\u53f3\u5b50\u6811\u90fd\u4e0d\u4e3a\u7a7a BiTree tmpNode=root->lchild; while (tmpNode->rchild!=NULL) { tmpNode=tmpNode->rchild; } root->Key=tmpNode->Key; DeleteNode(root->lchild,tmpNode->Key); } } } int main() { BiTree T = NULL; KeyType str[7] = {54, 20, 66, 40, 28, 79, 58}; Creat_BST(T, str, 7); InOrder(T); printf(\"\\n\"); BiTree res,parent; res=BST_Search(T,40,parent); if (res) { printf(\"find res->%d\\n\",res->Key); } else{ printf(\"not find\\n\"); } printf(\"\u5220\u9664\u7ed3\u70b928\\n\"); DeleteNode(T,28); InOrder(T); return 1; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/search/BinarySearchTree/cmake-build-debug/BinarySearchTree 20 28 40 54 58 66 79 find res->40 \u5220\u9664\u7ed3\u70b928 20 40 54 58 66 79 Process finished with exit code 1 4.BST-2014-42 42.(15\u5206) \u4e00\u4e2a\u957f\u5ea6\u4e3aL(L>=1)\u7684\u751f\u5e8f\u5e8f\u5217S\uff0c\u5904\u5728\u7b2c[L/2]\u4e2a\u4f4d\u7f6e\u7684\u6570\u79f0\u4e3aS\u7684\u4e2d\u4f4d\u6570\u3002 \u4f8b\u5982\uff1a\u82e5\u5e8f\u5217S1=(11,13,15,17,19)\uff0c\u5219S1\u7684\u4e2d\u4f4d\u6570\u662f15\uff0c \u4e24\u4e2a\u5e8f\u5217\u7684\u4e2d\u4f4d\u6570\u662f\u542b\u6709\u5b83\u4eec\u6240\u6709\u5143\u7d20\u7684\u5347\u5e8f\u5e8f\u5217\u7684\u4e2d\u4f4d\u6570\u3002 \u4f8b\u5982\uff1a\u82e5S2=(2,4,6,8,20)\uff0c\u5219S1\u548cS2\u7684\u4e2d\u4f4d\u6570\u662f11. \u73b0\u5728\u6709\u4e24\u4e2a\u7b49\u957f\u5347\u5e8f\u5e8f\u5217A\u548cB\uff0c\u8bd5\u8bbe\u8ba1\u4e00\u4e2a\u5728\u65f6\u95f4\u548c\u7a7a\u95f4\u4e24\u65b9\u9762\u90fd\u5c3d\u53ef\u80fd\u9ad8\u6548\u7684\u7b97\u6cd5\uff0c \u627e\u51fa\u4e24\u4e2a\u5e8f\u5217A\u548cB\u7684\u4e2d\u4f4d\u6570\u3002\u8981\u6c42\uff1a \u7ed9\u51fa\u7b97\u6cd5\u7684\u57fa\u672c\u8bbe\u8ba1\u601d\u60f3 \u6839\u636e\u8bbe\u8ba1\u601d\u60f3\uff0c\u91c7\u7528C/C++\u8bed\u8a00\u63cf\u8ff0\u7b97\u6cd5 \u8bf4\u660e\u65f6\u95f4\u590d\u6742\u5ea6\u4ee5\u53ca\u7a7a\u95f4\u590d\u6742\u5ea6 \u89e3\u6790\uff1a \u8003\u5bdf\u5185\u5bb9\u4e3a\u53cc\u6570\u7ec4\u7684\u4e8c\u5206\u67e5\u627e\u3002 1.\u7b97\u6cd5\u7684\u8bbe\u8ba1\u601d\u60f3\uff1a 1\uff09\u82e5a=b\uff0c\u5219a\u6216b\u5373\u4e3a\u6240\u6c42\u4e2d\u4f4d\u6570\uff0c\u7b97\u6cd5\u7ed3\u675f\u3002 2\uff09\u82e5 ab\uff0c\u5219\u820d\u5f03\u5e8f\u5217 A \u4e2d\u8f83\u5c0f\u7684\u4e00\u534a\uff0c\u540c\u65f6\u820d\u5f03\u5e8f\u5217 B \u4e2d\u8f83\u5927\u7684\u4e00\u534a\uff0c\u8981\u6c42\u820d\u5f03\u7684 \u957f\u5ea6\u76f8\u7b49\uff1b 3\uff09\u82e5 ab\uff0c\u5219\u820d\u5f03\u5e8f\u5217 A \u4e2d\u8f83\u5927\u7684\u4e00\u534a\uff0c\u540c\u65f6\u820d\u5f03\u5e8f\u5217 B\u4e2d\u8f83\u5c0f\u7684\u4e00\u534a\uff0c\u8981\u6c42\u820d\u5f03 \u7684\u957f\u5ea6\u76f8\u7b49\uff1b \u5728\u4fdd\u7559\u7684\u4e24\u4e2a\u5347\u5e8f\u5e8f\u5217\u4e2d\uff0c\u91cd\u590d\u8fc7\u7a0b 1\uff09\u30012\uff09\u30013\uff09\uff0c\u76f4\u5230\u4e24\u4e2a\u5e8f\u5217\u4e2d\u5747\u53ea\u542b\u4e00\u4e2a\u5143\u7d20 \u65f6\u4e3a \u6b62\uff0c\u8f83\u5c0f\u8005\u5373\u4e3a\u6240\u6c42\u7684\u4e2d\u4f4d\u6570\u3002 2. \u7b97\u6cd5\u63cf\u8ff0 int MidSearch(int* A,int* B,int n) { //\u5206\u522b\u8868\u793a\u5e8f\u5217 A \u548c B \u7684\u9996\u4f4d\u6570\u3001\u672b\u4f4d\u6570\u548c\u4e2d\u4f4d\u6570\uff0cs\u662fstart\u7b80\u5199\uff0cd\u662fend\u7b80\u5199 int s1 = 0, d1 = n - 1, m1, s2 = 0, d2 = n - 1, m2; //\u5faa\u73af\u5224\u65ad\u7ed3\u675f\u6761\u4ef6\u662f\uff0c\u4e24\u4e2a\u6570\u7ec4\u5747\u4e0d\u65ad\u5220\u9664\u6700\u540e\u5747\u53ea\u80fd\u5269\u4f59\u4e00\u4e2a\u5143\u7d20 while(s1!=d1||s2!=d2) { m1 = (s1 + d1) / 2; m2 = (s2 + d2) / 2; if(A[m1]==B[m2]) { return A[m1];//\u6ee1\u8db3\u6761\u4ef6 1 }else if(A[m1]<B[m2])//\u6ee1\u8db3\u6761\u4ef62 { if((s1 + d1) % 2 == 0) { //\u82e5\u5143\u7d20\u4e2a\u6570\u4e3a\u5947\u6570,\u8fd9\u91cc\u6ce8\u610f\u6570\u7ec4\u4e0b\u6807\u4ece0\u5f00\u59cb s1=m1;//\u820d\u5f03 A \u4e2d\u95f4\u70b9\u4ee5\u524d\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 d2=m2;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u4ee5\u540e\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 }else{//\u5143\u7d20\u4e2a\u6570\u4e3a\u5076\u6570 s1=m1+1;//\u820d\u5f03 A \u4e2d\u95f4\u70b9\u53ca\u4e2d\u95f4\u70b9\u4ee5\u524d\u90e8\u5206 d2=m2;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u4ee5\u540e\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 } }else{//\u6ee1\u8db3\u6761\u4ef6 3\uff09\uff0c\u4e0b\u9762\u7684\u64cd\u4f5c\u548c\u4e0a\u9762\u6761\u4ef62\u662f\u5b8c\u5168\u5bf9\u79f0\u7684 if ((s1 + d1) % 2 == 0) { //\u82e5\u5143\u7d20\u4e2a\u6570\u4e3a\u5947\u6570 d1=m1;//\u820d\u5f03 A \u4e2d\u95f4\u70b9\u4ee5\u540e\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 s2=m2;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u4ee5\u524d\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 }else{//\u5143\u7d20\u4e2a\u6570\u4e3a\u5076\u6570 d1=m1; //\u820d\u5f03 A \u4e2d\u95f4\u70b9\u4ee5\u540e\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 s2=m2+1;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u53ca\u4e2d\u95f4\u70b9\u4ee5\u524d\u90e8\u5206 } } } return A[s1] < B[s2] ? A[s1] : B[s2];//\u56e0\u4e3a\u9898\u76ee\u8981\u7684\u662f11\uff0c\u56e0\u6b64\u6211\u4eec\u62ff\u5c0f\u7684\u90a3\u4e2a } #include <stdio.h> #include <stdlib.h> int main() { int A[] = {11, 13, 15, 17, 19}; int B[] = {2, 4, 6, 8, 20}; int mid = MidSearch(A, B, 5); printf(\"mid=%d\\n\", mid); return 0; } 3.\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(log2n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(1) \u56e0\u4e3a\u6ca1\u6709\u4f7f\u7528\u989d\u5916\u7684\u8ddf n \u76f8\u5173\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(1)\uff0c \u56e0\u4e3a\u4e0d\u65ad\u7684\u4e8c\u5206\uff0c\u6b21\u6570\u662f log2n\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(log2n)\u3002","title":"7.\u67e5\u627e"},{"location":"DataStruct/search/search/#_1","text":"","title":"\u67e5\u627e\u7b97\u6cd5"},{"location":"DataStruct/search/search/#1","text":"\u987a\u5e8f\u67e5\u627e\u53c8\u79f0\u4e3a\u7ebf\u6027\u67e5\u627e\uff0c\u5bf9\u4e8e\u987a\u5e8f\u8868\u548c\u94fe\u8868\u90fd\u9002\u7528\u3002 \u8fd9\u91cc\u7684\u987a\u5e8f\u67e5\u627e\u9002\u7528\u7684 \u54e8\u5175\uff1a \u5c06\u8981\u67e5\u627e\u7684\u6570\u7ec4\u7684\u7b2c0\u4e2a\u4f4d\u7f6e\u7559\u7ed9\u54e8\u5175\uff0c\u4ece\u540e\u5411\u524d\u5faa\u73af\uff0c\u53ef\u4ee5\u66f4\u52a0\u7b80\u6d01 ElemType ST_Search(SSTable ST, ElemType key) { ST.elem[0] = key; int i; for (i = ST.TableLen-1; ST.elem[i] != ST.elem[0] ;i--) { } return i; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> typedef int ElemType; typedef struct SSTable{ ElemType *elem; int TableLen; }; void ST_Init(SSTable &ST,int length) { ST.TableLen = length + 1; ST.elem = (ElemType*) malloc(sizeof (SSTable) * ST.TableLen); int i; srand(time(NULL)); for (i=1;i<ST.TableLen;i++) { ST.elem[i] = rand() % 100; } } void ST_Print(SSTable ST) { for (int i = 1; i < ST.TableLen; ++i) { printf(\"%3d\",ST.elem[i]); } printf(\"\\n\"); } ElemType ST_Search(SSTable ST, ElemType key) { ST.elem[0] = key; int i; for (i = ST.TableLen-1; ST.elem[i] != ST.elem[0] ;i--) { } return i; } int main() { SSTable ST; ST_Init(ST,15); ST_Print(ST); ElemType res; ElemType key; scanf(\"%d\",&key); res= ST_Search(ST,key); if (res) { printf(\"search_res->%d\\n\",res); } else{ printf(\"not find\\n\"); } return 0; }","title":"1.\u987a\u5e8f\u67e5\u627e"},{"location":"DataStruct/search/search/#2","text":"\u4e8c\u5206\u67e5\u627e\u6f14\u793a\ud83c\udf88 \u4e8c\u5206\u67e5\u627e\u4e5f\u53eb\u6298\u534a\u67e5\u627e \uff0c\u5b83\u4ec5\u4ec5\u662f\u7528\u4e8e \u6709\u5e8f\u7684\u987a\u5e8f\u8868 \u4e8c\u5206\u67e5\u627e\u7684\u57fa\u672c\u601d\u60f3\uff1a \u5c06\u7ed9\u5b9a\u7684key\u4e0e\u8868\u4e2d\u95f4\u4f4d\u7f6e\u7684\u5143\u7d20\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u540c->\u67e5\u627e\u6210\u529f \u5982\u679c\u4e0d\u540c\uff0c\u5728\u4e2d\u95f4\u5143\u7d20\u7684\u524d\u534a\u6bb5\u6216\u540e\u534a\u6bb5\u5206\u522b\u8fdb\u884c\u7b2c\u4e00\u6b65\u7684\u64cd\u4f5c\uff0c\u76f4\u5230\u67e5\u627e\u6210\u529f \u5982\u679c\u5b9e\u5728\u6ca1\u6709\u627e\u5230\u5143\u7d20\uff0c\u5219\u67e5\u627e\u4e0d\u6210\u529f \u6f14\u793a\u7684\u8fc7\u7a0b\uff1a \u521d\u59cb\u5316\u987a\u5e8f\u8868\uff0c\u653e\u516510\u4e2a\u5143\u7d20 \u9002\u7528qsort\u63a5\u53e3\u8fdb\u884c\u6392\u5e8f\uff0c\u5e76\u6253\u5370 \u8fdb\u884c\u67e5\u627e \u4e8c\u5206\u67e5\u627e\u4ee3\u7801\uff1a ElemType BinarySearch(SSTable L,ElemType key) { int low=0; int high=L.TableLen-1; int mid; while (low<=high) { mid=(low+high)/2; if(key>L.elem[mid]) { low=mid+1; } else if(key<L.elem[mid]) { high=mid-1; } else{ return mid; } } return -1; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> typedef int ElemType; typedef struct SSTable{ ElemType *elem; int TableLen; }; void ST_Init(SSTable &ST,int length) { ST.TableLen = length; ST.elem = (ElemType*) malloc(sizeof (SSTable) * ST.TableLen); int i; srand(time(NULL)); for (i=0;i<ST.TableLen;i++) { ST.elem[i] = rand() % 100; } } void ST_Print(SSTable ST) { for (int i = 0; i < ST.TableLen; ++i) { printf(\"%3d\",ST.elem[i]); } printf(\"\\n\"); } ElemType BinarySearch(SSTable L,ElemType key) { int low=0; int high=L.TableLen-1; int mid; while (low<=high) { mid=(low+high)/2; if(key>L.elem[mid]) { low=mid+1; } else if(key<L.elem[mid]) { high=mid-1; } else{ return mid; } } return -1; } //\u51fd\u6570\u540d\u4e2d\u5b58\u7684\u662f\u51fd\u6570\u7684\u5165\u53e3\u5730\u5740\uff0c\u4e5f\u662f\u4e00\u4e2a\u6307\u9488\uff08\u51fd\u6570\u6307\u9488\uff09 //qsort\u89c4\u5b9a\u5982\u679cleft\u6307\u9488\u6307\u5411\u7684\u503c\u5927\u4e8eright\u6307\u9488\u6307\u5411\u7684\u503c\uff0c\u8fd4\u56de\u6b63\u503c\uff0c\u5426\u5219\u8fd4\u56de\u8d1f int compare(const void *left,const void *right) { return *(int*)left-*(int*)right; } int main() { SSTable ST; ST_Init(ST,10); ST_Print(ST); qsort(ST.elem,ST.TableLen,sizeof (ElemType),compare); ST_Print(ST); ElemType key; printf(\"please input search key:\\n\"); scanf(\"%d\",&key); int res; res = BinarySearch(ST,key); if (res!=-1) { printf(\"search res->%d\\n\",res); } else{ printf(\"not find\\n\"); } return 0; } qsort\u63a5\u53e3 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) base --\u6307\u5411\u8981\u6392\u5e8f\u6570\u7ec4\u7684\u6307\u9488 nitems --\u6570\u7ec4\u4e2d\u5143\u7d20\u7684\u4e2a\u6570 size -- \u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5927\u5c0f (sizeof(int)) compar -- \u6bd4\u8f83\u4e24\u4e2a\u5143\u7d20\u7684\u51fd\u6570\uff0c\u8fd4\u56de\u503c\u5fc5\u987b\u662f\u6307\u5b9a\u7c7b\u578b(\u8fd9\u91cc\u662fint) qsort\u89c4\u5b9a\u5982\u679cleft\u6307\u9488\u6307\u5411\u7684\u503c\u5927\u4e8eright\u6307\u9488\u6307\u5411\u7684\u503c\uff0c\u8fd4\u56de\u6b63\u503c\uff0c\u5426\u5219\u8fd4\u56de\u8d1f\uff0c\u76f8\u7b49\u8fd4\u56de0 qsort\u63a5\u53e3\u7684\u4f8b\u5b50\uff1a #include <stdio.h> #include <stdlib.h> int values[] = { 88, 56, 100, 2, 25 }; int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int main() { int n; printf(\"\u6392\u5e8f\u4e4b\u524d\u7684\u5217\u8868\uff1a\\n\"); for( n = 0 ; n < 5; n++ ) { printf(\"%d \", values[n]); } qsort(values, 5, sizeof(int), cmpfunc); printf(\"\\n\u6392\u5e8f\u4e4b\u540e\u7684\u5217\u8868\uff1a\\n\"); for( n = 0 ; n < 5; n++ ) { printf(\"%d \", values[n]); } return(0); } \u8fd0\u884c\u7ed3\u679c\uff1a \u6392\u5e8f\u4e4b\u524d\u7684\u5217\u8868\uff1a 88 56 100 2 25 \u6392\u5e8f\u4e4b\u540e\u7684\u5217\u8868\uff1a 2 25 56 88 100","title":"2.\u4e8c\u5206\u67e5\u627e"},{"location":"DataStruct/search/search/#3","text":"\u4e8c\u53c9\u6392\u5e8f\u6811\u6f14\u793a\ud83c\udf88 \u4e8c\u53c9\u67e5\u627e\u6811\u4e5f\u53eb\u4e8c\u53c9\u6392\u5e8f\u6811\uff0c\u6216\u8005\u662f\u4e00\u68f5\u7a7a\u6811\u3002 \u5177\u6709\u4ee5\u4e0b\u7684\u7279\u6027\uff1a \u5982\u679c\u5de6\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u5de6\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5c0f\u4e8e\u6839\u7ed3\u70b9 \u5982\u679c\u53f3\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u53f3\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5927\u4e8e\u6839\u7ed3\u70b9 \u5de6\u53f3\u5b50\u6811\u4e5f\u5206\u522b\u662f\u4e00\u68f5\u4e8c\u53c9\u6392\u5e8f\u6811 \u770b\u4efb\u4f55\u4e00\u4e2a\u6700\u5c0f\u5355\u5143\u7684\u6811\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u5de6\u5b69\u5b50\u7ed3\u70b9\u5c0f\u4e8e\u6839\u8282\u70b9\uff0c\u53f3\u5b69\u5b50\u7ed3\u70b9\u5927\u4e8e\u6839\u7ed3\u70b9 \u4f8b\u5982\uff1a \u4f7f\u7528\u4e8c\u53c9\u67e5\u627e\u6811\u67e5\u627e\u5143\u7d20\uff0c\u67e5\u627e\u7684\u6700\u591a\u6b21\u6570\u5c31\u662f\u6811\u7684\u9ad8\u5ea6\u3002 \u4e2d\u5e8f\u904d\u5386\u4e8c\u53c9\u67e5\u627e\u6811\uff0c\u5f97\u5230\u7684\u662f\u4ece\u5c0f\u5230\u5927\u7684\u7ed3\u679c","title":"3.\u4e8c\u53c9\u67e5\u627e\u6811"},{"location":"DataStruct/search/search/#1_1","text":"parent\u8282\u70b9\u7528\u6765\u6307\u793a\u8981\u63d2\u5165\u7684\u4f4d\u7f6e\u7684\u7236\u4eb2\u8282\u70b9 \u5f53\u627e\u5230\u4e3aNULL\u7684p\u8282\u70b9\u65f6\uff0c\u8df3\u51fa\u5faa\u73af void Creat_BST(BiTree &T, KeyType *str, int len) { int i; for (i = 0; i < len; i++) { BST_Insert(T, str[i]); } } int BST_Insert(BiTree &T, KeyType k) { BiTree TreeNew = (BiTree) calloc(1, sizeof(BSTNode)); TreeNew->Key=k; if (NULL==T) { T=TreeNew; return 0; } //\u7528\u6765\u904d\u5386\u6811 BiTree p=T,parent; while (p) { parent=p; if (k>p->Key) { p=p->rchild; } else if (k<p->Key) { p=p->lchild; } else{ //\u76f8\u7b49\u7684\u5143\u7d20\u4e0d\u653e\u5165\u67e5\u627e\u6811\uff0c\u8fd4\u56de-1 return -1; } } if (k>parent->Key) { parent->rchild=TreeNew; } else{ parent->lchild=TreeNew; } return 0; }","title":"1.\u975e\u9012\u5f52\u5efa\u7acb\u4e8c\u53c9\u67e5\u627e\u6811"},{"location":"DataStruct/search/search/#2_1","text":"int RecurveBST_Insert(BiTree &T,KeyType k) { if (NULL==T) { T=(BiTree) malloc(sizeof (BSTNode)); T->Key=k; T->lchild=T->rchild=NULL; return 1; } else if(k==T->Key) { return 0; } else if (k<T->Key) { return BST_Insert(T->lchild,k); } else{ return BST_Insert(T->rchild,k); } } \u51fd\u6570int RecurveBST_Insert(BiTree &T,KeyType k)\u4f20\u5165\u5f15\u7528\u7c7b\u578b \u5728\u9012\u5f52\u8fc7\u7a0b\u4e2d\uff0c\u9012\u5f52\u65f6\u4f20\u5165\u7684\u53c2\u6570\u4f9d\u7136\u662f\u5f15\u7528\u7c7b\u578b","title":"2.\u9012\u5f52\u5efa\u7acb\u4e8c\u53c9\u67e5\u627e\u6811"},{"location":"DataStruct/search/search/#3_1","text":"BiTree BST_Search(BiTree T,KeyType k,BiTree &parent) { parent=NULL; while (T!=NULL && k!=T->Key) { parent=T; if (k>T->Key) { T=T->rchild; } else{ T=T->lchild; } } return T; } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include \"stdlib.h\" //\u4e8c\u53c9\u6392\u5e8f\u6811 typedef int KeyType; typedef struct BSTNode { KeyType Key; struct BSTNode *lchild, *rchild; } BSTNode, *BiTree; //\u975e\u9012\u5f52\u521b\u5efa\u4e8c\u53c9\u67e5\u627e\u6811 int BST_Insert(BiTree &T, KeyType k) { BiTree TreeNew = (BiTree) calloc(1, sizeof(BSTNode)); TreeNew->Key=k; if (NULL==T) { T=TreeNew; return 0; } //\u7528\u6765\u904d\u5386\u6811 BiTree p=T,parent; while (p) { parent=p; if (k>p->Key) { p=p->rchild; } else if (k<p->Key) { p=p->lchild; } else{ //\u76f8\u7b49\u7684\u5143\u7d20\u4e0d\u653e\u5165\u67e5\u627e\u6811\uff0c\u8fd4\u56de-1 return -1; } } if (k>parent->Key) { parent->rchild=TreeNew; } else{ parent->lchild=TreeNew; } return 0; } void Creat_BST(BiTree &T, KeyType *str, int len) { int i; for (i = 0; i < len; i++) { BST_Insert(T, str[i]); } } void InOrder(BiTree T) { if (T!=NULL) { InOrder(T->lchild); printf(\"%3d\",T->Key); InOrder(T->rchild); } } BiTree BST_Search(BiTree T,KeyType k,BiTree &parent) { parent=NULL; while (T!=NULL && k!=T->Key) { parent=T; if (k>T->Key) { T=T->rchild; } else{ T=T->lchild; } } return T; } int RecurveBST_Insert(BiTree &T,KeyType k) { if (NULL==T) { T=(BiTree) malloc(sizeof (BSTNode)); T->Key=k; T->lchild=T->rchild=NULL; return 1; } else if(k==T->Key) { return 0; } else if (k<T->Key) { return BST_Insert(T->lchild,k); } else{ return BST_Insert(T->rchild,k); } } int main() { BiTree T = NULL; KeyType str[7] = {54, 20, 66, 40, 28, 79, 58}; Creat_BST(T, str, 7); InOrder(T); printf(\"\\n\"); BiTree res,parent; res=BST_Search(T,40,parent); if (res) { printf(\"find res->%d\\n\",res->Key); } else{ printf(\"not find\\n\"); } return 1; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/search/BinarySearchTree/cmake-build-debug/BinarySearchTree 20 28 40 54 58 66 79 find res->40","title":"3.\u4f7f\u7528\u4e8c\u53c9\u67e5\u627e\u6811\u67e5\u627e"},{"location":"DataStruct/search/search/#4","text":"\u903b\u8f91\u8fc7\u7a0b\uff1a \u9996\u5148\u5b9a\u4f4d\u5230\u8981\u5220\u9664\u7684\u7ed3\u70b9\uff0c\u6839\u7ed3\u70b9\u5982\u679c\u5927\u4e8e\u8981\u5220\u9664\u7684\u5143\u7d20\uff0c\u8d70\u5de6\u5b50\u6811\uff0c\u5426\u5219\u8d70\u53f3\u5b50\u6811 \u5224\u65ad\u8981\u5220\u9664\u7684\u7ed3\u70b9\u7684\u5b50\u7ed3\u70b9\u662f\u5426\u4e3a\u7a7a \u5982\u679c\u5de6\u7ed3\u70b9\u4e3a\u7a7a\uff08\u5de6\u53f3\u7ed3\u70b9\u90fd\u4e3a\u7a7a\uff09\uff0c\u5c06\u5220\u9664\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u6307\u5411\u53f3\u5b69\u5b50\u8282\u70b9 \u5982\u679c\u53f3\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u5c06\u5220\u9664\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u6307\u5411\u5de6\u5b69\u5b50\u8282\u70b9 \u5982\u679c\u5de6\u53f3\u5b69\u5b50\u8282\u70b9\u90fd\u4e0d\u4e3a\u7a7a \u627e\u5de6\u5b50\u6811\u7684\u6700\u53f3\u5b69\u5b50\u8282\u70b9\u653e\u5728\u8981\u5220\u9664\u5143\u7d20\u7684\u4f4d\u7f6e \u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u6811\u8fd8\u662f\u4e00\u68f5\u4e8c\u53c9\u67e5\u627e\u6811 void DeleteNode(BiTree &root,KeyType x) { if (NULL==root) { return; } if (root->Key>x) { DeleteNode(root->lchild,x); } else if (root->Key<x) { DeleteNode(root->rchild,x); } else{ //\u627e\u5230\u4e86\u8981\u5220\u9664\u7684\u8282\u70b9 if (root->lchild==NULL) { BiTree tmpNode=root; root=root->rchild; free(tmpNode); } else if (root->rchild==NULL) { BiTree tmpNode=root; root=root->lchild; free(tmpNode); }else{ //\u5de6\u53f3\u5b50\u6811\u90fd\u4e0d\u4e3a\u7a7a BiTree tmpNode=root->lchild; while (tmpNode->rchild!=NULL) { tmpNode=tmpNode->rchild; } root->Key=tmpNode->Key; DeleteNode(root->lchild,tmpNode->Key); } } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include \"stdlib.h\" //\u4e8c\u53c9\u6392\u5e8f\u6811 typedef int KeyType; typedef struct BSTNode { KeyType Key; struct BSTNode *lchild, *rchild; } BSTNode, *BiTree; //\u975e\u9012\u5f52\u521b\u5efa\u4e8c\u53c9\u67e5\u627e\u6811 int BST_Insert(BiTree &T, KeyType k) { BiTree TreeNew = (BiTree) calloc(1, sizeof(BSTNode)); TreeNew->Key=k; if (NULL==T) { T=TreeNew; return 0; } //\u7528\u6765\u904d\u5386\u6811 BiTree p=T,parent; while (p) { parent=p; if (k>p->Key) { p=p->rchild; } else if (k<p->Key) { p=p->lchild; } else{ //\u76f8\u7b49\u7684\u5143\u7d20\u4e0d\u653e\u5165\u67e5\u627e\u6811\uff0c\u8fd4\u56de-1 return -1; } } if (k>parent->Key) { parent->rchild=TreeNew; } else{ parent->lchild=TreeNew; } return 0; } int RecurveBST_Insert(BiTree &T,KeyType k) { if (NULL==T) { T=(BiTree) malloc(sizeof (BSTNode)); T->Key=k; T->lchild=T->rchild=NULL; return 1; } else if(k==T->Key) { return 0; } else if (k<T->Key) { return BST_Insert(T->lchild,k); } else{ return BST_Insert(T->rchild,k); } } void Creat_BST(BiTree &T, KeyType *str, int len) { int i; for (i = 0; i < len; i++) { BST_Insert(T, str[i]); // RecurveBST_Insert(T,str[i]); } } void InOrder(BiTree T) { if (T!=NULL) { InOrder(T->lchild); printf(\"%3d\",T->Key); InOrder(T->rchild); } } BiTree BST_Search(BiTree T,KeyType k,BiTree &parent) { parent=NULL; while (T!=NULL && k!=T->Key) { parent=T; if (k>T->Key) { T=T->rchild; } else{ T=T->lchild; } } return T; } void DeleteNode(BiTree &root,KeyType x) { if (NULL==root) { return; } if (root->Key>x) { DeleteNode(root->lchild,x); } else if (root->Key<x) { DeleteNode(root->rchild,x); } else{ //\u627e\u5230\u4e86\u8981\u5220\u9664\u7684\u8282\u70b9 if (root->lchild==NULL) { BiTree tmpNode=root; root=root->rchild; free(tmpNode); } else if (root->rchild==NULL) { BiTree tmpNode=root; root=root->lchild; free(tmpNode); }else{ //\u5de6\u53f3\u5b50\u6811\u90fd\u4e0d\u4e3a\u7a7a BiTree tmpNode=root->lchild; while (tmpNode->rchild!=NULL) { tmpNode=tmpNode->rchild; } root->Key=tmpNode->Key; DeleteNode(root->lchild,tmpNode->Key); } } } int main() { BiTree T = NULL; KeyType str[7] = {54, 20, 66, 40, 28, 79, 58}; Creat_BST(T, str, 7); InOrder(T); printf(\"\\n\"); BiTree res,parent; res=BST_Search(T,40,parent); if (res) { printf(\"find res->%d\\n\",res->Key); } else{ printf(\"not find\\n\"); } printf(\"\u5220\u9664\u7ed3\u70b928\\n\"); DeleteNode(T,28); InOrder(T); return 1; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/search/BinarySearchTree/cmake-build-debug/BinarySearchTree 20 28 40 54 58 66 79 find res->40 \u5220\u9664\u7ed3\u70b928 20 40 54 58 66 79 Process finished with exit code 1","title":"4.\u4e8c\u53c9\u67e5\u627e\u6811\u5220\u9664\u5143\u7d20"},{"location":"DataStruct/search/search/#4bst-2014-42","text":"42.(15\u5206) \u4e00\u4e2a\u957f\u5ea6\u4e3aL(L>=1)\u7684\u751f\u5e8f\u5e8f\u5217S\uff0c\u5904\u5728\u7b2c[L/2]\u4e2a\u4f4d\u7f6e\u7684\u6570\u79f0\u4e3aS\u7684\u4e2d\u4f4d\u6570\u3002 \u4f8b\u5982\uff1a\u82e5\u5e8f\u5217S1=(11,13,15,17,19)\uff0c\u5219S1\u7684\u4e2d\u4f4d\u6570\u662f15\uff0c \u4e24\u4e2a\u5e8f\u5217\u7684\u4e2d\u4f4d\u6570\u662f\u542b\u6709\u5b83\u4eec\u6240\u6709\u5143\u7d20\u7684\u5347\u5e8f\u5e8f\u5217\u7684\u4e2d\u4f4d\u6570\u3002 \u4f8b\u5982\uff1a\u82e5S2=(2,4,6,8,20)\uff0c\u5219S1\u548cS2\u7684\u4e2d\u4f4d\u6570\u662f11. \u73b0\u5728\u6709\u4e24\u4e2a\u7b49\u957f\u5347\u5e8f\u5e8f\u5217A\u548cB\uff0c\u8bd5\u8bbe\u8ba1\u4e00\u4e2a\u5728\u65f6\u95f4\u548c\u7a7a\u95f4\u4e24\u65b9\u9762\u90fd\u5c3d\u53ef\u80fd\u9ad8\u6548\u7684\u7b97\u6cd5\uff0c \u627e\u51fa\u4e24\u4e2a\u5e8f\u5217A\u548cB\u7684\u4e2d\u4f4d\u6570\u3002\u8981\u6c42\uff1a \u7ed9\u51fa\u7b97\u6cd5\u7684\u57fa\u672c\u8bbe\u8ba1\u601d\u60f3 \u6839\u636e\u8bbe\u8ba1\u601d\u60f3\uff0c\u91c7\u7528C/C++\u8bed\u8a00\u63cf\u8ff0\u7b97\u6cd5 \u8bf4\u660e\u65f6\u95f4\u590d\u6742\u5ea6\u4ee5\u53ca\u7a7a\u95f4\u590d\u6742\u5ea6 \u89e3\u6790\uff1a \u8003\u5bdf\u5185\u5bb9\u4e3a\u53cc\u6570\u7ec4\u7684\u4e8c\u5206\u67e5\u627e\u3002 1.\u7b97\u6cd5\u7684\u8bbe\u8ba1\u601d\u60f3\uff1a 1\uff09\u82e5a=b\uff0c\u5219a\u6216b\u5373\u4e3a\u6240\u6c42\u4e2d\u4f4d\u6570\uff0c\u7b97\u6cd5\u7ed3\u675f\u3002 2\uff09\u82e5 ab\uff0c\u5219\u820d\u5f03\u5e8f\u5217 A \u4e2d\u8f83\u5c0f\u7684\u4e00\u534a\uff0c\u540c\u65f6\u820d\u5f03\u5e8f\u5217 B \u4e2d\u8f83\u5927\u7684\u4e00\u534a\uff0c\u8981\u6c42\u820d\u5f03\u7684 \u957f\u5ea6\u76f8\u7b49\uff1b 3\uff09\u82e5 ab\uff0c\u5219\u820d\u5f03\u5e8f\u5217 A \u4e2d\u8f83\u5927\u7684\u4e00\u534a\uff0c\u540c\u65f6\u820d\u5f03\u5e8f\u5217 B\u4e2d\u8f83\u5c0f\u7684\u4e00\u534a\uff0c\u8981\u6c42\u820d\u5f03 \u7684\u957f\u5ea6\u76f8\u7b49\uff1b \u5728\u4fdd\u7559\u7684\u4e24\u4e2a\u5347\u5e8f\u5e8f\u5217\u4e2d\uff0c\u91cd\u590d\u8fc7\u7a0b 1\uff09\u30012\uff09\u30013\uff09\uff0c\u76f4\u5230\u4e24\u4e2a\u5e8f\u5217\u4e2d\u5747\u53ea\u542b\u4e00\u4e2a\u5143\u7d20 \u65f6\u4e3a \u6b62\uff0c\u8f83\u5c0f\u8005\u5373\u4e3a\u6240\u6c42\u7684\u4e2d\u4f4d\u6570\u3002 2. \u7b97\u6cd5\u63cf\u8ff0 int MidSearch(int* A,int* B,int n) { //\u5206\u522b\u8868\u793a\u5e8f\u5217 A \u548c B \u7684\u9996\u4f4d\u6570\u3001\u672b\u4f4d\u6570\u548c\u4e2d\u4f4d\u6570\uff0cs\u662fstart\u7b80\u5199\uff0cd\u662fend\u7b80\u5199 int s1 = 0, d1 = n - 1, m1, s2 = 0, d2 = n - 1, m2; //\u5faa\u73af\u5224\u65ad\u7ed3\u675f\u6761\u4ef6\u662f\uff0c\u4e24\u4e2a\u6570\u7ec4\u5747\u4e0d\u65ad\u5220\u9664\u6700\u540e\u5747\u53ea\u80fd\u5269\u4f59\u4e00\u4e2a\u5143\u7d20 while(s1!=d1||s2!=d2) { m1 = (s1 + d1) / 2; m2 = (s2 + d2) / 2; if(A[m1]==B[m2]) { return A[m1];//\u6ee1\u8db3\u6761\u4ef6 1 }else if(A[m1]<B[m2])//\u6ee1\u8db3\u6761\u4ef62 { if((s1 + d1) % 2 == 0) { //\u82e5\u5143\u7d20\u4e2a\u6570\u4e3a\u5947\u6570,\u8fd9\u91cc\u6ce8\u610f\u6570\u7ec4\u4e0b\u6807\u4ece0\u5f00\u59cb s1=m1;//\u820d\u5f03 A \u4e2d\u95f4\u70b9\u4ee5\u524d\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 d2=m2;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u4ee5\u540e\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 }else{//\u5143\u7d20\u4e2a\u6570\u4e3a\u5076\u6570 s1=m1+1;//\u820d\u5f03 A \u4e2d\u95f4\u70b9\u53ca\u4e2d\u95f4\u70b9\u4ee5\u524d\u90e8\u5206 d2=m2;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u4ee5\u540e\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 } }else{//\u6ee1\u8db3\u6761\u4ef6 3\uff09\uff0c\u4e0b\u9762\u7684\u64cd\u4f5c\u548c\u4e0a\u9762\u6761\u4ef62\u662f\u5b8c\u5168\u5bf9\u79f0\u7684 if ((s1 + d1) % 2 == 0) { //\u82e5\u5143\u7d20\u4e2a\u6570\u4e3a\u5947\u6570 d1=m1;//\u820d\u5f03 A \u4e2d\u95f4\u70b9\u4ee5\u540e\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 s2=m2;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u4ee5\u524d\u7684\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 }else{//\u5143\u7d20\u4e2a\u6570\u4e3a\u5076\u6570 d1=m1; //\u820d\u5f03 A \u4e2d\u95f4\u70b9\u4ee5\u540e\u90e8\u5206\u4e14\u4fdd\u7559\u4e2d\u95f4\u70b9 s2=m2+1;//\u820d\u5f03 B \u4e2d\u95f4\u70b9\u53ca\u4e2d\u95f4\u70b9\u4ee5\u524d\u90e8\u5206 } } } return A[s1] < B[s2] ? A[s1] : B[s2];//\u56e0\u4e3a\u9898\u76ee\u8981\u7684\u662f11\uff0c\u56e0\u6b64\u6211\u4eec\u62ff\u5c0f\u7684\u90a3\u4e2a } #include <stdio.h> #include <stdlib.h> int main() { int A[] = {11, 13, 15, 17, 19}; int B[] = {2, 4, 6, 8, 20}; int mid = MidSearch(A, B, 5); printf(\"mid=%d\\n\", mid); return 0; } 3.\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(log2n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(1) \u56e0\u4e3a\u6ca1\u6709\u4f7f\u7528\u989d\u5916\u7684\u8ddf n \u76f8\u5173\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(1)\uff0c \u56e0\u4e3a\u4e0d\u65ad\u7684\u4e8c\u5206\uff0c\u6b21\u6570\u662f log2n\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(log2n)\u3002","title":"4.BST-2014-42"},{"location":"DataStruct/sort/sort/","text":"\u6392\u5e8f 1.\u4ea4\u6362\u6392\u5e8f \u5192\u6ce1\u6392\u5e8f \u5feb\u901f\u6392\u5e8f 1.1 \u5192\u6ce1\u6392\u5e8f \u5192\u6ce1\u6392\u5e8f\u7684\u539f\u7406\u6bd4\u8f83\u7b80\u5355\uff0c\u4eba\u751f\u82e6\u77ed\uff0c\u5c31\u8df3\u8fc7\u5427 #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> //\u5b9a\u4e49\u4e86\u6570\u636e\u7c7b\u578b\u7684\u7ed3\u6784\u4f53 typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } //\u6253\u5370 void STPrint(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } //\u4ea4\u6362 void swap(Elemtype &a, Elemtype &b) { Elemtype tmp; tmp = a; a = b; b = tmp; } //\u5192\u6ce1\u6392\u5e8f void BubbleSort(Elemtype A[], int n) { for (int i = 0;i<n;i++) // \u5916\u5c42\u5faa\u73af\uff0c\u6392\u5e8f\u7684round\u6570\uff0c\u7b49\u4e8e\u6570\u7ec4\u5143\u7d20\u4e2a\u6570\u51cf1 { for (int j=0; j<n-i-1;j++) // \u5185\u5c42\u5faa\u73af\uff0c\u4ea4\u6362\u5143\u7d20\u7684\u6bd4\u8f83\u6b21\u6570\uff0c\u7b49\u4e8e\u65e0\u5e8f\u533a\u7684\u5143\u7d20\u4e2a\u6570-1 { if(A[j]>A[j+1]) { swap(A[j],A[j+1]); } } } } int main() { SSTable ST; STInit(ST,10); STPrint(ST); BubbleSort(ST.elem,ST.len); STPrint(ST); } 1.2 \u5feb\u901f\u6392\u5e8f \u5feb\u901f\u6392\u5e8f\u7684\u6838\u5fc3\u662f\u5206\u6cbb\u601d\u60f3\u3002 - \u53d6\u4e00\u4e2a\u5143\u7d20p\uff08\u4e00\u822c\u53d6\u7b2c\u4e00\u4e2a\u5143\u7d20\uff09\uff0c\u4f7f\u5f97\u5143\u7d20p\u5f52\u4f4d - \u5217\u8868\u88abp\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u7684\u90fd\u6bd4p\u5c0f\uff0c\u53f3\u8fb9\u7684\u90fd\u6bd4p\u5927 - \u5206\u522b\u9012\u5f52\u5de6\u8fb9\u548c\u53f3\u8fb9 partition \u51fd\u6570\u7684\u601d\u60f3\uff1a 5 7 4 6 3 1 2 9 8 \u9996\u5148\u53d6\u7b2c\u4e00\u4e2a\u5143\u7d205\uff0c\u540c\u65f6\u7528\u6307\u5411\u9664\u53bb5 \u4ee5\u5916\u7684\u5217\u8868\u7684\u5934\u5c3e _ 7 4 6 3 1 2 9 8 | | L R \u4ece\u53f3\u8fb9\u8d77\uff0c\u627e\u6bd45\u5c0f\u7684\u6570\u653e\u5728_\u7684\u4f4d\u7f6e 2 7 4 6 3 1 _ 9 8 | | L R \u4ece\u5de6\u8fb9\u8d77\uff0c\u627e\u6bd45\u5927\u7684\u6570\u653e\u5728_\u7684\u4f4d\u7f6e 2 _ 4 6 3 1 7 9 8 | | L R 2 1 4 6 3 _ 7 9 8 | | L R 2 1 4 _ 3 6 7 9 8 | | L R 2 1 4 3 _ 6 7 9 8 | L R \u4e00\u6b21partition\u7684\u8fc7\u7a0b\u7ed3\u675f 2 1 4 3 5 6 7 9 8 | L R -- 5 \u653e\u5728\u7684\u4ed6\u8be5\u5728\u7684\u4f4d\u7f6e partition \u51fd\u6570\u7684\u5b9e\u73b0\uff1a \u8fd9\u91cc\u7684partition\u51fd\u6570\u4f7f\u7528\u76f4\u63a5\u8986\u76d6\u7684\u65b9\u5f0f\u3002 int partition(Elemtype *A, int low, int high) { Elemtype pivot=A[low];//\u62ff\u6700\u5de6\u8fb9\u7684\u5143\u7d20\u4f5c\u4e3a\u5206\u5272\u503c while (low<high) { //\u4ece\u540e\u5f80\u524d\u627e\u4e00\u4e2a\u6bd4pivot\u5c0f\u7684\u503c while (low<high && A[high]>=pivot) { high--; } A[low]=A[high]; //\u4ece\u524d\u5f80\u540e\u627e\u4e00\u4e2a\u6bd4pivot\u5927\u7684\u503c while (low<high && A[low]<=pivot) { low++; } A[high]=A[low]; } //\u5916\u5c42\u5faa\u73af\u7ed3\u675f\u4e4b\u540elow=high=\u7559\u7ed9pivot\u7684\u7a7a\u4f4d A[low]=pivot; return low; } \u6d4b\u8bd5partition\u51fd\u6570\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u6570\u7ec4\uff0c\u6d4b\u8bd5partition\u51fd\u6570\u662f\u5426\u53ef\u4ee5\u5c06\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u653e\u7f6e\u5f52\u4f4d \uff08\u5de6\u8fb9\u90fd\u5c0f\u4e8e\u8be5\u5143\u7d20\uff0c\u53f3\u8fb9\u90fd\u5927\u4e8e\u8be5\u5143\u7d20\uff09 #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } int main() { SSTable S; STInit(S, 10); Elemtype A[10] = {64, 94, 95, 79, 69, 84, 18, 22, 12, 78}; memcpy(S.elem, A, sizeof(A)); PrintST(S); partition(S.elem,0,9); PrintST(S); return 0; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/Sort-QuickSort/cmake-build-debug/Sort_QuickSort 64 94 95 79 69 84 18 22 12 78 12 22 18 64 69 84 79 95 94 78 \u5143\u7d2064\u6210\u529f\u653e\u5728\u5b83\u7684\u4f4d\u7f6e\u3002 \u5feb\u901f\u6392\u5e8f\u5b9e\u73b0\uff1a void QuickSort(Elemtype *A, int low, int high) { if (low<high) { int pivot_pos= partition(A,low,high); QuickSort(A,low,pivot_pos-1); QuickSort(A,pivot_pos+1,high); } } \u6bcf\u6b21\u4f7f\u7528partition\u5206\u6210\u4e24\u90e8\u5206\uff0c\u5de6\u53f3\u4f9d\u6b21\u9012\u5f52 \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } int partition(Elemtype *A, int low, int high) { Elemtype pivot=A[low];//\u62ff\u6700\u5de6\u8fb9\u7684\u5143\u7d20\u4f5c\u4e3a\u5206\u5272\u503c while (low<high) { //\u4ece\u540e\u5f80\u524d\u627e\u4e00\u4e2a\u6bd4pivot\u5c0f\u7684\u503c while (low<high && A[high]>=pivot) { high--; } A[low]=A[high]; //\u4ece\u524d\u5f80\u540e\u627e\u4e00\u4e2a\u6bd4pivot\u5927\u7684\u503c while (low<high && A[low]<=pivot) { low++; } A[high]=A[low]; } //\u5916\u5c42\u5faa\u73af\u7ed3\u675f\u4e4b\u540elow=high=\u7559\u7ed9pivot\u7684\u7a7a\u4f4d A[low]=pivot; return low; } void QuickSort(Elemtype *A, int low, int high) { if (low<high) { int pivot_pos= partition(A,low,high); QuickSort(A,low,pivot_pos-1); QuickSort(A,pivot_pos+1,high); } } int main() { SSTable S; STInit(S, 10); PrintST(S); QuickSort(S.elem,0,9); PrintST(S); return 0; } \u5feb\u901f\u6392\u5e8f\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \u5047\u5982\u6bcf\u6b21\u5feb\u901f\u6392\u5e8f\u6570\u7ec4\u90fd\u88ab\u5e73\u5747\u5730\u4e00\u5206\u4e3a\u4e8c\uff0c\u90a3\u4e48\u53ef\u4ee5\u5f97\u51fa QuickSort \u9012\u5f52\u7684\u6b21\u6570\u662f log2n\uff0c \u7b2c\u4e00\u6b21partition\u904d\u5386\u6b21\u6570\u4e3a n\uff0c\u5206\u6210\u4e24\u4e2a\u6570\u7ec4\u540e\uff0c\u6bcf\u4e2a\u6570\u7ec4\u904d\u5386 n/2 \u6b21\uff0c\u52a0\u8d77\u6765\u8fd8\u662fn\u3002\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nlog2n)\u3002 \u5982\u679c\u6bcf\u6b21\u6211\u4eec\u4ecd\u7136\u7528\u6700\u5de6\u8fb9\u7684\u6570\u4f5c\u4e3a\u5206\u5272\u503c\uff0c\u90a3\u4e48\u6bcf\u6b21\u6570\u7ec4\u90fd\u4e0d\u4f1a\u4e8c\u5206\uff0c \u5bfc\u81f4\u9012\u5f52n\u6b21\uff0c \u6240\u4ee5\u5feb\u901f\u6392\u5e8f\u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\u4e3an\u7684\u5e73\u65b9 \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0c\u6709\u65f6\u4f1a\u9996\u5148\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u4e0b\u6807\uff0c\u5148\u5c06\u5bf9\u5e94\u4e0b\u6807\u7684\u503c\u4e0e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\u4ea4\u6362\uff0c\u518d\u8fdb\u884cpartition\u64cd\u4f5c\u3002 \u56e0\u6b64\u5feb\u5e8f\u6700\u597d\u548c\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(log2n)\uff0c\u6700\u5dee\u662fO(n^2) \u5feb\u6392\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(log2n)\uff0c\u56e0\u6b64\u9012\u5f52\u7684\u6b21\u6570\u662flog2n\uff0c\u6bcf\u6b21\u9012\u5f52\u90fd\u9700\u8981\u5360\u7528\u7a7a\u95f4\u3002 2.\u63d2\u5165\u6392\u5e8f \u76f4\u63a5\u63d2\u5165\u6392\u5e8f \u6298\u534a\u63d2\u5165\u6392\u5e8f \u5e0c\u5c14\u6392\u5e8f 2.1 \u76f4\u63a5\u63d2\u5165\u6392\u5e8f \u5982\u679c\u5e8f\u5217\u53ea\u6709\u4e00\u4e2a\u6570\uff0c\u5e8f\u5217\u5c31\u662f\u6709\u5e8f\u7684\u3002\u63d2\u5165\u6392\u5e8f\u9996\u5148\u5c06\u7b2c\u4e00\u4e2a\u6570\u89c6\u4e3a\u6709\u5e8f\u5e8f\u5217\u3002 \u7136\u540e\u540e\u97629\u4e2a\u6570\u89c6\u4e3a\u8981\u4f9d\u6b21\u63d2\u5165\u7684\u5e8f\u5217 \u76f4\u63a5\u63d2\u5165\u6392\u5e8f\u7684\u5b9e\u73b0\uff1a void InsertSort(Elemtype *A,int n) { int i,j,insertVal; for(i=1;i<n;i++) { insertVal=A[i]; for(j=i-1;j>=0&&A[j]>insertVal;j--) { A[j+1]=A[j]; } A[j+1]=insertVal; } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } void InsertSort(Elemtype *A,int n) { int i,j,insertVal; for(i=1;i<n;i++) { insertVal=A[i]; for(j=i-1;j>=0&&A[j]>insertVal;j--) { A[j+1]=A[j]; } A[j+1]=insertVal; } } int main() { SSTable S; STInit(S,10); PrintST(S); InsertSort(S.elem,10); PrintST(S); return 0; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/Sort-InsertSort/cmake-build-debug/Sort_InsertSort 44 74 14 15 86 10 33 86 16 65 10 14 15 16 33 44 65 74 86 86 Process finished with exit code 0 \u65f6\u95f4\u590d\u6742\u5ea6&\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a \u968f\u7740\u6709\u5e8f\u5e8f\u5217\u7684\u4e0d\u65ad\u589e\u52a0\uff0c\u63d2\u5165\u6392\u5e8f\u6bd4\u8f83\u7684\u6b21\u6570\u4e5f\u4f1a\u589e\u52a0\u3002 \u63d2\u5165\u6392\u5e8f\u7684\u6267\u884c\u6b21\u6570\u4e5f\u662f\u4ece1\u589e\u52a0\u5230n-1\uff0c\u603b\u8fd0\u884c\u6b21\u6570\u662fn\uff08n-1\uff09/2\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u4f9d\u7136\u4e3aO\uff08n^2\uff09 \u3002 \u56e0\u4e3a\u672a\u4f7f\u7528\u989d\u5916\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1). \u5982\u679c\u6570\u7ec4\u672c\u8eab\u6709\u5e8f\uff0c\u90a3\u4e48\u6700\u597d\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662fO\uff08n\uff09\u3002 3.\u9009\u62e9\u6392\u5e8f \u7b80\u5355\u9009\u62e9\u6392\u5e8f \u5806\u6392\u5e8f 3.1\u7b80\u5355\u9009\u62e9\u6392\u5e8f \u9009\u62e9\u6392\u5e8f\u6f14\u793a\ud83c\udf88 \u9009\u62e9\u6392\u5e8f\u7684\u539f\u7406\uff1a \u6709\u4e00\u7ec4\u5e8f\u5217\uff1a 19 21 79 9 8 81 76 91 83 44 | min \u5047\u5b9a\u7b2c\u4e00\u4e2a\u5143\u7d20\u662f\u6700\u5c0f\u503c\uff0c\u4f9d\u6b21\u904d\u5386min\u4e4b\u540e\u7684\u90e8\u5206\uff0c 19 21 79 9 8 81 76 91 83 44 | min \u627e\u5230\u6700\u5c0f\u503c\u540e\u4e0e\u7b2c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362 9 21 79 19 8 81 76 91 83 44 | min \u5047\u5b9a\u7b2c\u4e8c\u4e2a\u5143\u7d20\u4e3a\u6700\u5c0f\u503c\uff0c\u4f9d\u6b21\u904d\u5386min\u4e4b\u540e\u7684\u90e8\u5206 9 21 79 19 8 81 76 91 83 44 | min \u627e\u5230\u6700\u5c0f\u503c\u540e\u4e0e\u7b2c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362 9 8 79 19 21 81 76 91 83 44 | min \u5047\u5b9a\u7b2c\u4e09\u4e2a\u5143\u7d20\u4e3a\u6700\u5c0f\u503c\uff0c\u4f9d\u6b21\u904d\u5386min\u4e4b\u540e\u7684\u90e8\u5206 ......\u4f9d\u6b21\u5faa\u73af \u9009\u62e9\u6392\u5e8f\u7684\u5b9e\u73b0\uff1a void SelectSort(Elemtype *A,int n) { int i,j,min;//\u5206\u522b\u5b9a\u4e49\u5185\u5916\u5c42\u7684\u5faa\u73af\u53d8\u91cf\u4ee5\u53ca\u7528\u4e8e\u6807\u8bc6\u6700\u5c0f\u503c\u7684\u53d8\u91cfmin for(i=0;i<n-1;i++) { // min\u73b0\u6807\u6ce8\u6700\u5c0f\u503c min=i; for(j=i+1;j<n;j++) { // \u5982\u679c\u627e\u5230\u5e94\u8be5\u5c0f\u4e8emin\u7684\uff0c\u5219min\u91cd\u65b0\u6807\u6ce8\u4e3a\u90a3\u4e2a\u503c if(A[min]>A[j]) { min=j; } //\u5faa\u73af\u7ed3\u675f\u540e\uff0cmin\u6807\u8bc6\u7684\u5c31\u662f\u540e\u7eed\u5e8f\u5217\u7684\u6700\u5c0f\u503c } //\u8fdb\u884c\u4ea4\u6362 swap(A[i],A[min]); } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } void swap(Elemtype &a, Elemtype &b) { Elemtype tmp; tmp = a; a = b; b = tmp; } void SelectSort(Elemtype *A,int n) { int i,j,min; for(i=0;i<n-1;i++) { min=i; for(j=i+1;j<n;j++) { if(A[min]>A[j]) { min=j; } } swap(A[i],A[min]); } } int main() { SSTable S; STInit(S,10); PrintST(S); SelectSort(S.elem,10); PrintST(S); } \u9009\u62e9\u6392\u5e8f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a \u9009\u62e9\u6392\u5e8f\u867d\u7136\u51cf\u5c11\u4e86\u4ea4\u6362\u6b21\u6570\uff0c\u4f46\u662f\u5faa\u73af\u6bd4\u8f83\u7684\u6b21\u6570\u4f9d\u7136\u548c\u5192\u6ce1\u6392\u5e8f\u662f\u4e00\u6837\u7684\uff0c\u90fd\u662f\u4ece1\u5230N-1\uff0c \u603b\u8fd0\u884c\u6b21\u6570\u4e3aN\uff08N-1\uff09/2\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n^2) \u56e0\u4e3a\u672a\u4f7f\u7528\u989d\u5916\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1) 3.2\u5806\u6392\u5e8f \u5806\u6392\u5e8f\u6f14\u793a\ud83c\udf88 3.2.1\u524d\u620f\uff1a\u5806 \u5806\u662f\u4e00\u79cd\u57fa\u4e8e\u6811\u7684\u6570\u636e\u7ed3\u6784\u3002\u6ee1\u8db3\u4ee5\u4e0b\u7279\u6027\u7684\u6811\u79f0\u4e3a\u5806\uff1a \u7ed9\u5b9a\u5806\u4e2d\u4efb\u610f\u7ed3\u70b9P\u548cc\uff0c\u82e5P\u662fC\u7684\u7236\u7ed3\u70b9\uff0c\u5219P\u7684\u503c\u5c0f\u4e8e\u7b49\u4e8e\uff08\u5927\u4e8e\u7b49\u4e8e\uff09C\u7684\u503c\u3002 \u5c0f\u6839\u5806\uff08\u6700\u5c0f\u5806\uff09\uff1a\u7236\u8282\u70b9\u5c0f\u4e8e\u5b50\u7ed3\u70b9 \u5927\u6839\u5806\uff08\u6700\u5927\u5806\uff09\uff1a\u7236\u8282\u70b9\u5927\u4e8e\u5b50\u7ed3\u70b9 \u5806\u6700\u9876\u7aef\u7684\u7ed3\u70b9\u79f0\u4e3a\u6839\u7ed3\u70b9\uff0c\u6839\u8282\u70b9\u6ca1\u6709\u7236\u7ed3\u70b9\u3002 \u5c06\u4e8c\u53c9\u6811\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u5bf9\u5e94\u5230\u6570\u7ec4\u4e0b\u6807\uff0c\u8fd9\u6837\u7684\u6570\u636e\u7ed3\u6784\u79f0\u4e4b\u4e3a\u5806 3.2.2\u5411\u4e0b\u8c03\u6574 \u9488\u5bf9\u4e00\u68f5\u5b50\u6811\uff0c\u4f7f\u7528\u5411\u4e0b\u8c03\u6574\u51fd\u6570\uff0c\u53ef\u4ee5\u4f7f\u4e00\u68f5\u5b50\u6811\u6210\u4e3a\u5806 \u9700\u8981\u6ce8\u610f\u7684\u70b9\uff1a \u5de6\u53f3\u5b69\u5b50\u7684\u8fb9\u754c\u95ee\u9898 \u5faa\u73af\u7684\u7ec8\u6b62\u6761\u4ef6 void AdjustDown(Elemtype *A, int d, int len) { int dad = d; int son = 2 * dad + 1; //\u5de6\u5b69\u5b50\u7684\u4e0b\u6807 while (son <= len) { if (son + 1 <= len && A[son] < A[son + 1]) { son++; } if (A[son] > A[dad]) { swap(A[son], A[dad]); dad = son; son = 2 * dad + 1; } else { break; } } } 3.2.3\u5806\u6392\u5e8f void HeapSort(Elemtype *A,int len) { int i; //\u5efa\u7acb\u4e00\u4e2a\u5806 for(i=len/2;i>=0;i--) { AdjustDown(A,i,len); } //\u6bcf\u6b21\u53d6\u6700\u6709\u4e00\u4e2a\u5143\u7d20\u4e0e\u5806\u9876\u5143\u7d20\u4ea4\u6362\u4f4d\u7f6e\u3002 //\u4e4b\u540e\u5c06len-1\u957f\u5ea6\u7684\u6570\u7ec4\u8fdb\u884c\u5411\u4e0b\u8c03\u6574\u3002 for(i=len;i>0;i--) { AdjustDown(A,0,i); swap(A[0],A[i]); } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } void swap(Elemtype &a, Elemtype &b) { Elemtype tmp; tmp = a; a = b; b = tmp; } //\u5411\u4e0b\u8c03\u6574 void AdjustDown(Elemtype *A, int d, int len) { int dad = d; int son = 2 * dad + 1; //\u5de6\u5b69\u5b50\u7684\u4e0b\u6807 while (son <= len) { if (son + 1 <= len && A[son] < A[son + 1]) { son++; } if (A[son] > A[dad]) { swap(A[son], A[dad]); dad = son; son = 2 * dad + 1; } else { break; } } } void HeapSort(Elemtype *A,int len) { int i; for(i=len/2;i>=0;i--) { AdjustDown(A,i,len); } for(i=len;i>0;i--) { AdjustDown(A,0,i); swap(A[0],A[i]); } } int main() { SSTable ST; STInit(ST, 10); // Elemtype A[10] = {3, 87, 2, 93, 78, 56, 61, 38, 12, 40}; // memcpy(ST.elem, A, sizeof(A)); PrintST(ST); HeapSort(ST.elem,9); PrintST(ST); } /Users/uichuan/Documents/library/DataStructure/codes/Sort-HeapSort/cmake-build-debug/Sort_HeapSort 7 69 95 16 75 70 89 98 12 81 7 12 16 69 70 75 81 89 95 98 Process finished with exit code 0 \u5806\u6392\u5e8f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a AdjustDown\u51fd\u6570\u7684\u5faa\u73af\u6b21\u6570\u662flog2n HeapSort\u51fd\u6570\u7b2c\u4e00\u4e2afor\u5faa\u73af\u6267\u884c\u4e86n/2\u6b21 \u7b2c\u4e00\u4e2afor\u5faa\u73af\u6267\u884c\u4e86n\u6b21 \u603b\u8ba1\u6b21\u6570\u4e3a3/2nlog2n\u6b21\uff0c\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u662fO\uff08nlog2n\uff09 \u5806\u6392\u6700\u597d\u3001\u6700\u574f\u3001\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f O ( n log2 n )\u3002 \u5806\u6392\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O (1)\uff0c\u56e0\u4e3a\u6ca1\u6709\u4f7f\u7528\u4e0e n \u76f8\u5173\u7684\u989d\u5916\u7a7a\u95f4\u3002 4.\u5f52\u5e76\u6392\u5e8f \u4e00\u4e2a\u6570\u7ec4\u5982\u679c\u5206\u4e24\u6bb5\u6709\u5e8f\uff0c\u90a3\u4e48\u53ef\u4ee5\u4f7f\u7528\u4e00\u6b21 \u5f52\u5e76 \u8ba9\u6574\u4e2a\u6570\u7ec4\u6709\u5e8f\u3002 \u4f8b\u5982\uff1a A={1,5,7,9, 2,3,4,8} \u5206\u4e24\u6bb5\u6709\u5e8f \u9700\u8981\u7533\u8bf7\u4e00\u5757\u989d\u5916\u7684\u7a7a\u95f4\u6765\u5b58\u50a8\u6392\u597d\u5e8f\u7684\u6570\u7ec4\u3002 4.1 Merge\u51fd\u6570 \u901a\u8fc7\u4e00\u6b21merge\u51fd\u6570\u7684\u8c03\u7528\uff0c\u53ef\u4ee5\u4f7f\u6709\u5e8f\u7684\u4e24\u4e2a\u5c0f\u6570\u7ec4\u5408\u5e76\u6210\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4\u3002 merge\u51fd\u6570\u7684\u5b9e\u73b0\uff1a void Merge(Elemtype *A, int low, int mid, int high) { static Elemtype B[N]; int i, j, k; // \u590d\u5236\u5143\u7d20 for (k = low; k <= high; k++) { B[k] = A[k]; } for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) { if (B[i] < B[j]) { A[k] = B[i++]; } else { A[k] = B[j++]; } } //\u5269\u4e0b\u4e00\u90e8\u5206\u76f4\u63a5\u653e\u5165\u6709\u5e8f\u6570\u7ec4 while (i <= mid) { A[k++] = B[i++]; } while (j <= high) { A[k++] = B[j++]; } } \u6d4b\u8bd5\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #define N 7 typedef int Elemtype; void PrintArr(Elemtype *A,int len) { for(int i=0;i<len;i++) { printf(\"%3d\",A[i]); } printf(\"\\n\"); } void Merge(Elemtype *A, int low, int mid, int high) { static Elemtype B[N]; int i, j, k; // \u590d\u5236\u5143\u7d20 for (k = low; k <= high; k++) { B[k] = A[k]; } for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) { if (B[i] < B[j]) { A[k] = B[i++]; } else { A[k] = B[j++]; } } //\u5269\u4e0b\u4e00\u90e8\u5206\u76f4\u63a5\u653e\u5165\u6709\u5e8f\u6570\u7ec4 while (i <= mid) { A[k++] = B[i++]; } while (j <= high) { A[k++] = B[j++]; } } int main() { Elemtype A[] = {1, 5, 7, 9, 2, 3, 4, 8}; PrintArr(A,8); Merge(A,0,3,7); PrintArr(A,8); return 0; } 4.2 \u5f52\u5e76\u6392\u5e8f\u7684\u9012\u5f52\u5b9e\u73b0 MergeSort\u51fd\u6570\u7684\u5b9e\u73b0\uff1a \u603b\u4f53\u601d\u8def \u5c06\u6574\u4e2a\u6570\u7ec4\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206 \u5de6\u53f3\u4e24\u90e8\u5206\u5206\u522b\u9012\u5f52\u8fdb\u884c\u5f52\u5e76\u6392\u5e8f Merge\u5408\u5e76\u5de6\u53f3\u4e24\u90e8\u5206\u5df2\u7ecf\u6709\u5e8f\u7684\u5c0f\u6570\u7ec4 \u6700\u540e\u901a\u8fc7merge\u5f97\u5230\u6700\u7ec8\u7684\u6709\u5e8f\u6570\u7ec4\u3002 void MergeSort(Elemtype *A,int low,int high) { if (low<high) { int mid=(low+high)/2; MergeSort(A,low,mid); MergeSort(A,mid+1,high); Merge(A,low,mid,high); } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #define N 7 typedef int Elemtype; void PrintArr(Elemtype *A,int len) { for(int i=0;i<len;i++) { printf(\"%3d\",A[i]); } printf(\"\\n\"); } void Merge(Elemtype *A, int low, int mid, int high) { static Elemtype B[N]; int i, j, k; // \u590d\u5236\u5143\u7d20 for (k = low; k <= high; k++) { B[k] = A[k]; } for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) { if (B[i] < B[j]) { A[k] = B[i++]; } else { A[k] = B[j++]; } } //\u5269\u4e0b\u4e00\u90e8\u5206\u76f4\u63a5\u653e\u5165\u6709\u5e8f\u6570\u7ec4 while (i <= mid) { A[k++] = B[i++]; } while (j <= high) { A[k++] = B[j++]; } } void MergeSort(Elemtype *A,int low,int high) { if (low<high) { int mid=(low+high)/2; MergeSort(A,low,mid); MergeSort(A,mid+1,high); Merge(A,low,mid,high); } } int main() { Elemtype A[] = {1, 5, 7, 9, 2, 3, 4, 8}; printf(\"--------Merge Test--------\\n\"); PrintArr(A,8); Merge(A,0,3,7); PrintArr(A,8); printf(\"--------MergeSort Test--------\\n\"); Elemtype Arr[] = {2,1,5,4,6,9,7,3}; PrintArr(Arr,8); MergeSort(Arr,0,7); PrintArr(Arr,8); return 0; } \u6d4b\u8bd5\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/Sort-MergeSort/cmake-build-debug/Sort_MergeSort --------Merge Test-------- 1 5 7 9 2 3 4 8 1 2 3 4 5 7 8 9 --------MergeSort Test-------- 2 1 5 4 6 9 7 3 1 2 3 4 5 6 7 9 Process finished with exit code 0 \u65f6\u95f4\u590d\u6742\u5ea6\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a MergeSort\u51fd\u6570\u7684\u9012\u5f52\u6b21\u6570\u4e3alog2n\uff0c Merge\u51fd\u6570\u5faa\u73af\u4e86n\u6b21\uff0c\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nlog2n) \u5f52\u5e76\u6392\u5e8f\u6700\u597d\uff0c\u6700\u574f\uff0c\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662fO(nlog2n) \u5f52\u5e76\u6392\u5e8f\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(n)\uff0c\u56e0\u4e3a\u5728Merge\u51fd\u6570\u7684\u8fc7\u7a0b\u4e2d\u4f7f\u7528\u4e86\u53e6\u5916\u7684\u4e00\u4e2a\u7b49\u957f\u6570\u7ec4\u3002 5.\u6392\u5e8f\u7b97\u6cd5\u65f6\u95f4&\u7a7a\u95f4\u590d\u6742\u5ea6\u6c47\u603b","title":"8.\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#_1","text":"","title":"\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#1","text":"\u5192\u6ce1\u6392\u5e8f \u5feb\u901f\u6392\u5e8f","title":"1.\u4ea4\u6362\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#11","text":"\u5192\u6ce1\u6392\u5e8f\u7684\u539f\u7406\u6bd4\u8f83\u7b80\u5355\uff0c\u4eba\u751f\u82e6\u77ed\uff0c\u5c31\u8df3\u8fc7\u5427 #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> //\u5b9a\u4e49\u4e86\u6570\u636e\u7c7b\u578b\u7684\u7ed3\u6784\u4f53 typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } //\u6253\u5370 void STPrint(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } //\u4ea4\u6362 void swap(Elemtype &a, Elemtype &b) { Elemtype tmp; tmp = a; a = b; b = tmp; } //\u5192\u6ce1\u6392\u5e8f void BubbleSort(Elemtype A[], int n) { for (int i = 0;i<n;i++) // \u5916\u5c42\u5faa\u73af\uff0c\u6392\u5e8f\u7684round\u6570\uff0c\u7b49\u4e8e\u6570\u7ec4\u5143\u7d20\u4e2a\u6570\u51cf1 { for (int j=0; j<n-i-1;j++) // \u5185\u5c42\u5faa\u73af\uff0c\u4ea4\u6362\u5143\u7d20\u7684\u6bd4\u8f83\u6b21\u6570\uff0c\u7b49\u4e8e\u65e0\u5e8f\u533a\u7684\u5143\u7d20\u4e2a\u6570-1 { if(A[j]>A[j+1]) { swap(A[j],A[j+1]); } } } } int main() { SSTable ST; STInit(ST,10); STPrint(ST); BubbleSort(ST.elem,ST.len); STPrint(ST); }","title":"1.1 \u5192\u6ce1\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#12","text":"\u5feb\u901f\u6392\u5e8f\u7684\u6838\u5fc3\u662f\u5206\u6cbb\u601d\u60f3\u3002 - \u53d6\u4e00\u4e2a\u5143\u7d20p\uff08\u4e00\u822c\u53d6\u7b2c\u4e00\u4e2a\u5143\u7d20\uff09\uff0c\u4f7f\u5f97\u5143\u7d20p\u5f52\u4f4d - \u5217\u8868\u88abp\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u7684\u90fd\u6bd4p\u5c0f\uff0c\u53f3\u8fb9\u7684\u90fd\u6bd4p\u5927 - \u5206\u522b\u9012\u5f52\u5de6\u8fb9\u548c\u53f3\u8fb9 partition \u51fd\u6570\u7684\u601d\u60f3\uff1a 5 7 4 6 3 1 2 9 8 \u9996\u5148\u53d6\u7b2c\u4e00\u4e2a\u5143\u7d205\uff0c\u540c\u65f6\u7528\u6307\u5411\u9664\u53bb5 \u4ee5\u5916\u7684\u5217\u8868\u7684\u5934\u5c3e _ 7 4 6 3 1 2 9 8 | | L R \u4ece\u53f3\u8fb9\u8d77\uff0c\u627e\u6bd45\u5c0f\u7684\u6570\u653e\u5728_\u7684\u4f4d\u7f6e 2 7 4 6 3 1 _ 9 8 | | L R \u4ece\u5de6\u8fb9\u8d77\uff0c\u627e\u6bd45\u5927\u7684\u6570\u653e\u5728_\u7684\u4f4d\u7f6e 2 _ 4 6 3 1 7 9 8 | | L R 2 1 4 6 3 _ 7 9 8 | | L R 2 1 4 _ 3 6 7 9 8 | | L R 2 1 4 3 _ 6 7 9 8 | L R \u4e00\u6b21partition\u7684\u8fc7\u7a0b\u7ed3\u675f 2 1 4 3 5 6 7 9 8 | L R -- 5 \u653e\u5728\u7684\u4ed6\u8be5\u5728\u7684\u4f4d\u7f6e partition \u51fd\u6570\u7684\u5b9e\u73b0\uff1a \u8fd9\u91cc\u7684partition\u51fd\u6570\u4f7f\u7528\u76f4\u63a5\u8986\u76d6\u7684\u65b9\u5f0f\u3002 int partition(Elemtype *A, int low, int high) { Elemtype pivot=A[low];//\u62ff\u6700\u5de6\u8fb9\u7684\u5143\u7d20\u4f5c\u4e3a\u5206\u5272\u503c while (low<high) { //\u4ece\u540e\u5f80\u524d\u627e\u4e00\u4e2a\u6bd4pivot\u5c0f\u7684\u503c while (low<high && A[high]>=pivot) { high--; } A[low]=A[high]; //\u4ece\u524d\u5f80\u540e\u627e\u4e00\u4e2a\u6bd4pivot\u5927\u7684\u503c while (low<high && A[low]<=pivot) { low++; } A[high]=A[low]; } //\u5916\u5c42\u5faa\u73af\u7ed3\u675f\u4e4b\u540elow=high=\u7559\u7ed9pivot\u7684\u7a7a\u4f4d A[low]=pivot; return low; } \u6d4b\u8bd5partition\u51fd\u6570\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u6570\u7ec4\uff0c\u6d4b\u8bd5partition\u51fd\u6570\u662f\u5426\u53ef\u4ee5\u5c06\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u653e\u7f6e\u5f52\u4f4d \uff08\u5de6\u8fb9\u90fd\u5c0f\u4e8e\u8be5\u5143\u7d20\uff0c\u53f3\u8fb9\u90fd\u5927\u4e8e\u8be5\u5143\u7d20\uff09 #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } int main() { SSTable S; STInit(S, 10); Elemtype A[10] = {64, 94, 95, 79, 69, 84, 18, 22, 12, 78}; memcpy(S.elem, A, sizeof(A)); PrintST(S); partition(S.elem,0,9); PrintST(S); return 0; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/Sort-QuickSort/cmake-build-debug/Sort_QuickSort 64 94 95 79 69 84 18 22 12 78 12 22 18 64 69 84 79 95 94 78 \u5143\u7d2064\u6210\u529f\u653e\u5728\u5b83\u7684\u4f4d\u7f6e\u3002 \u5feb\u901f\u6392\u5e8f\u5b9e\u73b0\uff1a void QuickSort(Elemtype *A, int low, int high) { if (low<high) { int pivot_pos= partition(A,low,high); QuickSort(A,low,pivot_pos-1); QuickSort(A,pivot_pos+1,high); } } \u6bcf\u6b21\u4f7f\u7528partition\u5206\u6210\u4e24\u90e8\u5206\uff0c\u5de6\u53f3\u4f9d\u6b21\u9012\u5f52 \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } int partition(Elemtype *A, int low, int high) { Elemtype pivot=A[low];//\u62ff\u6700\u5de6\u8fb9\u7684\u5143\u7d20\u4f5c\u4e3a\u5206\u5272\u503c while (low<high) { //\u4ece\u540e\u5f80\u524d\u627e\u4e00\u4e2a\u6bd4pivot\u5c0f\u7684\u503c while (low<high && A[high]>=pivot) { high--; } A[low]=A[high]; //\u4ece\u524d\u5f80\u540e\u627e\u4e00\u4e2a\u6bd4pivot\u5927\u7684\u503c while (low<high && A[low]<=pivot) { low++; } A[high]=A[low]; } //\u5916\u5c42\u5faa\u73af\u7ed3\u675f\u4e4b\u540elow=high=\u7559\u7ed9pivot\u7684\u7a7a\u4f4d A[low]=pivot; return low; } void QuickSort(Elemtype *A, int low, int high) { if (low<high) { int pivot_pos= partition(A,low,high); QuickSort(A,low,pivot_pos-1); QuickSort(A,pivot_pos+1,high); } } int main() { SSTable S; STInit(S, 10); PrintST(S); QuickSort(S.elem,0,9); PrintST(S); return 0; } \u5feb\u901f\u6392\u5e8f\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \u5047\u5982\u6bcf\u6b21\u5feb\u901f\u6392\u5e8f\u6570\u7ec4\u90fd\u88ab\u5e73\u5747\u5730\u4e00\u5206\u4e3a\u4e8c\uff0c\u90a3\u4e48\u53ef\u4ee5\u5f97\u51fa QuickSort \u9012\u5f52\u7684\u6b21\u6570\u662f log2n\uff0c \u7b2c\u4e00\u6b21partition\u904d\u5386\u6b21\u6570\u4e3a n\uff0c\u5206\u6210\u4e24\u4e2a\u6570\u7ec4\u540e\uff0c\u6bcf\u4e2a\u6570\u7ec4\u904d\u5386 n/2 \u6b21\uff0c\u52a0\u8d77\u6765\u8fd8\u662fn\u3002\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nlog2n)\u3002 \u5982\u679c\u6bcf\u6b21\u6211\u4eec\u4ecd\u7136\u7528\u6700\u5de6\u8fb9\u7684\u6570\u4f5c\u4e3a\u5206\u5272\u503c\uff0c\u90a3\u4e48\u6bcf\u6b21\u6570\u7ec4\u90fd\u4e0d\u4f1a\u4e8c\u5206\uff0c \u5bfc\u81f4\u9012\u5f52n\u6b21\uff0c \u6240\u4ee5\u5feb\u901f\u6392\u5e8f\u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\u4e3an\u7684\u5e73\u65b9 \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0c\u6709\u65f6\u4f1a\u9996\u5148\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u4e0b\u6807\uff0c\u5148\u5c06\u5bf9\u5e94\u4e0b\u6807\u7684\u503c\u4e0e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\u4ea4\u6362\uff0c\u518d\u8fdb\u884cpartition\u64cd\u4f5c\u3002 \u56e0\u6b64\u5feb\u5e8f\u6700\u597d\u548c\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(log2n)\uff0c\u6700\u5dee\u662fO(n^2) \u5feb\u6392\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(log2n)\uff0c\u56e0\u6b64\u9012\u5f52\u7684\u6b21\u6570\u662flog2n\uff0c\u6bcf\u6b21\u9012\u5f52\u90fd\u9700\u8981\u5360\u7528\u7a7a\u95f4\u3002","title":"1.2 \u5feb\u901f\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#2","text":"\u76f4\u63a5\u63d2\u5165\u6392\u5e8f \u6298\u534a\u63d2\u5165\u6392\u5e8f \u5e0c\u5c14\u6392\u5e8f","title":"2.\u63d2\u5165\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#21","text":"\u5982\u679c\u5e8f\u5217\u53ea\u6709\u4e00\u4e2a\u6570\uff0c\u5e8f\u5217\u5c31\u662f\u6709\u5e8f\u7684\u3002\u63d2\u5165\u6392\u5e8f\u9996\u5148\u5c06\u7b2c\u4e00\u4e2a\u6570\u89c6\u4e3a\u6709\u5e8f\u5e8f\u5217\u3002 \u7136\u540e\u540e\u97629\u4e2a\u6570\u89c6\u4e3a\u8981\u4f9d\u6b21\u63d2\u5165\u7684\u5e8f\u5217 \u76f4\u63a5\u63d2\u5165\u6392\u5e8f\u7684\u5b9e\u73b0\uff1a void InsertSort(Elemtype *A,int n) { int i,j,insertVal; for(i=1;i<n;i++) { insertVal=A[i]; for(j=i-1;j>=0&&A[j]>insertVal;j--) { A[j+1]=A[j]; } A[j+1]=insertVal; } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } void InsertSort(Elemtype *A,int n) { int i,j,insertVal; for(i=1;i<n;i++) { insertVal=A[i]; for(j=i-1;j>=0&&A[j]>insertVal;j--) { A[j+1]=A[j]; } A[j+1]=insertVal; } } int main() { SSTable S; STInit(S,10); PrintST(S); InsertSort(S.elem,10); PrintST(S); return 0; } \u8fd0\u884c\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/Sort-InsertSort/cmake-build-debug/Sort_InsertSort 44 74 14 15 86 10 33 86 16 65 10 14 15 16 33 44 65 74 86 86 Process finished with exit code 0 \u65f6\u95f4\u590d\u6742\u5ea6&\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a \u968f\u7740\u6709\u5e8f\u5e8f\u5217\u7684\u4e0d\u65ad\u589e\u52a0\uff0c\u63d2\u5165\u6392\u5e8f\u6bd4\u8f83\u7684\u6b21\u6570\u4e5f\u4f1a\u589e\u52a0\u3002 \u63d2\u5165\u6392\u5e8f\u7684\u6267\u884c\u6b21\u6570\u4e5f\u662f\u4ece1\u589e\u52a0\u5230n-1\uff0c\u603b\u8fd0\u884c\u6b21\u6570\u662fn\uff08n-1\uff09/2\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u4f9d\u7136\u4e3aO\uff08n^2\uff09 \u3002 \u56e0\u4e3a\u672a\u4f7f\u7528\u989d\u5916\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1). \u5982\u679c\u6570\u7ec4\u672c\u8eab\u6709\u5e8f\uff0c\u90a3\u4e48\u6700\u597d\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662fO\uff08n\uff09\u3002","title":"2.1 \u76f4\u63a5\u63d2\u5165\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#3","text":"\u7b80\u5355\u9009\u62e9\u6392\u5e8f \u5806\u6392\u5e8f","title":"3.\u9009\u62e9\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#31","text":"\u9009\u62e9\u6392\u5e8f\u6f14\u793a\ud83c\udf88 \u9009\u62e9\u6392\u5e8f\u7684\u539f\u7406\uff1a \u6709\u4e00\u7ec4\u5e8f\u5217\uff1a 19 21 79 9 8 81 76 91 83 44 | min \u5047\u5b9a\u7b2c\u4e00\u4e2a\u5143\u7d20\u662f\u6700\u5c0f\u503c\uff0c\u4f9d\u6b21\u904d\u5386min\u4e4b\u540e\u7684\u90e8\u5206\uff0c 19 21 79 9 8 81 76 91 83 44 | min \u627e\u5230\u6700\u5c0f\u503c\u540e\u4e0e\u7b2c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362 9 21 79 19 8 81 76 91 83 44 | min \u5047\u5b9a\u7b2c\u4e8c\u4e2a\u5143\u7d20\u4e3a\u6700\u5c0f\u503c\uff0c\u4f9d\u6b21\u904d\u5386min\u4e4b\u540e\u7684\u90e8\u5206 9 21 79 19 8 81 76 91 83 44 | min \u627e\u5230\u6700\u5c0f\u503c\u540e\u4e0e\u7b2c\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362 9 8 79 19 21 81 76 91 83 44 | min \u5047\u5b9a\u7b2c\u4e09\u4e2a\u5143\u7d20\u4e3a\u6700\u5c0f\u503c\uff0c\u4f9d\u6b21\u904d\u5386min\u4e4b\u540e\u7684\u90e8\u5206 ......\u4f9d\u6b21\u5faa\u73af \u9009\u62e9\u6392\u5e8f\u7684\u5b9e\u73b0\uff1a void SelectSort(Elemtype *A,int n) { int i,j,min;//\u5206\u522b\u5b9a\u4e49\u5185\u5916\u5c42\u7684\u5faa\u73af\u53d8\u91cf\u4ee5\u53ca\u7528\u4e8e\u6807\u8bc6\u6700\u5c0f\u503c\u7684\u53d8\u91cfmin for(i=0;i<n-1;i++) { // min\u73b0\u6807\u6ce8\u6700\u5c0f\u503c min=i; for(j=i+1;j<n;j++) { // \u5982\u679c\u627e\u5230\u5e94\u8be5\u5c0f\u4e8emin\u7684\uff0c\u5219min\u91cd\u65b0\u6807\u6ce8\u4e3a\u90a3\u4e2a\u503c if(A[min]>A[j]) { min=j; } //\u5faa\u73af\u7ed3\u675f\u540e\uff0cmin\u6807\u8bc6\u7684\u5c31\u662f\u540e\u7eed\u5e8f\u5217\u7684\u6700\u5c0f\u503c } //\u8fdb\u884c\u4ea4\u6362 swap(A[i],A[min]); } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } void swap(Elemtype &a, Elemtype &b) { Elemtype tmp; tmp = a; a = b; b = tmp; } void SelectSort(Elemtype *A,int n) { int i,j,min; for(i=0;i<n-1;i++) { min=i; for(j=i+1;j<n;j++) { if(A[min]>A[j]) { min=j; } } swap(A[i],A[min]); } } int main() { SSTable S; STInit(S,10); PrintST(S); SelectSort(S.elem,10); PrintST(S); } \u9009\u62e9\u6392\u5e8f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a \u9009\u62e9\u6392\u5e8f\u867d\u7136\u51cf\u5c11\u4e86\u4ea4\u6362\u6b21\u6570\uff0c\u4f46\u662f\u5faa\u73af\u6bd4\u8f83\u7684\u6b21\u6570\u4f9d\u7136\u548c\u5192\u6ce1\u6392\u5e8f\u662f\u4e00\u6837\u7684\uff0c\u90fd\u662f\u4ece1\u5230N-1\uff0c \u603b\u8fd0\u884c\u6b21\u6570\u4e3aN\uff08N-1\uff09/2\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n^2) \u56e0\u4e3a\u672a\u4f7f\u7528\u989d\u5916\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1)","title":"3.1\u7b80\u5355\u9009\u62e9\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#32","text":"\u5806\u6392\u5e8f\u6f14\u793a\ud83c\udf88","title":"3.2\u5806\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#321","text":"\u5806\u662f\u4e00\u79cd\u57fa\u4e8e\u6811\u7684\u6570\u636e\u7ed3\u6784\u3002\u6ee1\u8db3\u4ee5\u4e0b\u7279\u6027\u7684\u6811\u79f0\u4e3a\u5806\uff1a \u7ed9\u5b9a\u5806\u4e2d\u4efb\u610f\u7ed3\u70b9P\u548cc\uff0c\u82e5P\u662fC\u7684\u7236\u7ed3\u70b9\uff0c\u5219P\u7684\u503c\u5c0f\u4e8e\u7b49\u4e8e\uff08\u5927\u4e8e\u7b49\u4e8e\uff09C\u7684\u503c\u3002 \u5c0f\u6839\u5806\uff08\u6700\u5c0f\u5806\uff09\uff1a\u7236\u8282\u70b9\u5c0f\u4e8e\u5b50\u7ed3\u70b9 \u5927\u6839\u5806\uff08\u6700\u5927\u5806\uff09\uff1a\u7236\u8282\u70b9\u5927\u4e8e\u5b50\u7ed3\u70b9 \u5806\u6700\u9876\u7aef\u7684\u7ed3\u70b9\u79f0\u4e3a\u6839\u7ed3\u70b9\uff0c\u6839\u8282\u70b9\u6ca1\u6709\u7236\u7ed3\u70b9\u3002 \u5c06\u4e8c\u53c9\u6811\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u5bf9\u5e94\u5230\u6570\u7ec4\u4e0b\u6807\uff0c\u8fd9\u6837\u7684\u6570\u636e\u7ed3\u6784\u79f0\u4e4b\u4e3a\u5806","title":"3.2.1\u524d\u620f\uff1a\u5806"},{"location":"DataStruct/sort/sort/#322","text":"\u9488\u5bf9\u4e00\u68f5\u5b50\u6811\uff0c\u4f7f\u7528\u5411\u4e0b\u8c03\u6574\u51fd\u6570\uff0c\u53ef\u4ee5\u4f7f\u4e00\u68f5\u5b50\u6811\u6210\u4e3a\u5806 \u9700\u8981\u6ce8\u610f\u7684\u70b9\uff1a \u5de6\u53f3\u5b69\u5b50\u7684\u8fb9\u754c\u95ee\u9898 \u5faa\u73af\u7684\u7ec8\u6b62\u6761\u4ef6 void AdjustDown(Elemtype *A, int d, int len) { int dad = d; int son = 2 * dad + 1; //\u5de6\u5b69\u5b50\u7684\u4e0b\u6807 while (son <= len) { if (son + 1 <= len && A[son] < A[son + 1]) { son++; } if (A[son] > A[dad]) { swap(A[son], A[dad]); dad = son; son = 2 * dad + 1; } else { break; } } }","title":"3.2.2\u5411\u4e0b\u8c03\u6574"},{"location":"DataStruct/sort/sort/#323","text":"void HeapSort(Elemtype *A,int len) { int i; //\u5efa\u7acb\u4e00\u4e2a\u5806 for(i=len/2;i>=0;i--) { AdjustDown(A,i,len); } //\u6bcf\u6b21\u53d6\u6700\u6709\u4e00\u4e2a\u5143\u7d20\u4e0e\u5806\u9876\u5143\u7d20\u4ea4\u6362\u4f4d\u7f6e\u3002 //\u4e4b\u540e\u5c06len-1\u957f\u5ea6\u7684\u6570\u7ec4\u8fdb\u884c\u5411\u4e0b\u8c03\u6574\u3002 for(i=len;i>0;i--) { AdjustDown(A,0,i); swap(A[0],A[i]); } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #include <string.h> typedef int Elemtype; typedef struct { Elemtype *elem; int len; } SSTable; //\u521d\u59cb\u5316\u7528\u6765\u5b58\u653e\u6570\u7ec4\u548c\u6570\u7ec4\u957f\u5ea6\u7684\u7ed3\u6784\u4f53 void STInit(SSTable &ST, int len) { ST.len = len; ST.elem = (Elemtype *) malloc(sizeof(Elemtype) * ST.len); int i; srand(time(NULL)); for (i = 0; i < ST.len; i++) { ST.elem[i] = rand() % 100; } } void PrintST(SSTable ST) { for (int i = 0; i < ST.len; i++) { printf(\"%3d\", ST.elem[i]); } printf(\"\\n\"); } void swap(Elemtype &a, Elemtype &b) { Elemtype tmp; tmp = a; a = b; b = tmp; } //\u5411\u4e0b\u8c03\u6574 void AdjustDown(Elemtype *A, int d, int len) { int dad = d; int son = 2 * dad + 1; //\u5de6\u5b69\u5b50\u7684\u4e0b\u6807 while (son <= len) { if (son + 1 <= len && A[son] < A[son + 1]) { son++; } if (A[son] > A[dad]) { swap(A[son], A[dad]); dad = son; son = 2 * dad + 1; } else { break; } } } void HeapSort(Elemtype *A,int len) { int i; for(i=len/2;i>=0;i--) { AdjustDown(A,i,len); } for(i=len;i>0;i--) { AdjustDown(A,0,i); swap(A[0],A[i]); } } int main() { SSTable ST; STInit(ST, 10); // Elemtype A[10] = {3, 87, 2, 93, 78, 56, 61, 38, 12, 40}; // memcpy(ST.elem, A, sizeof(A)); PrintST(ST); HeapSort(ST.elem,9); PrintST(ST); } /Users/uichuan/Documents/library/DataStructure/codes/Sort-HeapSort/cmake-build-debug/Sort_HeapSort 7 69 95 16 75 70 89 98 12 81 7 12 16 69 70 75 81 89 95 98 Process finished with exit code 0 \u5806\u6392\u5e8f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a AdjustDown\u51fd\u6570\u7684\u5faa\u73af\u6b21\u6570\u662flog2n HeapSort\u51fd\u6570\u7b2c\u4e00\u4e2afor\u5faa\u73af\u6267\u884c\u4e86n/2\u6b21 \u7b2c\u4e00\u4e2afor\u5faa\u73af\u6267\u884c\u4e86n\u6b21 \u603b\u8ba1\u6b21\u6570\u4e3a3/2nlog2n\u6b21\uff0c\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u662fO\uff08nlog2n\uff09 \u5806\u6392\u6700\u597d\u3001\u6700\u574f\u3001\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f O ( n log2 n )\u3002 \u5806\u6392\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O (1)\uff0c\u56e0\u4e3a\u6ca1\u6709\u4f7f\u7528\u4e0e n \u76f8\u5173\u7684\u989d\u5916\u7a7a\u95f4\u3002","title":"3.2.3\u5806\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#4","text":"\u4e00\u4e2a\u6570\u7ec4\u5982\u679c\u5206\u4e24\u6bb5\u6709\u5e8f\uff0c\u90a3\u4e48\u53ef\u4ee5\u4f7f\u7528\u4e00\u6b21 \u5f52\u5e76 \u8ba9\u6574\u4e2a\u6570\u7ec4\u6709\u5e8f\u3002 \u4f8b\u5982\uff1a A={1,5,7,9, 2,3,4,8} \u5206\u4e24\u6bb5\u6709\u5e8f \u9700\u8981\u7533\u8bf7\u4e00\u5757\u989d\u5916\u7684\u7a7a\u95f4\u6765\u5b58\u50a8\u6392\u597d\u5e8f\u7684\u6570\u7ec4\u3002","title":"4.\u5f52\u5e76\u6392\u5e8f"},{"location":"DataStruct/sort/sort/#41-merge","text":"\u901a\u8fc7\u4e00\u6b21merge\u51fd\u6570\u7684\u8c03\u7528\uff0c\u53ef\u4ee5\u4f7f\u6709\u5e8f\u7684\u4e24\u4e2a\u5c0f\u6570\u7ec4\u5408\u5e76\u6210\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4\u3002 merge\u51fd\u6570\u7684\u5b9e\u73b0\uff1a void Merge(Elemtype *A, int low, int mid, int high) { static Elemtype B[N]; int i, j, k; // \u590d\u5236\u5143\u7d20 for (k = low; k <= high; k++) { B[k] = A[k]; } for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) { if (B[i] < B[j]) { A[k] = B[i++]; } else { A[k] = B[j++]; } } //\u5269\u4e0b\u4e00\u90e8\u5206\u76f4\u63a5\u653e\u5165\u6709\u5e8f\u6570\u7ec4 while (i <= mid) { A[k++] = B[i++]; } while (j <= high) { A[k++] = B[j++]; } } \u6d4b\u8bd5\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #define N 7 typedef int Elemtype; void PrintArr(Elemtype *A,int len) { for(int i=0;i<len;i++) { printf(\"%3d\",A[i]); } printf(\"\\n\"); } void Merge(Elemtype *A, int low, int mid, int high) { static Elemtype B[N]; int i, j, k; // \u590d\u5236\u5143\u7d20 for (k = low; k <= high; k++) { B[k] = A[k]; } for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) { if (B[i] < B[j]) { A[k] = B[i++]; } else { A[k] = B[j++]; } } //\u5269\u4e0b\u4e00\u90e8\u5206\u76f4\u63a5\u653e\u5165\u6709\u5e8f\u6570\u7ec4 while (i <= mid) { A[k++] = B[i++]; } while (j <= high) { A[k++] = B[j++]; } } int main() { Elemtype A[] = {1, 5, 7, 9, 2, 3, 4, 8}; PrintArr(A,8); Merge(A,0,3,7); PrintArr(A,8); return 0; }","title":"4.1 Merge\u51fd\u6570"},{"location":"DataStruct/sort/sort/#42","text":"MergeSort\u51fd\u6570\u7684\u5b9e\u73b0\uff1a \u603b\u4f53\u601d\u8def \u5c06\u6574\u4e2a\u6570\u7ec4\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206 \u5de6\u53f3\u4e24\u90e8\u5206\u5206\u522b\u9012\u5f52\u8fdb\u884c\u5f52\u5e76\u6392\u5e8f Merge\u5408\u5e76\u5de6\u53f3\u4e24\u90e8\u5206\u5df2\u7ecf\u6709\u5e8f\u7684\u5c0f\u6570\u7ec4 \u6700\u540e\u901a\u8fc7merge\u5f97\u5230\u6700\u7ec8\u7684\u6709\u5e8f\u6570\u7ec4\u3002 void MergeSort(Elemtype *A,int low,int high) { if (low<high) { int mid=(low+high)/2; MergeSort(A,low,mid); MergeSort(A,mid+1,high); Merge(A,low,mid,high); } } \u5168\u90e8\u4ee3\u7801\uff1a #include <stdio.h> #include <stdlib.h> #include <time.h> #define N 7 typedef int Elemtype; void PrintArr(Elemtype *A,int len) { for(int i=0;i<len;i++) { printf(\"%3d\",A[i]); } printf(\"\\n\"); } void Merge(Elemtype *A, int low, int mid, int high) { static Elemtype B[N]; int i, j, k; // \u590d\u5236\u5143\u7d20 for (k = low; k <= high; k++) { B[k] = A[k]; } for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) { if (B[i] < B[j]) { A[k] = B[i++]; } else { A[k] = B[j++]; } } //\u5269\u4e0b\u4e00\u90e8\u5206\u76f4\u63a5\u653e\u5165\u6709\u5e8f\u6570\u7ec4 while (i <= mid) { A[k++] = B[i++]; } while (j <= high) { A[k++] = B[j++]; } } void MergeSort(Elemtype *A,int low,int high) { if (low<high) { int mid=(low+high)/2; MergeSort(A,low,mid); MergeSort(A,mid+1,high); Merge(A,low,mid,high); } } int main() { Elemtype A[] = {1, 5, 7, 9, 2, 3, 4, 8}; printf(\"--------Merge Test--------\\n\"); PrintArr(A,8); Merge(A,0,3,7); PrintArr(A,8); printf(\"--------MergeSort Test--------\\n\"); Elemtype Arr[] = {2,1,5,4,6,9,7,3}; PrintArr(Arr,8); MergeSort(Arr,0,7); PrintArr(Arr,8); return 0; } \u6d4b\u8bd5\u7ed3\u679c\uff1a /Users/uichuan/Documents/library/DataStructure/codes/Sort-MergeSort/cmake-build-debug/Sort_MergeSort --------Merge Test-------- 1 5 7 9 2 3 4 8 1 2 3 4 5 7 8 9 --------MergeSort Test-------- 2 1 5 4 6 9 7 3 1 2 3 4 5 6 7 9 Process finished with exit code 0 \u65f6\u95f4\u590d\u6742\u5ea6\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a MergeSort\u51fd\u6570\u7684\u9012\u5f52\u6b21\u6570\u4e3alog2n\uff0c Merge\u51fd\u6570\u5faa\u73af\u4e86n\u6b21\uff0c\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nlog2n) \u5f52\u5e76\u6392\u5e8f\u6700\u597d\uff0c\u6700\u574f\uff0c\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662fO(nlog2n) \u5f52\u5e76\u6392\u5e8f\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(n)\uff0c\u56e0\u4e3a\u5728Merge\u51fd\u6570\u7684\u8fc7\u7a0b\u4e2d\u4f7f\u7528\u4e86\u53e6\u5916\u7684\u4e00\u4e2a\u7b49\u957f\u6570\u7ec4\u3002","title":"4.2 \u5f52\u5e76\u6392\u5e8f\u7684\u9012\u5f52\u5b9e\u73b0"},{"location":"DataStruct/sort/sort/#5","text":"","title":"5.\u6392\u5e8f\u7b97\u6cd5\u65f6\u95f4&amp;\u7a7a\u95f4\u590d\u6742\u5ea6\u6c47\u603b"},{"location":"DataStruct/stack/stack/","text":"\u6808 \u6808\uff1a\u53ea\u5141\u8bb8\u5728\u4e00\u6bb5\u8fdb\u884c \u63d2\u5165\u6216\u8005\u5220\u9664 \u64cd\u4f5c\u7684\u7ebf\u6027\u8868 \uff08First in last out\uff09 1.\u6808\u7684\u987a\u5e8f\u8868\u793a int main(){ SqStack S; InitStack(S); Push(S,1); Push(S,2); Push(S,3); ElemType res; Pop(S,res); printf(\"pop_res->%d\\n\",res); return 0; } \u521d\u59cb\u5316\u6808 #include <stdio.h> #include <stdlib.h> #define MaxSize 50 typedef int ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S) { S.top=-1; } \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a bool StackEmpty(SqStack S) { if(S.top==-1) { return true; } else{ return false; } } \u5411\u6808\u4e2d\u589e\u52a0\u5143\u7d20 bool Push(SqStack &S,ElemType x) { if(S.top==MaxSize-1) { return false; } S.data[++S.top]=x; return true; } \u53d6\u6808\u9876\u5143\u7d20 bool GetTop(SqStack S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top]; return true; } \u5f39\u51fa\u6808\u9876\u5143\u7d20 bool Pop(SqStack &S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top--]; return true; } 2.\u6808\u7684\u94fe\u5f0f\u8868\u793a #include <stdio.h> #include <stdlib.h> typedef int element_type; typedef struct LStack{ element_type data; struct LStack *next; }LStack,*LinkStack; int main() { LinkStack S; InitStack(S); element_type insert_num_1,insert_num_2,insert_num_3; insert_num_1 = 1; insert_num_2 = 2; insert_num_3 = 3; Push(S,insert_num_1); Push(S,insert_num_2); Push(S,insert_num_3); PrintLStack(S); } bool InitStack(LinkStack &S) { S = (LinkStack) malloc(sizeof (LStack)); S->next = NULL; return true; } bool Push(LinkStack &S,element_type e) { LinkStack new_one; new_one = (LinkStack) malloc(sizeof (LStack)); new_one->data = e; new_one->next = S->next; S->next = new_one; } void PrintLStack(LinkStack S) { LinkStack point; point = S->next; while (point!=NULL) { printf(\"%3d\\n\",point->data); point = point->next; } } 3.\u6808\u7684\u5e94\u7528-\u62ec\u53f7\u5339\u914d \u5b9e\u73b0\u4ee3\u7801\uff1a #include <stdio.h> #define MaxSize 50 typedef char ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S) { S.top=-1; } bool StackEmpty(SqStack S) { if(S.top==-1) { return true; } else{ return false; } } bool Push(SqStack &S,ElemType x) { if(S.top==MaxSize-1) { return false; } S.data[++S.top]=x; return true; } bool Pop(SqStack &S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top--]; return true; } bool GetTop(SqStack S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top]; return true; } bool bracketCheck(char str[],int length) { SqStack S; InitStack(S); for(int i=0;i<length;i++) { if(str[i] == '(' || str[i] == '[' || str[i] == '{') { Push(S,str[i]); } else{ if(StackEmpty(S)) { return false; } char topElem; Pop(S,topElem); if(str[i] == ')' && topElem != '(') { return false; } if(str[i] == ']' && topElem != '[') { return false; } if(str[i] == '}' && topElem != '{') { return false; } } } return StackEmpty(S); } int main(){ bool res; res = bracketCheck(\"()()(\",5); if(res) { printf(\"match\\n\"); } else{ printf(\"fail\\n\"); } return 0; }","title":"3.\u6808"},{"location":"DataStruct/stack/stack/#_1","text":"\u6808\uff1a\u53ea\u5141\u8bb8\u5728\u4e00\u6bb5\u8fdb\u884c \u63d2\u5165\u6216\u8005\u5220\u9664 \u64cd\u4f5c\u7684\u7ebf\u6027\u8868 \uff08First in last out\uff09","title":"\u6808"},{"location":"DataStruct/stack/stack/#1","text":"int main(){ SqStack S; InitStack(S); Push(S,1); Push(S,2); Push(S,3); ElemType res; Pop(S,res); printf(\"pop_res->%d\\n\",res); return 0; }","title":"1.\u6808\u7684\u987a\u5e8f\u8868\u793a"},{"location":"DataStruct/stack/stack/#_2","text":"#include <stdio.h> #include <stdlib.h> #define MaxSize 50 typedef int ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S) { S.top=-1; }","title":"\u521d\u59cb\u5316\u6808"},{"location":"DataStruct/stack/stack/#_3","text":"bool StackEmpty(SqStack S) { if(S.top==-1) { return true; } else{ return false; } }","title":"\u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a"},{"location":"DataStruct/stack/stack/#_4","text":"bool Push(SqStack &S,ElemType x) { if(S.top==MaxSize-1) { return false; } S.data[++S.top]=x; return true; }","title":"\u5411\u6808\u4e2d\u589e\u52a0\u5143\u7d20"},{"location":"DataStruct/stack/stack/#_5","text":"bool GetTop(SqStack S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top]; return true; }","title":"\u53d6\u6808\u9876\u5143\u7d20"},{"location":"DataStruct/stack/stack/#_6","text":"bool Pop(SqStack &S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top--]; return true; }","title":"\u5f39\u51fa\u6808\u9876\u5143\u7d20"},{"location":"DataStruct/stack/stack/#2","text":"#include <stdio.h> #include <stdlib.h> typedef int element_type; typedef struct LStack{ element_type data; struct LStack *next; }LStack,*LinkStack; int main() { LinkStack S; InitStack(S); element_type insert_num_1,insert_num_2,insert_num_3; insert_num_1 = 1; insert_num_2 = 2; insert_num_3 = 3; Push(S,insert_num_1); Push(S,insert_num_2); Push(S,insert_num_3); PrintLStack(S); } bool InitStack(LinkStack &S) { S = (LinkStack) malloc(sizeof (LStack)); S->next = NULL; return true; } bool Push(LinkStack &S,element_type e) { LinkStack new_one; new_one = (LinkStack) malloc(sizeof (LStack)); new_one->data = e; new_one->next = S->next; S->next = new_one; } void PrintLStack(LinkStack S) { LinkStack point; point = S->next; while (point!=NULL) { printf(\"%3d\\n\",point->data); point = point->next; } }","title":"2.\u6808\u7684\u94fe\u5f0f\u8868\u793a"},{"location":"DataStruct/stack/stack/#3-","text":"\u5b9e\u73b0\u4ee3\u7801\uff1a #include <stdio.h> #define MaxSize 50 typedef char ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S) { S.top=-1; } bool StackEmpty(SqStack S) { if(S.top==-1) { return true; } else{ return false; } } bool Push(SqStack &S,ElemType x) { if(S.top==MaxSize-1) { return false; } S.data[++S.top]=x; return true; } bool Pop(SqStack &S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top--]; return true; } bool GetTop(SqStack S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top]; return true; } bool bracketCheck(char str[],int length) { SqStack S; InitStack(S); for(int i=0;i<length;i++) { if(str[i] == '(' || str[i] == '[' || str[i] == '{') { Push(S,str[i]); } else{ if(StackEmpty(S)) { return false; } char topElem; Pop(S,topElem); if(str[i] == ')' && topElem != '(') { return false; } if(str[i] == ']' && topElem != '[') { return false; } if(str[i] == '}' && topElem != '{') { return false; } } } return StackEmpty(S); } int main(){ bool res; res = bracketCheck(\"()()(\",5); if(res) { printf(\"match\\n\"); } else{ printf(\"fail\\n\"); } return 0; }","title":"3.\u6808\u7684\u5e94\u7528-\u62ec\u53f7\u5339\u914d"},{"location":"DataStruct/tree/tree/","text":"\u6811 (Tree) \u6811\u662fn\uff08n>=0\uff09\u4e2a\u8282\u70b9\u7684\u6709\u9650\u96c6\uff0c\u5f53n=0\u65f6\uff0c\u79f0\u4e3a\u7a7a\u6811\uff0c \u200b \u5728\u4efb\u610f\u4e00\u68f5\u975e\u7a7a\u6811\u4e2d\u5e94\u8be5\u6ee1\u8db3\uff1a \u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u7279\u5b9a\u7684\u79f0\u4e3a\u6839\u7684\u8282\u70b9 \u5f53n>1\u65f6\uff0c\u5176\u4f59\u8282\u70b9\u53ef\u4ee5\u5206\u4e3am\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u7684\u6709\u9650\u96c6 T1,T2,...,Tm\uff0c\u6bcf\u4e2a\u96c6\u5408\u672c\u8eab\u53c8\u662f\u4e00\u68f5\u6811\uff0c\u5e76\u4e14\u79f0\u4e3a\u6839\u7684\u5b50\u6811 \u200b \uff08\u4ee5\u4e0a\u662f\u6811\u7684\u9012\u5f52\u5b9a\u4e49\uff09 \u6811\u4f5c\u4e3a\u4e00\u79cd\u903b\u8f91\u7ed3\u6784\uff0c\u540c\u65f6\u4e5f\u662f\u4e00\u79cd\u5206\u5c42\u7ed3\u6784 - \u6811\u7684\u6839\u8282\u70b9\u6ca1\u6709\u524d\u9a71\uff0c\u9664\u53bb\u6839\u8282\u70b9\u4ee5\u5916\uff0c\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u524d\u9a71 - \u6811\u7684\u6240\u6709\u8282\u70b9\u90fd\u53ef\u4ee5\u67090\u4e2a\u6216\u8005\u591a\u4e2a\u540e\u7ee7 1. \u524d\u620f \u4e8c\u53c9\u6811\u662f\u6811\uff0c\u4f46\u4e8c\u53c9\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u4e0a\u6700\u591a\u6709\u4e24\u68f5\u5b50\u6811\uff08\u5373\u4e8c\u53c9\u6811\u4e2d\u4e0d\u5b58\u5728\u5ea6\u5927\u4e8e2\u7684\u8282\u70b9\uff09\uff0c \u5e76\u4e14\u4e8c\u53c9\u6811\u7684\u5b50\u6811\u6709\u5de6\u53f3\u4e4b\u5206\uff0c\u4e0d\u80fd\u98a0\u5012\u987a\u5e8f\uff0c \u540c\u65f6\uff0c\u4e8c\u53c9\u6811\u4e5f\u9075\u5b88\u6811\u7684\u9012\u5f52\u5b9a\u4e49 \u6ee1\u4e8c\u53c9\u6811\u4e0e\u5b8c\u5168\u4e8c\u53c9\u6811 \u6bcf\u4e00\u5c42\u7684\u8282\u70b9\u6570\u90fd\u6ee1\u8db32^(\u5c42\u6570-1)\uff0c\u5c31\u662f\u6ee1\u4e8c\u53c9\u6811 2. \u4e8c\u53c9\u6811\u7684\u94fe\u5f0f\u5b58\u50a8 \u200b \u6811\u8282\u70b9\u7684\u6570\u636e\u7ed3\u6784 \u200b \u4f7f\u7528\u94fe\u5f0f\u7ed3\u6784\u5b9e\u73b0 typedef char BiElemtype typedef struct BiTNode{ BiElemtype c; struct BiTNode *lchild; struct BiTNode *rchild; }BiTNOde,*BiTree; typedef struct tage{ BiTree p; struct tag *pnext; }tag_t,*ptag_t; 3.\u4e8c\u53c9\u6811\u7684\u5efa\u7acb\u8fc7\u7a0b \u5c42\u6b21\u5efa\u7acb\u4e8c\u53c9\u6811\uff0c\u5fc5\u987b\u4f7f\u7528 \u8f85\u52a9\u961f\u5217 \u6b65\u9aa4\u5927\u81f4\u5982\u4e0b\uff1a \u58f0\u660e\u4e8c\u53c9\u6811\u7684\u65b0\u7ed3\u70b9\uff0c\u6811\u6839\uff08\u7ed3\u6784\u4f53\u6307\u9488\uff09 \u58f0\u660e\u8f85\u52a9\u961f\u5217\u7684\u5934\u8282\u70b9\uff0c\u5c3e\u8282\u70b9\uff0c\u65b0\u8282\u70b9\uff0c\u5f53\u524d\u8282\u70b9\uff08\u7ed3\u6784\u4f53\u6307\u9488\uff09 \u8fdb\u5165\u5faa\u73af \u4e3a\u8f85\u52a9\u961f\u5217\u63d2\u5165\u65b0\u7684\u8f85\u52a9\u961f\u5217\u8282\u70b9\uff0c\u540c\u65f6\u5c3e\u6307\u9488\u540e\u79fbptail=ptail->next \u6bcf\u6b21\u5224\u65ad\u5f53\u524d\u63d2\u5165\u7684\u8282\u70b9\uff08pcur\uff09\u6307\u5411\u7684\u8282\u70b9\u7684\u5de6\u53f3\u5b69\u5b50\u8282\u70b9\u662f\u5426\u4e3a\u7a7a \u5f53\u53f3\u5b69\u5b50\u8282\u70b9\u88ab\u63d2\u5165\u540e\uff0cpcur=pcur->next \u4ee3\u7801\uff1a function.h // // Created by \u738b\u4e00\u5ddd on 2022/11/17. // #ifndef CREATE_TREE_FUNCTION_H #define CREATE_TREE_FUNCTION_H #endif //CREATE_TREE_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct BiTNode { BiElemType c;//c \u5c31\u662f\u4e66\u7c4d\u4e0a\u7684 data struct BiTNode *lchild; struct BiTNode *rchild; struct BiTNode *lchild; } BiTNode, *BiTree; //tag \u7ed3\u6784\u4f53\u662f\u8f85\u52a9\u961f\u5217\u4f7f\u7528\u7684 typedef struct tag { BiTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; } tag_t, *ptag_t; main.cpp #include \"function.h\" int main() { BiTree pnew; char c; //\u521d\u59cb\u5316\u6811\u6839\u4e3a\u7a7a BiTree tree = NULL; //\u8f85\u52a9\u961f\u5217 ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (BiTree) calloc(1, sizeof(BiTNode)); pnew->c = c; //\u7ed9\u8f85\u52a9\u961f\u5217\u8282\u70b9\u7533\u8bf7\u7a7a\u95f4 listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else { ptail->pnext = listpnew; ptail = listpnew; } if (NULL == pcur->p->lchild) { pcur->p->lchild = pnew; } else if (NULL == pcur->p->rchild) { pcur->p->rchild = pnew; pcur = pcur->pnext; } } return 0; } 4.\u4e8c\u53c9\u6811\u7684\u904d\u5386 1.\u904d\u5386\u7684\u9012\u5f52\u7b97\u6cd5 \u5982\u679c\u4e8c\u53c9\u6811\u4e3a\u7a7a \u8bbf\u95ee\u6839\u8282\u70b9 \u524d\u5e8f\u904d\u5386\u5de6\u5b50\u6811 \u524d\u5e8f\u904d\u5386\u53f3\u5b50\u6811 \u524d\u5e8f\u904d\u5386 void preOrder(BiTree p) { if(p!=NULL) { putchar(p->c); preOrder(p->lchild); preOrder(p->rchild); } } \u4e2d\u5e8f\u904d\u5386 void InOrder(BiTree p) { if(p!=NULL) { InOrder(p->lchild); putchar(p->c); InOrder(p->rchild); } } \u540e\u5e8f\u904d\u5386 void PostOrder(BiTree p) { if(p!=NULL) { PostOrder(p->lchild); PostOrder(p->rchild); putchar(p->c); } } 2.\u4e2d\u5e8f\u904d\u5386\u7684\u975e\u9012\u5f52\u7b97\u6cd5 \u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386\u7684\u8fc7\u7a0b\uff1a \u6cbf\u7740\u6839\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u8282\u70b9\u6df1\u5165\u5e76\u4e14\u4f9d\u6b21\u5165\u6808\uff0c\u76f4\u5230\u5de6\u5b69\u5b50\u8282\u70b9\u4e3a\u7a7a \u8f93\u51fa\u6b64\u65f6\u7684\u6808\u9876\u5143\u7d20\u5e76\u4e14pop\u6808\u9876\u5143\u7d20 \u5982\u679c\u53f3\u5b69\u5b50\u8282\u70b9\u4e3a\u7a7a\u5219\u6267\u884cstep2\uff0c\u5982\u679c\u53f3\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u627e\u53f3\u5b69\u5b50\u7684\u6700\u5de6\u8282\u70b9 \u5faa\u73af\u7ed3\u675f\uff0c\u6240\u6709\u5143\u7d20\u51fa\u6808 \u4ee3\u7801\uff1a \u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386 void InOrder(BiTree T) { SqStack S; InitStack(S); BiTree p=T; while (p||!StackEmpty(S)) { if(p) { Push(S,p); p=p->lchild; } else{ Pop(S,p); putchar(p->c); p=p->rchild; } } } \u8f85\u52a9\u6808 #include <stdio.h> #include <stdlib.h> #define MaxSize 50 typedef BiTree ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S); bool StackEmpty(SqStack S); bool Push(SqStack &S,ElemType x); bool Pop(SqStack &S,ElemType &x); bool GetTop(SqStack S,ElemType &x); \u5168\u90e8\u4ee3\u7801\uff1a function.h // // Created by \u738b\u4e00\u5ddd on 2022/11/18. // #ifndef TREE_NONRECURSIVE_FUNCTION_H #define TREE_NONRECURSIVE_FUNCTION_H #endif //TREE_NONRECURSIVE_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct BiTNode { BiElemType c; struct BiTNode *rchild; struct BiTNode *lchild; } BiTNode, *BiTree; typedef struct tag { BiTree p; struct tag *pnext; } tag_t, *ptag_t; #include <stdio.h> #include <stdlib.h> #define MaxSize 50 typedef BiTree ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S); bool StackEmpty(SqStack S); bool Push(SqStack &S,ElemType x); bool Pop(SqStack &S,ElemType &x); bool GetTop(SqStack S,ElemType &x); stack.cpp #include \"function.h\" void InitStack(SqStack &S) { S.top=-1; } bool StackEmpty(SqStack S) { if(S.top==-1) { return true; } else{ return false; } } bool Push(SqStack &S,ElemType x) { if(S.top==MaxSize-1) { return false; } S.data[++S.top]=x; return true; } bool Pop(SqStack &S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top--]; return true; } bool GetTop(SqStack S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top]; return true; } main.cpp #include \"function.h\" //\u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386 void InOrder(BiTree T) { SqStack S; InitStack(S); BiTree p=T; while (p||!StackEmpty(S)) { if(p) { Push(S,p); p=p->lchild; } else{ Pop(S,p); putchar(p->c); p=p->rchild; } } } int main() { BiTree pnew; BiTree tree=NULL; ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; char c; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (BiTree) calloc(1, sizeof(BiTNode)); pnew->c = c; listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else{ ptail->pnext=listpnew; ptail=listpnew; } if(NULL== pcur->p->lchild) { pcur->p->lchild=pnew; } else if(NULL== pcur->p->rchild) { pcur->p->rchild=pnew; pcur=pcur->pnext; } } InOrder(tree); return 0; } 3.\u5c42\u5e8f\u904d\u5386\u7b97\u6cd5 \u5c42\u6b21\u904d\u5386\u5fc5\u987b\u4f7f\u7528\u8f85\u52a9\u961f\u5217 \u5c42\u5e8f\u904d\u5386\u7684\u8fc7\u7a0b\uff1a \u5c06\u6811\u6839\u5165\u961f \u8fdb\u5165\u5faa\u73af\uff0c\u6bcf\u6b21\u5faa\u73af\u961f\u5217\u51fa\u961f\u4e00\u6b21 \u51fa\u961f\u4e4b\u540e\u5224\u65ad\u5de6\u53f3\u5b50\u6811\u662f\u5426\u4e3a\u7a7a\uff0c\u4e0d\u4e3a\u7a7a\u5219\u5165\u961f \u5faa\u73af\u7684\u6761\u4ef6\u662f\u961f\u5217\u4e2d\u8fd8\u6709\u8282\u70b9\uff08\u5143\u7d20\uff09 \u5c42\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u4f1a\u5c06\u5143\u7d20\u6309\u7167 \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 \u8f93\u51fa \u4ee3\u7801\uff1a \u5c42\u5e8f\u904d\u5386\u51fd\u6570 void LevelOrder(BiTree T) { LinkQueue Q; InitQueue(Q); BiTree p; //\u7528\u6765\u63a5\u6536\u51fa\u961f\u7684\u5143\u7d20 EnQueue(Q,T); while (!IsEmpty(Q)) { DeQueue(Q,p); putchar(p->c); if(p->lchild) { EnQueue(Q,p->lchild); } if(p->rchild) { EnQueue(Q,p->rchild); } } } function.h // // Created by \u738b\u4e00\u5ddd on 2022/11/18. // #ifndef TREE_HIERARCHICTRAVERSAL_FUNCTION_H #define TREE_HIERARCHICTRAVERSAL_FUNCTION_H #endif //TREE_HIERARCHICTRAVERSAL_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct BiTNode { BiElemType c; struct BiTNode *rchild; struct BiTNode *lchild; } BiTNode, *BiTree; typedef struct tag { BiTree p; struct tag *pnext; } tag_t, *ptag_t; //\u961f\u5217\u7684\u7ed3\u6784\u4f53 typedef BiTree ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode, *LinkList; typedef struct LinkQueue { LinkNode *front, *rear; } LinkQueue; void InitQueue(LinkQueue &Q); void EnQueue(LinkQueue &Q, ElemType x); bool IsEmpty(LinkQueue Q); bool DeQueue(LinkQueue &Q, ElemType &element); main.cpp #include \"function.h\" void PreOrder(BiTree p) { if(p!=NULL) { putchar(p->c); PreOrder(p->lchild); PreOrder(p->rchild); } } void LevelOrder(BiTree T) { LinkQueue Q; InitQueue(Q); BiTree p; EnQueue(Q,T); while (!IsEmpty(Q)) { DeQueue(Q,p); putchar(p->c); if(p->lchild) { EnQueue(Q,p->lchild); } if(p->rchild) { EnQueue(Q,p->rchild); } } } int main() { BiTree pnew; BiTree tree=NULL; ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; char c; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (BiTree) calloc(1, sizeof(BiTNode)); pnew->c = c; listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else{ ptail->pnext=listpnew; ptail=listpnew; } if(NULL== pcur->p->lchild) { pcur->p->lchild=pnew; } else if(NULL== pcur->p->rchild) { pcur->p->rchild=pnew; pcur=pcur->pnext; } } printf(\"-------PreOrder-------\\n\"); PreOrder(tree); printf(\"\\n\"); printf(\"-------LevelOrder-------\\n\"); LevelOrder(tree); printf(\"\\n\"); return 0; } 5.tree-2014-41 41.(13\u5206) \u4e8c\u53c9\u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6(WPL)\u662f\u4e8c\u53c9\u6811\u4e2d\u6240\u6709\u53f6\u7ed3\u70b9\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6 \u4e4b\u548c\u3002\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811 T\uff0c\u91c7\u7528\u4e8c\u53c9\u94fe\u8868\u5b58\u50a8\uff0c\u7ed3\u70b9\u7ed3\u6784\u5982\u4e0b: left|weight|right \u5176\u4e2d\u53f6\u8282\u70b9\u7684weight\u57df\u4fdd\u5b58\u8be5\u8282\u70b9\u7684\u975e\u8d1f\u6743\u503c\u3002\u8bberoot\u4e3a\u6307\u5411T\u7684\u6839\u8282\u70b9\u7684\u6307\u9488\uff0c\u8bf7\u8bbe\u8ba1\u6c42T\u7684WPL\u7b97\u6cd5\uff0c\u8981\u6c42\uff1a \u7ed9\u51fa\u7b97\u6cd5\u7684\u57fa\u672c\u8bbe\u8ba1\u601d\u60f3 \u4f7f\u7528C/C++\u8bed\u8a00\uff0c\u7ed9\u51fa\u4e8c\u53c9\u6811\u8282\u70b9\u7684\u6570\u636e\u7c7b\u578b\u5b9a\u4e49 \u6839\u636e\u8bbe\u8ba1\u601d\u60f3\uff0c\u91c7\u7528C/C++\u8bed\u8a00\u63cf\u8ff0\u7b97\u6cd5 \u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6(Weighted Path Length of Tree\uff0c\u7b80\u8bb0\u4e3a WPL \u8003\u67e5\u4e8c\u53c9\u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6\uff0c\u4e8c\u53c9\u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6\u4e3a\u6bcf\u4e2a\u53f6\u5b50\u7ed3\u70b9\u7684\u6df1\u5ea6\u4e0e\u6743\u503c\u4e4b\u79ef\u7684\u603b\u548c\uff0c\u53ef\u4ee5\u4f7f\u7528\u5148\u5e8f\u904d\u5386\u6216\u5c42\u6b21\u904d\u5386\u89e3\u51b3\u95ee\u9898\u3002 \u7b97\u6cd5\u7684\u8bbe\u8ba1\u601d\u60f3 \u57fa\u4e8e\u5148\u5e8f\u9012\u5f52\u904d\u5386\u7684\u7b97\u6cd5\u601d\u60f3\u662f\u7528\u4e00\u4e2a static \u53d8\u91cf\u8bb0\u5f55 wpl\uff0c \u628a\u6bcf\u4e2a\u7ed3\u70b9\u7684\u6df1\u5ea6\u4f5c\u4e3a \u9012\u5f52\u51fd\u6570\u7684\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\uff0c \u7b97\u6cd5\u6b65\u9aa4\u5982\u4e0b: \u82e5\u8be5\u7ed3\u70b9\u662f\u53f6\u5b50\u7ed3\u70b9\uff0c\u90a3\u4e48\u53d8\u91cf wpl \u52a0\u4e0a\u8be5\u7ed3\u70b9\u7684\u6df1\u5ea6\u4e0e\u6743\u503c\u4e4b\u79ef; \u82e5\u8be5\u7ed3\u70b9\u975e\u53f6\u5b50\u7ed3\u70b9\uff0c\u90a3\u4e48\u82e5\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u5bf9\u5de6\u5b50\u6811\u8c03\u7528\u9012\u5f52\u7b97\u6cd5\uff0c \u82e5\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c \u5bf9\u53f3\u5b50\u6811\u8c03\u7528\u9012\u5f52\u7b97\u6cd5\uff0c\u6df1\u5ea6\u53c2\u6570\u5747\u4e3a\u672c\u7ed3\u70b9\u7684\u6df1\u5ea6\u53c2\u6570\u52a0\u4e00; \u6700\u540e\u8fd4\u56de\u8ba1\u7b97\u51fa\u7684 wpl \u5373\u53ef\u3002 \u4e8c\u53c9\u6811\u8282\u70b9\u7684\u6570\u636e\u7c7b\u578b\u5b9a\u4e49 typedef int BiElemType; typedef struct BiTNode{ BiElemType weight; struct BiTNode *lchild; struct BiTNode *rchild; }BiTNode,*BiTree; C++\u63cf\u8ff0 function.h // // Created by 41507 on 2022/11/9. // #ifndef INC_1_TREE_FUNCTION_H #define INC_1_TREE_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef int BiElemType; typedef struct BiTNode{ BiElemType weight;//c\u5c31\u662f\u4e66\u7c4d\u4e0a\u7684data struct BiTNode *lchild; struct BiTNode *rchild; }BiTNode,*BiTree; //tag\u7ed3\u6784\u4f53\u662f\u8f85\u52a9\u961f\u5217\u4f7f\u7528\u7684 typedef struct tag{ BiTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; }tag_t,*ptag_t; #endif //INC_1_TREE_FUNCTION_H main.cpp #include \"function.h\" //int wpl=0; //\u524d\u5e8f\u904d\u5386\uff0c\u4e5f\u53eb\u5148\u5e8f\u904d\u5386\uff0c\u4e5f\u662f\u6df1\u5ea6\u4f18\u5148\u904d\u5386 int PreOrder(BiTree p,int deep) { static int wpl=0;//\u53ea\u4f1a\u521d\u59cb\u5316\u4e00\u6b21 if(p!=NULL) { // printf(\"ele%c--%d\\n\", p->c,deep); if(p->lchild==NULL&&p->rchild==NULL) { wpl=wpl+p->weight*deep; } PreOrder(p->lchild,deep+1);//\u6253\u5370\u5de6\u5b50\u6811 PreOrder(p->rchild,deep+1);//\u6253\u5370\u53f3\u5b50\u6811 } return wpl; } int main() { BiTree pnew;//\u7528\u6765\u6307\u5411\u65b0\u7533\u8bf7\u7684\u6811\u7ed3\u70b9 BiTree tree=NULL;//tree\u662f\u6307\u5411\u6811\u6839\u7684\uff0c\u4ee3\u8868\u6811 char c; ptag_t phead=NULL,ptail=NULL,listpnew=NULL,pcur; //abcdefghij while(scanf(\"%c\",&c)) { if(c=='\\n') { break;//\u8bfb\u53d6\u5230\u6362\u884c\u5c31\u7ed3\u675f } //calloc\u7533\u8bf7\u7684\u7a7a\u95f4\u5927\u5c0f\u662f\u4e24\u4e2a\u53c2\u6570\u76f4\u63a5\u76f8\u4e58\uff0c\u5e76\u5bf9\u7a7a\u95f4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u8d4b\u503c\u4e3a0 pnew= (BiTree)calloc(1,sizeof(BiTNode)); pnew->weight=c; listpnew= (ptag_t)calloc(1,sizeof(tag_t));//\u7ed9\u961f\u5217\u7ed3\u70b9\u7533\u8bf7\u7a7a\u95f4 listpnew->p=pnew; //\u5982\u679c\u662f\u6811\u7684\u7b2c\u4e00\u4e2a\u7ed3\u70b9 if(NULL==tree) { tree=pnew;//tree\u6307\u5411\u6811\u7684\u6839\u7ed3\u70b9 phead=listpnew;//\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u5373\u662f\u961f\u5217\u5934\uff0c\u4e5f\u662f\u961f\u5217\u5c3e ptail=listpnew; pcur=listpnew;//pcur\u8981\u6307\u5411\u8981\u8fdb\u5165\u6811\u7684\u7236\u4eb2\u5143\u7d20 }else{ //\u8ba9\u5143\u7d20\u5148\u5165\u961f\u5217 ptail->pnext=listpnew; ptail=listpnew; //\u63a5\u4e0b\u6765\u628a\u7ed3\u70b9\u653e\u5165\u6811\u4e2d if(NULL==pcur->p->lchild) { pcur->p->lchild=pnew;//pcur->p\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c31\u653e\u5165\u5de6\u5b69\u5b50 }else if(NULL==pcur->p->rchild) { pcur->p->rchild=pnew;//pcur->p\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c31\u653e\u5165\u53f3\u5b69\u5b50 pcur=pcur->pnext;//\u5f53\u524d\u7ed3\u70b9\u5de6\u53f3\u5b69\u5b50\u90fd\u6709\u4e86\uff0cpcur\u5c31\u6307\u5411\u4e0b\u4e00\u4e2a } } } printf(\"--------PreOrder----------\\n\");//\u4e5f\u53eb\u5148\u5e8f\u904d\u5386\uff0c\u5148\u6253\u5370\u5f53\u524d\u7ed3\u70b9\uff0c\u6253\u5370\u5de6\u5b69\u5b50\uff0c\u6253\u5370\u53f3\u5b69\u5b50 printf(\"wpl=%d\\n\",PreOrder(tree,0));//wpl\u7edf\u8ba1\u7684\u662f\u8def\u5f84\uff0c\u56e0\u6b64\u4e00\u5f00\u59cb\u5e94\u8be5\u4f20\u5165\u7684\u662f0 return 0; } 6.\u7ebf\u7d22\u4e8c\u53c9\u6811 \u7ebf\u7d22\u4e8c\u53c9\u6811\u7684\u4f5c\u7528\u662f \u65b9\u4fbf\u4ece\u4e00\u4e2a\u6307\u5b9a\u8282\u70b9\u51fa\u53d1\uff0c\u627e\u5230\u5176\u524d\u9a71\uff0c\u540e\u7ee7\uff0c\u4fbf\u4e0e\u4e8c\u53c9\u6811\u904d\u5386 \u5c06\u4e8c\u53c9\u6811\u6309\u7167\u67d0\u79cd\u904d\u5386\u89c4\u5219\uff08\u524d/\u4e2d/\u540e\u5e8f\u904d\u5386\uff09\u8f93\u51fa\u540e\uff0c\u5f97\u5230\u7684\u7ebf\u6027\u5e8f\u5217\uff0c \u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u6709\u4e00\u4e2a\u76f4\u63a5\u524d\u9a71\u548c\u76f4\u63a5\u540e\u7ee7 \u4f8b\u5982\uff1a 6.1\u7ebf\u7d22\u5316\u8fc7\u7a0b \u7ebf\u7d22\u4e8c\u53c9\u6811\u7684\u5b58\u50a8\u7ed3\u6784\u4e0e\u8f85\u52a9\u961f\u5217 typedef char BiElemType; typedef struct ThreadNode { BiElemType c; struct ThreadNode *rchild; struct ThreadNode *lchild; int ltag, rtag; } ThreadNode, *ThreadTree; typedef struct tag { ThreadTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; } tag_t, *ptag_t; \u5168\u5c40\u53d8\u91cf\uff1a ThreadNode *target; ThreadNode *pre = NULL; ThreadNode *final = NULL; \u7ebf\u7d22\u5316\uff1a // \u8bbf\u95ee\u8282\u70b9q\uff0c\u627e\u5b83\u7684\u524d\u9a71\u8282\u70b9pre void Visit(ThreadTree q) { if (q->lchild == NULL) { q->lchild = pre; q->ltag = 1; } if (pre != NULL && pre->rchild == NULL) { pre->rchild = q; pre->rtag = 1; } pre=q; } void InThread(ThreadTree T) { if (T != NULL) { InThread(T->lchild); Visit(T); InThread(T->rchild); } } void CreateInThread(ThreadTree T) { pre=NULL; if(T!=NULL) { InThread(T); if(pre->rchild == NULL) { pre->rtag = 1; } } } \u4ee5\u5982\u4e0b\u7684\u4e8c\u53c9\u6811\u4e3a\u4f8b\uff1a 6.2\u7ebf\u7d22\u5316\u5168\u90e8\u4ee3\u7801 #include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct ThreadNode { BiElemType c;//c \u5c31\u662f\u4e66\u7c4d\u4e0a\u7684 data struct BiTNode *lchild; struct ThreadNode *rchild; struct ThreadNode *lchild; int ltag, rtag; } ThreadNode, *ThreadTree; //tag \u7ed3\u6784\u4f53\u662f\u8f85\u52a9\u961f\u5217\u4f7f\u7528\u7684 typedef struct tag { ThreadTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; } tag_t, *ptag_t; ThreadNode *target; ThreadNode *pre = NULL; ThreadNode *final = NULL; // \u8bbf\u95ee\u8282\u70b9q\uff0c\u627e\u5b83\u7684\u524d\u9a71\u8282\u70b9pre void Visit(ThreadTree q) { if (q->lchild == NULL) { q->lchild = pre; q->ltag = 1; } if (pre != NULL && pre->rchild == NULL) { pre->rchild = q; pre->rtag = 1; } pre=q; } void InThread(ThreadTree T) { if (T != NULL) { InThread(T->lchild); Visit(T); InThread(T->rchild); } } void CreateInThread(ThreadTree T) { pre=NULL; if(T!=NULL) { InThread(T); if(pre->rchild == NULL) { pre->rtag = 1; } } } void preOrder(ThreadTree p) { if (p != NULL) { putchar(p->c); preOrder(p->lchild); preOrder(p->rchild); } } int main() { ThreadTree pnew; ThreadTree tree = NULL; char c; ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (ThreadTree) calloc(1, sizeof(ThreadNode)); pnew->c = c; pnew->rtag = 0; pnew->ltag = 0; listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else { ptail->pnext = listpnew; ptail = listpnew; } if (NULL == pcur->p->lchild) { pcur->p->lchild = pnew; } else if (NULL == pcur->p->rchild) { pcur->p->rchild = pnew; pcur = pcur->pnext; } } preOrder(tree); CreateInThread(tree); return 0; } 6.3 \u5148\u5e8f\u7ebf\u7d22\u5316\u4e2d\u65e0\u9650\u5faa\u73af\u95ee\u9898 \u5148\u5e8f\u904d\u5386\u5e8f\u5217\uff1a A BDGE CF \u5982\u679c\u8bbf\u95ee\u5230D\uff0c\u5219\u4f1a\u51fa\u73b0 D->lchild=B \u9020\u6210\u65e0\u9650\u5faa\u73af\uff0c\u5e94\u52a0\u5165\u5224\u65ad \u5224\u65adltag\u662f\u5426\u5df2\u7ecf\u7ebf\u7d22\u5316\uff0c\u5982\u679c\u8fd8\u672a\u7ebf\u7d22\u5316\uff0c\u518d\u8fdb\u884cPreThread if(T->ltag==0) { PreThread(T->lchild) } 6.4 \u7ebf\u7d22\u4e8c\u53c9\u6811\u4e2d\u627e\u524d\u9a71\u540e\u7ee7 6.4.1\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u4e2d\u5e8f\u540e\u7ee7next \u82e5p->rtag==1\uff0c\u5219next=p->rchild \u82e5p->rtag==0 left root right left root (left root right) left root ((left root right) root right) \u627e\u53f3\u5b50\u6811\u6700\u5de6\u8fb9\u8282\u70b9 6.4.2 \u627e\u6307\u5b9a\u8282\u70b9p\u7684\u4e2d\u5e8f\u524d\u9a71pre \u82e5p->ltag=1,\u5219pre=p->lchild \u82e5p->ltag=0 left root right (left root right) root right (left root (left root right)) root right \u627e\u5de6\u5b50\u6811\u7684\u6700\u53f3\u8282\u70b9 6.4.3\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u5148\u5e8f\u540e\u7ee7next \u82e5p->rtag=1,\u5219next=p->rchild \u82e5p->rtag=0,\u5219\u5fc5\u6709\u53f3\u5b69\u5b50\u8282\u70b9 - \u53ea\u6709\u53f3\u5b69\u5b50\u8282\u70b9 root right root (left root right) \u627e\u53f3\u5b69\u5b50\u8282\u70b9 - \u5177\u6709\u5de6\u53f3\u5b69\u5b50\u8282\u70b9 root left right root (root left right) right root ((root left right) left right) right \u627e\u5de6\u5b69\u5b50\u8282\u70b9 6.4.4\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u5148\u5e8f\u524d\u9a71pre \u7528\u4e09\u53c9\u94fe\u8868\uff0c\u627e\u5230\u4e00\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\uff08\u524d\u9a71\u8282\u70b9\uff09 p\u662f\u5de6\u5b69\u5b50\u8282\u70b9\uff08p\u53f3\u5144\u5f1f\u8282\u70b9\uff09 root left right p\u7684\u524d\u9a71\u662froot p\u662f\u53f3\u5b69\u5b50\u8282\u70b9\uff08\u5de6\u5b69\u5b50\u8282\u70b9\u4e3a\u7a7a\uff09 root right root (root left right) p\u7684\u524d\u9a71\u662froot p\u662f\u53f3\u5b69\u5b50\u8282\u70b9\uff0croot\u6709\u5de6\u5b69\u5b50\u8282\u70b9 root left right root (root left right) right root (root left (root left right)) right p\u7684\u524d\u9a71\u662f\u5de6\u5b69\u5b50\u8282\u70b9\u7684\u6700\u53f3\u4e0b\u65b9\u8282\u70b9 p\u662f\u6839\u8282\u70b9\uff0cp\u6ca1\u6709\u5148\u5e8f\u524d\u9a71 6.4.5\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u540e\u5e8f\u540e\u7ee7next \u7528\u4e09\u53c9\u94fe\u8868\uff0c\u627e\u5230\u4e00\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\uff08\u524d\u9a71\u8282\u70b9\uff09 p->rtag=1,\u5219next=p->rchild p->rtag=0\uff0c\u5219\u5fc5\u6709\u53f3\u5b50\u6811 - p\u662f\u53f3\u5b69\u5b50\uff0c\u6709\u5144\u5f1f\u8282\u70b9 left right root left right (left right root) \u627e\u6839\u8282\u70b9 - p\u662f\u5de6\u5b69\u5b50\uff0c\u53f3\u5144\u5f1f\u4e3a\u7a7a left root (left right root) root \u627e\u6839\u7ed3\u5e95\u54ea - p\u662f\u5de6\u5b69\u5b50\uff0c\u53f3\u5b69\u5b50\u4e0d\u7a7a left right root left (left right root) right left ((left right root) right root) right \u627e\u53f3\u5b69\u5b50\u7684\u6700\u5de6\u4e0b\u65b9\u8282\u70b9 6.4.6\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u540e\u5e8f\u524d\u9a71pre p->ltag=1,\u5219pre=p->lchild p->ltag=0,\u5219\u5fc5\u6709\u5de6\u5b50\u6811 - \u53ea\u6709\u5de6\u5b69\u5b50\u8282\u70b9 left root (left right root) root \u627e\u5de6\u5b69\u5b50\u8282\u70b9 - \u6709\u5de6\u53f3\u5b69\u5b50\u8282\u70b9 left right root left (left right root) root \u627e\u53f3\u5b69\u5b50\u8282\u70b9 test","title":"5.\u6811"},{"location":"DataStruct/tree/tree/#tree","text":"\u6811\u662fn\uff08n>=0\uff09\u4e2a\u8282\u70b9\u7684\u6709\u9650\u96c6\uff0c\u5f53n=0\u65f6\uff0c\u79f0\u4e3a\u7a7a\u6811\uff0c \u200b \u5728\u4efb\u610f\u4e00\u68f5\u975e\u7a7a\u6811\u4e2d\u5e94\u8be5\u6ee1\u8db3\uff1a \u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u7279\u5b9a\u7684\u79f0\u4e3a\u6839\u7684\u8282\u70b9 \u5f53n>1\u65f6\uff0c\u5176\u4f59\u8282\u70b9\u53ef\u4ee5\u5206\u4e3am\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u7684\u6709\u9650\u96c6 T1,T2,...,Tm\uff0c\u6bcf\u4e2a\u96c6\u5408\u672c\u8eab\u53c8\u662f\u4e00\u68f5\u6811\uff0c\u5e76\u4e14\u79f0\u4e3a\u6839\u7684\u5b50\u6811 \u200b \uff08\u4ee5\u4e0a\u662f\u6811\u7684\u9012\u5f52\u5b9a\u4e49\uff09 \u6811\u4f5c\u4e3a\u4e00\u79cd\u903b\u8f91\u7ed3\u6784\uff0c\u540c\u65f6\u4e5f\u662f\u4e00\u79cd\u5206\u5c42\u7ed3\u6784 - \u6811\u7684\u6839\u8282\u70b9\u6ca1\u6709\u524d\u9a71\uff0c\u9664\u53bb\u6839\u8282\u70b9\u4ee5\u5916\uff0c\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u524d\u9a71 - \u6811\u7684\u6240\u6709\u8282\u70b9\u90fd\u53ef\u4ee5\u67090\u4e2a\u6216\u8005\u591a\u4e2a\u540e\u7ee7","title":"\u6811 (Tree)"},{"location":"DataStruct/tree/tree/#1","text":"\u4e8c\u53c9\u6811\u662f\u6811\uff0c\u4f46\u4e8c\u53c9\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u4e0a\u6700\u591a\u6709\u4e24\u68f5\u5b50\u6811\uff08\u5373\u4e8c\u53c9\u6811\u4e2d\u4e0d\u5b58\u5728\u5ea6\u5927\u4e8e2\u7684\u8282\u70b9\uff09\uff0c \u5e76\u4e14\u4e8c\u53c9\u6811\u7684\u5b50\u6811\u6709\u5de6\u53f3\u4e4b\u5206\uff0c\u4e0d\u80fd\u98a0\u5012\u987a\u5e8f\uff0c \u540c\u65f6\uff0c\u4e8c\u53c9\u6811\u4e5f\u9075\u5b88\u6811\u7684\u9012\u5f52\u5b9a\u4e49 \u6ee1\u4e8c\u53c9\u6811\u4e0e\u5b8c\u5168\u4e8c\u53c9\u6811 \u6bcf\u4e00\u5c42\u7684\u8282\u70b9\u6570\u90fd\u6ee1\u8db32^(\u5c42\u6570-1)\uff0c\u5c31\u662f\u6ee1\u4e8c\u53c9\u6811","title":"1. \u524d\u620f"},{"location":"DataStruct/tree/tree/#2","text":"\u200b \u6811\u8282\u70b9\u7684\u6570\u636e\u7ed3\u6784 \u200b \u4f7f\u7528\u94fe\u5f0f\u7ed3\u6784\u5b9e\u73b0 typedef char BiElemtype typedef struct BiTNode{ BiElemtype c; struct BiTNode *lchild; struct BiTNode *rchild; }BiTNOde,*BiTree; typedef struct tage{ BiTree p; struct tag *pnext; }tag_t,*ptag_t;","title":"2. \u4e8c\u53c9\u6811\u7684\u94fe\u5f0f\u5b58\u50a8"},{"location":"DataStruct/tree/tree/#3","text":"\u5c42\u6b21\u5efa\u7acb\u4e8c\u53c9\u6811\uff0c\u5fc5\u987b\u4f7f\u7528 \u8f85\u52a9\u961f\u5217 \u6b65\u9aa4\u5927\u81f4\u5982\u4e0b\uff1a \u58f0\u660e\u4e8c\u53c9\u6811\u7684\u65b0\u7ed3\u70b9\uff0c\u6811\u6839\uff08\u7ed3\u6784\u4f53\u6307\u9488\uff09 \u58f0\u660e\u8f85\u52a9\u961f\u5217\u7684\u5934\u8282\u70b9\uff0c\u5c3e\u8282\u70b9\uff0c\u65b0\u8282\u70b9\uff0c\u5f53\u524d\u8282\u70b9\uff08\u7ed3\u6784\u4f53\u6307\u9488\uff09 \u8fdb\u5165\u5faa\u73af \u4e3a\u8f85\u52a9\u961f\u5217\u63d2\u5165\u65b0\u7684\u8f85\u52a9\u961f\u5217\u8282\u70b9\uff0c\u540c\u65f6\u5c3e\u6307\u9488\u540e\u79fbptail=ptail->next \u6bcf\u6b21\u5224\u65ad\u5f53\u524d\u63d2\u5165\u7684\u8282\u70b9\uff08pcur\uff09\u6307\u5411\u7684\u8282\u70b9\u7684\u5de6\u53f3\u5b69\u5b50\u8282\u70b9\u662f\u5426\u4e3a\u7a7a \u5f53\u53f3\u5b69\u5b50\u8282\u70b9\u88ab\u63d2\u5165\u540e\uff0cpcur=pcur->next \u4ee3\u7801\uff1a function.h // // Created by \u738b\u4e00\u5ddd on 2022/11/17. // #ifndef CREATE_TREE_FUNCTION_H #define CREATE_TREE_FUNCTION_H #endif //CREATE_TREE_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct BiTNode { BiElemType c;//c \u5c31\u662f\u4e66\u7c4d\u4e0a\u7684 data struct BiTNode *lchild; struct BiTNode *rchild; struct BiTNode *lchild; } BiTNode, *BiTree; //tag \u7ed3\u6784\u4f53\u662f\u8f85\u52a9\u961f\u5217\u4f7f\u7528\u7684 typedef struct tag { BiTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; } tag_t, *ptag_t; main.cpp #include \"function.h\" int main() { BiTree pnew; char c; //\u521d\u59cb\u5316\u6811\u6839\u4e3a\u7a7a BiTree tree = NULL; //\u8f85\u52a9\u961f\u5217 ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (BiTree) calloc(1, sizeof(BiTNode)); pnew->c = c; //\u7ed9\u8f85\u52a9\u961f\u5217\u8282\u70b9\u7533\u8bf7\u7a7a\u95f4 listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else { ptail->pnext = listpnew; ptail = listpnew; } if (NULL == pcur->p->lchild) { pcur->p->lchild = pnew; } else if (NULL == pcur->p->rchild) { pcur->p->rchild = pnew; pcur = pcur->pnext; } } return 0; }","title":"3.\u4e8c\u53c9\u6811\u7684\u5efa\u7acb\u8fc7\u7a0b"},{"location":"DataStruct/tree/tree/#4","text":"","title":"4.\u4e8c\u53c9\u6811\u7684\u904d\u5386"},{"location":"DataStruct/tree/tree/#1_1","text":"\u5982\u679c\u4e8c\u53c9\u6811\u4e3a\u7a7a \u8bbf\u95ee\u6839\u8282\u70b9 \u524d\u5e8f\u904d\u5386\u5de6\u5b50\u6811 \u524d\u5e8f\u904d\u5386\u53f3\u5b50\u6811 \u524d\u5e8f\u904d\u5386 void preOrder(BiTree p) { if(p!=NULL) { putchar(p->c); preOrder(p->lchild); preOrder(p->rchild); } } \u4e2d\u5e8f\u904d\u5386 void InOrder(BiTree p) { if(p!=NULL) { InOrder(p->lchild); putchar(p->c); InOrder(p->rchild); } } \u540e\u5e8f\u904d\u5386 void PostOrder(BiTree p) { if(p!=NULL) { PostOrder(p->lchild); PostOrder(p->rchild); putchar(p->c); } }","title":"1.\u904d\u5386\u7684\u9012\u5f52\u7b97\u6cd5"},{"location":"DataStruct/tree/tree/#2_1","text":"\u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386\u7684\u8fc7\u7a0b\uff1a \u6cbf\u7740\u6839\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u8282\u70b9\u6df1\u5165\u5e76\u4e14\u4f9d\u6b21\u5165\u6808\uff0c\u76f4\u5230\u5de6\u5b69\u5b50\u8282\u70b9\u4e3a\u7a7a \u8f93\u51fa\u6b64\u65f6\u7684\u6808\u9876\u5143\u7d20\u5e76\u4e14pop\u6808\u9876\u5143\u7d20 \u5982\u679c\u53f3\u5b69\u5b50\u8282\u70b9\u4e3a\u7a7a\u5219\u6267\u884cstep2\uff0c\u5982\u679c\u53f3\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u627e\u53f3\u5b69\u5b50\u7684\u6700\u5de6\u8282\u70b9 \u5faa\u73af\u7ed3\u675f\uff0c\u6240\u6709\u5143\u7d20\u51fa\u6808 \u4ee3\u7801\uff1a \u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386 void InOrder(BiTree T) { SqStack S; InitStack(S); BiTree p=T; while (p||!StackEmpty(S)) { if(p) { Push(S,p); p=p->lchild; } else{ Pop(S,p); putchar(p->c); p=p->rchild; } } } \u8f85\u52a9\u6808 #include <stdio.h> #include <stdlib.h> #define MaxSize 50 typedef BiTree ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S); bool StackEmpty(SqStack S); bool Push(SqStack &S,ElemType x); bool Pop(SqStack &S,ElemType &x); bool GetTop(SqStack S,ElemType &x); \u5168\u90e8\u4ee3\u7801\uff1a function.h // // Created by \u738b\u4e00\u5ddd on 2022/11/18. // #ifndef TREE_NONRECURSIVE_FUNCTION_H #define TREE_NONRECURSIVE_FUNCTION_H #endif //TREE_NONRECURSIVE_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct BiTNode { BiElemType c; struct BiTNode *rchild; struct BiTNode *lchild; } BiTNode, *BiTree; typedef struct tag { BiTree p; struct tag *pnext; } tag_t, *ptag_t; #include <stdio.h> #include <stdlib.h> #define MaxSize 50 typedef BiTree ElemType; typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack &S); bool StackEmpty(SqStack S); bool Push(SqStack &S,ElemType x); bool Pop(SqStack &S,ElemType &x); bool GetTop(SqStack S,ElemType &x); stack.cpp #include \"function.h\" void InitStack(SqStack &S) { S.top=-1; } bool StackEmpty(SqStack S) { if(S.top==-1) { return true; } else{ return false; } } bool Push(SqStack &S,ElemType x) { if(S.top==MaxSize-1) { return false; } S.data[++S.top]=x; return true; } bool Pop(SqStack &S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top--]; return true; } bool GetTop(SqStack S,ElemType &x) { if(S.top==-1) { return false; } x=S.data[S.top]; return true; } main.cpp #include \"function.h\" //\u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386 void InOrder(BiTree T) { SqStack S; InitStack(S); BiTree p=T; while (p||!StackEmpty(S)) { if(p) { Push(S,p); p=p->lchild; } else{ Pop(S,p); putchar(p->c); p=p->rchild; } } } int main() { BiTree pnew; BiTree tree=NULL; ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; char c; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (BiTree) calloc(1, sizeof(BiTNode)); pnew->c = c; listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else{ ptail->pnext=listpnew; ptail=listpnew; } if(NULL== pcur->p->lchild) { pcur->p->lchild=pnew; } else if(NULL== pcur->p->rchild) { pcur->p->rchild=pnew; pcur=pcur->pnext; } } InOrder(tree); return 0; }","title":"2.\u4e2d\u5e8f\u904d\u5386\u7684\u975e\u9012\u5f52\u7b97\u6cd5"},{"location":"DataStruct/tree/tree/#3_1","text":"\u5c42\u6b21\u904d\u5386\u5fc5\u987b\u4f7f\u7528\u8f85\u52a9\u961f\u5217 \u5c42\u5e8f\u904d\u5386\u7684\u8fc7\u7a0b\uff1a \u5c06\u6811\u6839\u5165\u961f \u8fdb\u5165\u5faa\u73af\uff0c\u6bcf\u6b21\u5faa\u73af\u961f\u5217\u51fa\u961f\u4e00\u6b21 \u51fa\u961f\u4e4b\u540e\u5224\u65ad\u5de6\u53f3\u5b50\u6811\u662f\u5426\u4e3a\u7a7a\uff0c\u4e0d\u4e3a\u7a7a\u5219\u5165\u961f \u5faa\u73af\u7684\u6761\u4ef6\u662f\u961f\u5217\u4e2d\u8fd8\u6709\u8282\u70b9\uff08\u5143\u7d20\uff09 \u5c42\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u4f1a\u5c06\u5143\u7d20\u6309\u7167 \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 \u8f93\u51fa \u4ee3\u7801\uff1a \u5c42\u5e8f\u904d\u5386\u51fd\u6570 void LevelOrder(BiTree T) { LinkQueue Q; InitQueue(Q); BiTree p; //\u7528\u6765\u63a5\u6536\u51fa\u961f\u7684\u5143\u7d20 EnQueue(Q,T); while (!IsEmpty(Q)) { DeQueue(Q,p); putchar(p->c); if(p->lchild) { EnQueue(Q,p->lchild); } if(p->rchild) { EnQueue(Q,p->rchild); } } } function.h // // Created by \u738b\u4e00\u5ddd on 2022/11/18. // #ifndef TREE_HIERARCHICTRAVERSAL_FUNCTION_H #define TREE_HIERARCHICTRAVERSAL_FUNCTION_H #endif //TREE_HIERARCHICTRAVERSAL_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct BiTNode { BiElemType c; struct BiTNode *rchild; struct BiTNode *lchild; } BiTNode, *BiTree; typedef struct tag { BiTree p; struct tag *pnext; } tag_t, *ptag_t; //\u961f\u5217\u7684\u7ed3\u6784\u4f53 typedef BiTree ElemType; typedef struct LinkNode { ElemType data; struct LinkNode *next; } LinkNode, *LinkList; typedef struct LinkQueue { LinkNode *front, *rear; } LinkQueue; void InitQueue(LinkQueue &Q); void EnQueue(LinkQueue &Q, ElemType x); bool IsEmpty(LinkQueue Q); bool DeQueue(LinkQueue &Q, ElemType &element); main.cpp #include \"function.h\" void PreOrder(BiTree p) { if(p!=NULL) { putchar(p->c); PreOrder(p->lchild); PreOrder(p->rchild); } } void LevelOrder(BiTree T) { LinkQueue Q; InitQueue(Q); BiTree p; EnQueue(Q,T); while (!IsEmpty(Q)) { DeQueue(Q,p); putchar(p->c); if(p->lchild) { EnQueue(Q,p->lchild); } if(p->rchild) { EnQueue(Q,p->rchild); } } } int main() { BiTree pnew; BiTree tree=NULL; ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; char c; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (BiTree) calloc(1, sizeof(BiTNode)); pnew->c = c; listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else{ ptail->pnext=listpnew; ptail=listpnew; } if(NULL== pcur->p->lchild) { pcur->p->lchild=pnew; } else if(NULL== pcur->p->rchild) { pcur->p->rchild=pnew; pcur=pcur->pnext; } } printf(\"-------PreOrder-------\\n\"); PreOrder(tree); printf(\"\\n\"); printf(\"-------LevelOrder-------\\n\"); LevelOrder(tree); printf(\"\\n\"); return 0; }","title":"3.\u5c42\u5e8f\u904d\u5386\u7b97\u6cd5"},{"location":"DataStruct/tree/tree/#5tree-2014-41","text":"41.(13\u5206) \u4e8c\u53c9\u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6(WPL)\u662f\u4e8c\u53c9\u6811\u4e2d\u6240\u6709\u53f6\u7ed3\u70b9\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6 \u4e4b\u548c\u3002\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811 T\uff0c\u91c7\u7528\u4e8c\u53c9\u94fe\u8868\u5b58\u50a8\uff0c\u7ed3\u70b9\u7ed3\u6784\u5982\u4e0b: left|weight|right \u5176\u4e2d\u53f6\u8282\u70b9\u7684weight\u57df\u4fdd\u5b58\u8be5\u8282\u70b9\u7684\u975e\u8d1f\u6743\u503c\u3002\u8bberoot\u4e3a\u6307\u5411T\u7684\u6839\u8282\u70b9\u7684\u6307\u9488\uff0c\u8bf7\u8bbe\u8ba1\u6c42T\u7684WPL\u7b97\u6cd5\uff0c\u8981\u6c42\uff1a \u7ed9\u51fa\u7b97\u6cd5\u7684\u57fa\u672c\u8bbe\u8ba1\u601d\u60f3 \u4f7f\u7528C/C++\u8bed\u8a00\uff0c\u7ed9\u51fa\u4e8c\u53c9\u6811\u8282\u70b9\u7684\u6570\u636e\u7c7b\u578b\u5b9a\u4e49 \u6839\u636e\u8bbe\u8ba1\u601d\u60f3\uff0c\u91c7\u7528C/C++\u8bed\u8a00\u63cf\u8ff0\u7b97\u6cd5 \u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6(Weighted Path Length of Tree\uff0c\u7b80\u8bb0\u4e3a WPL \u8003\u67e5\u4e8c\u53c9\u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6\uff0c\u4e8c\u53c9\u6811\u7684\u5e26\u6743\u8def\u5f84\u957f\u5ea6\u4e3a\u6bcf\u4e2a\u53f6\u5b50\u7ed3\u70b9\u7684\u6df1\u5ea6\u4e0e\u6743\u503c\u4e4b\u79ef\u7684\u603b\u548c\uff0c\u53ef\u4ee5\u4f7f\u7528\u5148\u5e8f\u904d\u5386\u6216\u5c42\u6b21\u904d\u5386\u89e3\u51b3\u95ee\u9898\u3002 \u7b97\u6cd5\u7684\u8bbe\u8ba1\u601d\u60f3 \u57fa\u4e8e\u5148\u5e8f\u9012\u5f52\u904d\u5386\u7684\u7b97\u6cd5\u601d\u60f3\u662f\u7528\u4e00\u4e2a static \u53d8\u91cf\u8bb0\u5f55 wpl\uff0c \u628a\u6bcf\u4e2a\u7ed3\u70b9\u7684\u6df1\u5ea6\u4f5c\u4e3a \u9012\u5f52\u51fd\u6570\u7684\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\uff0c \u7b97\u6cd5\u6b65\u9aa4\u5982\u4e0b: \u82e5\u8be5\u7ed3\u70b9\u662f\u53f6\u5b50\u7ed3\u70b9\uff0c\u90a3\u4e48\u53d8\u91cf wpl \u52a0\u4e0a\u8be5\u7ed3\u70b9\u7684\u6df1\u5ea6\u4e0e\u6743\u503c\u4e4b\u79ef; \u82e5\u8be5\u7ed3\u70b9\u975e\u53f6\u5b50\u7ed3\u70b9\uff0c\u90a3\u4e48\u82e5\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u5bf9\u5de6\u5b50\u6811\u8c03\u7528\u9012\u5f52\u7b97\u6cd5\uff0c \u82e5\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c \u5bf9\u53f3\u5b50\u6811\u8c03\u7528\u9012\u5f52\u7b97\u6cd5\uff0c\u6df1\u5ea6\u53c2\u6570\u5747\u4e3a\u672c\u7ed3\u70b9\u7684\u6df1\u5ea6\u53c2\u6570\u52a0\u4e00; \u6700\u540e\u8fd4\u56de\u8ba1\u7b97\u51fa\u7684 wpl \u5373\u53ef\u3002 \u4e8c\u53c9\u6811\u8282\u70b9\u7684\u6570\u636e\u7c7b\u578b\u5b9a\u4e49 typedef int BiElemType; typedef struct BiTNode{ BiElemType weight; struct BiTNode *lchild; struct BiTNode *rchild; }BiTNode,*BiTree; C++\u63cf\u8ff0 function.h // // Created by 41507 on 2022/11/9. // #ifndef INC_1_TREE_FUNCTION_H #define INC_1_TREE_FUNCTION_H #include <stdio.h> #include <stdlib.h> typedef int BiElemType; typedef struct BiTNode{ BiElemType weight;//c\u5c31\u662f\u4e66\u7c4d\u4e0a\u7684data struct BiTNode *lchild; struct BiTNode *rchild; }BiTNode,*BiTree; //tag\u7ed3\u6784\u4f53\u662f\u8f85\u52a9\u961f\u5217\u4f7f\u7528\u7684 typedef struct tag{ BiTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; }tag_t,*ptag_t; #endif //INC_1_TREE_FUNCTION_H main.cpp #include \"function.h\" //int wpl=0; //\u524d\u5e8f\u904d\u5386\uff0c\u4e5f\u53eb\u5148\u5e8f\u904d\u5386\uff0c\u4e5f\u662f\u6df1\u5ea6\u4f18\u5148\u904d\u5386 int PreOrder(BiTree p,int deep) { static int wpl=0;//\u53ea\u4f1a\u521d\u59cb\u5316\u4e00\u6b21 if(p!=NULL) { // printf(\"ele%c--%d\\n\", p->c,deep); if(p->lchild==NULL&&p->rchild==NULL) { wpl=wpl+p->weight*deep; } PreOrder(p->lchild,deep+1);//\u6253\u5370\u5de6\u5b50\u6811 PreOrder(p->rchild,deep+1);//\u6253\u5370\u53f3\u5b50\u6811 } return wpl; } int main() { BiTree pnew;//\u7528\u6765\u6307\u5411\u65b0\u7533\u8bf7\u7684\u6811\u7ed3\u70b9 BiTree tree=NULL;//tree\u662f\u6307\u5411\u6811\u6839\u7684\uff0c\u4ee3\u8868\u6811 char c; ptag_t phead=NULL,ptail=NULL,listpnew=NULL,pcur; //abcdefghij while(scanf(\"%c\",&c)) { if(c=='\\n') { break;//\u8bfb\u53d6\u5230\u6362\u884c\u5c31\u7ed3\u675f } //calloc\u7533\u8bf7\u7684\u7a7a\u95f4\u5927\u5c0f\u662f\u4e24\u4e2a\u53c2\u6570\u76f4\u63a5\u76f8\u4e58\uff0c\u5e76\u5bf9\u7a7a\u95f4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u8d4b\u503c\u4e3a0 pnew= (BiTree)calloc(1,sizeof(BiTNode)); pnew->weight=c; listpnew= (ptag_t)calloc(1,sizeof(tag_t));//\u7ed9\u961f\u5217\u7ed3\u70b9\u7533\u8bf7\u7a7a\u95f4 listpnew->p=pnew; //\u5982\u679c\u662f\u6811\u7684\u7b2c\u4e00\u4e2a\u7ed3\u70b9 if(NULL==tree) { tree=pnew;//tree\u6307\u5411\u6811\u7684\u6839\u7ed3\u70b9 phead=listpnew;//\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u5373\u662f\u961f\u5217\u5934\uff0c\u4e5f\u662f\u961f\u5217\u5c3e ptail=listpnew; pcur=listpnew;//pcur\u8981\u6307\u5411\u8981\u8fdb\u5165\u6811\u7684\u7236\u4eb2\u5143\u7d20 }else{ //\u8ba9\u5143\u7d20\u5148\u5165\u961f\u5217 ptail->pnext=listpnew; ptail=listpnew; //\u63a5\u4e0b\u6765\u628a\u7ed3\u70b9\u653e\u5165\u6811\u4e2d if(NULL==pcur->p->lchild) { pcur->p->lchild=pnew;//pcur->p\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c31\u653e\u5165\u5de6\u5b69\u5b50 }else if(NULL==pcur->p->rchild) { pcur->p->rchild=pnew;//pcur->p\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c31\u653e\u5165\u53f3\u5b69\u5b50 pcur=pcur->pnext;//\u5f53\u524d\u7ed3\u70b9\u5de6\u53f3\u5b69\u5b50\u90fd\u6709\u4e86\uff0cpcur\u5c31\u6307\u5411\u4e0b\u4e00\u4e2a } } } printf(\"--------PreOrder----------\\n\");//\u4e5f\u53eb\u5148\u5e8f\u904d\u5386\uff0c\u5148\u6253\u5370\u5f53\u524d\u7ed3\u70b9\uff0c\u6253\u5370\u5de6\u5b69\u5b50\uff0c\u6253\u5370\u53f3\u5b69\u5b50 printf(\"wpl=%d\\n\",PreOrder(tree,0));//wpl\u7edf\u8ba1\u7684\u662f\u8def\u5f84\uff0c\u56e0\u6b64\u4e00\u5f00\u59cb\u5e94\u8be5\u4f20\u5165\u7684\u662f0 return 0; }","title":"5.tree-2014-41"},{"location":"DataStruct/tree/tree/#6","text":"\u7ebf\u7d22\u4e8c\u53c9\u6811\u7684\u4f5c\u7528\u662f \u65b9\u4fbf\u4ece\u4e00\u4e2a\u6307\u5b9a\u8282\u70b9\u51fa\u53d1\uff0c\u627e\u5230\u5176\u524d\u9a71\uff0c\u540e\u7ee7\uff0c\u4fbf\u4e0e\u4e8c\u53c9\u6811\u904d\u5386 \u5c06\u4e8c\u53c9\u6811\u6309\u7167\u67d0\u79cd\u904d\u5386\u89c4\u5219\uff08\u524d/\u4e2d/\u540e\u5e8f\u904d\u5386\uff09\u8f93\u51fa\u540e\uff0c\u5f97\u5230\u7684\u7ebf\u6027\u5e8f\u5217\uff0c \u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u6709\u4e00\u4e2a\u76f4\u63a5\u524d\u9a71\u548c\u76f4\u63a5\u540e\u7ee7 \u4f8b\u5982\uff1a","title":"6.\u7ebf\u7d22\u4e8c\u53c9\u6811"},{"location":"DataStruct/tree/tree/#61","text":"\u7ebf\u7d22\u4e8c\u53c9\u6811\u7684\u5b58\u50a8\u7ed3\u6784\u4e0e\u8f85\u52a9\u961f\u5217 typedef char BiElemType; typedef struct ThreadNode { BiElemType c; struct ThreadNode *rchild; struct ThreadNode *lchild; int ltag, rtag; } ThreadNode, *ThreadTree; typedef struct tag { ThreadTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; } tag_t, *ptag_t; \u5168\u5c40\u53d8\u91cf\uff1a ThreadNode *target; ThreadNode *pre = NULL; ThreadNode *final = NULL; \u7ebf\u7d22\u5316\uff1a // \u8bbf\u95ee\u8282\u70b9q\uff0c\u627e\u5b83\u7684\u524d\u9a71\u8282\u70b9pre void Visit(ThreadTree q) { if (q->lchild == NULL) { q->lchild = pre; q->ltag = 1; } if (pre != NULL && pre->rchild == NULL) { pre->rchild = q; pre->rtag = 1; } pre=q; } void InThread(ThreadTree T) { if (T != NULL) { InThread(T->lchild); Visit(T); InThread(T->rchild); } } void CreateInThread(ThreadTree T) { pre=NULL; if(T!=NULL) { InThread(T); if(pre->rchild == NULL) { pre->rtag = 1; } } } \u4ee5\u5982\u4e0b\u7684\u4e8c\u53c9\u6811\u4e3a\u4f8b\uff1a","title":"6.1\u7ebf\u7d22\u5316\u8fc7\u7a0b"},{"location":"DataStruct/tree/tree/#62","text":"#include <stdio.h> #include <stdlib.h> typedef char BiElemType; typedef struct ThreadNode { BiElemType c;//c \u5c31\u662f\u4e66\u7c4d\u4e0a\u7684 data struct BiTNode *lchild; struct ThreadNode *rchild; struct ThreadNode *lchild; int ltag, rtag; } ThreadNode, *ThreadTree; //tag \u7ed3\u6784\u4f53\u662f\u8f85\u52a9\u961f\u5217\u4f7f\u7528\u7684 typedef struct tag { ThreadTree p;//\u6811\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u503c struct tag *pnext; } tag_t, *ptag_t; ThreadNode *target; ThreadNode *pre = NULL; ThreadNode *final = NULL; // \u8bbf\u95ee\u8282\u70b9q\uff0c\u627e\u5b83\u7684\u524d\u9a71\u8282\u70b9pre void Visit(ThreadTree q) { if (q->lchild == NULL) { q->lchild = pre; q->ltag = 1; } if (pre != NULL && pre->rchild == NULL) { pre->rchild = q; pre->rtag = 1; } pre=q; } void InThread(ThreadTree T) { if (T != NULL) { InThread(T->lchild); Visit(T); InThread(T->rchild); } } void CreateInThread(ThreadTree T) { pre=NULL; if(T!=NULL) { InThread(T); if(pre->rchild == NULL) { pre->rtag = 1; } } } void preOrder(ThreadTree p) { if (p != NULL) { putchar(p->c); preOrder(p->lchild); preOrder(p->rchild); } } int main() { ThreadTree pnew; ThreadTree tree = NULL; char c; ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL; while (scanf(\"%c\", &c)) { if (c == '\\n') { break; } pnew = (ThreadTree) calloc(1, sizeof(ThreadNode)); pnew->c = c; pnew->rtag = 0; pnew->ltag = 0; listpnew = (ptag_t) calloc(1, sizeof(tag_t)); listpnew->p = pnew; if (NULL == tree) { tree = pnew; phead = listpnew; ptail = listpnew; pcur = listpnew; continue; } else { ptail->pnext = listpnew; ptail = listpnew; } if (NULL == pcur->p->lchild) { pcur->p->lchild = pnew; } else if (NULL == pcur->p->rchild) { pcur->p->rchild = pnew; pcur = pcur->pnext; } } preOrder(tree); CreateInThread(tree); return 0; }","title":"6.2\u7ebf\u7d22\u5316\u5168\u90e8\u4ee3\u7801"},{"location":"DataStruct/tree/tree/#63","text":"\u5148\u5e8f\u904d\u5386\u5e8f\u5217\uff1a A BDGE CF \u5982\u679c\u8bbf\u95ee\u5230D\uff0c\u5219\u4f1a\u51fa\u73b0 D->lchild=B \u9020\u6210\u65e0\u9650\u5faa\u73af\uff0c\u5e94\u52a0\u5165\u5224\u65ad \u5224\u65adltag\u662f\u5426\u5df2\u7ecf\u7ebf\u7d22\u5316\uff0c\u5982\u679c\u8fd8\u672a\u7ebf\u7d22\u5316\uff0c\u518d\u8fdb\u884cPreThread if(T->ltag==0) { PreThread(T->lchild) }","title":"6.3 \u5148\u5e8f\u7ebf\u7d22\u5316\u4e2d\u65e0\u9650\u5faa\u73af\u95ee\u9898"},{"location":"DataStruct/tree/tree/#64","text":"6.4.1\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u4e2d\u5e8f\u540e\u7ee7next \u82e5p->rtag==1\uff0c\u5219next=p->rchild \u82e5p->rtag==0 left root right left root (left root right) left root ((left root right) root right) \u627e\u53f3\u5b50\u6811\u6700\u5de6\u8fb9\u8282\u70b9 6.4.2 \u627e\u6307\u5b9a\u8282\u70b9p\u7684\u4e2d\u5e8f\u524d\u9a71pre \u82e5p->ltag=1,\u5219pre=p->lchild \u82e5p->ltag=0 left root right (left root right) root right (left root (left root right)) root right \u627e\u5de6\u5b50\u6811\u7684\u6700\u53f3\u8282\u70b9 6.4.3\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u5148\u5e8f\u540e\u7ee7next \u82e5p->rtag=1,\u5219next=p->rchild \u82e5p->rtag=0,\u5219\u5fc5\u6709\u53f3\u5b69\u5b50\u8282\u70b9 - \u53ea\u6709\u53f3\u5b69\u5b50\u8282\u70b9 root right root (left root right) \u627e\u53f3\u5b69\u5b50\u8282\u70b9 - \u5177\u6709\u5de6\u53f3\u5b69\u5b50\u8282\u70b9 root left right root (root left right) right root ((root left right) left right) right \u627e\u5de6\u5b69\u5b50\u8282\u70b9 6.4.4\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u5148\u5e8f\u524d\u9a71pre \u7528\u4e09\u53c9\u94fe\u8868\uff0c\u627e\u5230\u4e00\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\uff08\u524d\u9a71\u8282\u70b9\uff09 p\u662f\u5de6\u5b69\u5b50\u8282\u70b9\uff08p\u53f3\u5144\u5f1f\u8282\u70b9\uff09 root left right p\u7684\u524d\u9a71\u662froot p\u662f\u53f3\u5b69\u5b50\u8282\u70b9\uff08\u5de6\u5b69\u5b50\u8282\u70b9\u4e3a\u7a7a\uff09 root right root (root left right) p\u7684\u524d\u9a71\u662froot p\u662f\u53f3\u5b69\u5b50\u8282\u70b9\uff0croot\u6709\u5de6\u5b69\u5b50\u8282\u70b9 root left right root (root left right) right root (root left (root left right)) right p\u7684\u524d\u9a71\u662f\u5de6\u5b69\u5b50\u8282\u70b9\u7684\u6700\u53f3\u4e0b\u65b9\u8282\u70b9 p\u662f\u6839\u8282\u70b9\uff0cp\u6ca1\u6709\u5148\u5e8f\u524d\u9a71 6.4.5\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u540e\u5e8f\u540e\u7ee7next \u7528\u4e09\u53c9\u94fe\u8868\uff0c\u627e\u5230\u4e00\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\uff08\u524d\u9a71\u8282\u70b9\uff09 p->rtag=1,\u5219next=p->rchild p->rtag=0\uff0c\u5219\u5fc5\u6709\u53f3\u5b50\u6811 - p\u662f\u53f3\u5b69\u5b50\uff0c\u6709\u5144\u5f1f\u8282\u70b9 left right root left right (left right root) \u627e\u6839\u8282\u70b9 - p\u662f\u5de6\u5b69\u5b50\uff0c\u53f3\u5144\u5f1f\u4e3a\u7a7a left root (left right root) root \u627e\u6839\u7ed3\u5e95\u54ea - p\u662f\u5de6\u5b69\u5b50\uff0c\u53f3\u5b69\u5b50\u4e0d\u7a7a left right root left (left right root) right left ((left right root) right root) right \u627e\u53f3\u5b69\u5b50\u7684\u6700\u5de6\u4e0b\u65b9\u8282\u70b9 6.4.6\u627e\u6307\u5b9a\u8282\u70b9p\u7684\u540e\u5e8f\u524d\u9a71pre p->ltag=1,\u5219pre=p->lchild p->ltag=0,\u5219\u5fc5\u6709\u5de6\u5b50\u6811 - \u53ea\u6709\u5de6\u5b69\u5b50\u8282\u70b9 left root (left right root) root \u627e\u5de6\u5b69\u5b50\u8282\u70b9 - \u6709\u5de6\u53f3\u5b69\u5b50\u8282\u70b9 left right root left (left right root) root \u627e\u53f3\u5b69\u5b50\u8282\u70b9 test","title":"6.4 \u7ebf\u7d22\u4e8c\u53c9\u6811\u4e2d\u627e\u524d\u9a71\u540e\u7ee7"}]}